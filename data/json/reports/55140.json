{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": "2017-09-18T14:10:45.973Z", 
    "voters": [
        "flamezzz", 
        "nirvana-msu", 
        "sp1d3rs", 
        "bl4de", 
        "shailesh4594", 
        "reactors08", 
        "003random", 
        "akaash_pantherdefence", 
        "mdv", 
        "dor1s", 
        "and 15 more..."
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "2500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 55140, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2017-09-19T17:40:28.024Z", 
    "vulnerability_information": "Most of OAuth 2 API implementations seem to have multiple Race Condition vulnerabilities for processing requests for Access Token or Refresh Token.\r\n\r\nRace Condition allows a malicious application to obtain several `access_token` and `refresh_token` pairs while only one pair should be generated. Further, it leads to authorization bypass when access would be revoked.\r\n\r\nI've already tested for this vulnerability 11 different targets (web-services providing OAuth2 API), and 6 of them are vulnerable. Only one target seems to be certainly protected (or I just failed to catch into Race Condition time window). The rest 4 targets have Race Condition bug, but protected against further exploitation by one of the following reasons:\r\n* only one of several tokens generated is valid (**1 target**)\r\n* for any access revocation all tokens always are revoked (**1 target**)\r\n* for all concurring requests finished successfully the same `access_token` values (or in pair with `refresh_token`) obtained (**2 targets**)\r\n\r\nAt this moment I cannot list vulnerable targets here because of responsible disclosure, but I think it would be possible to publish their names soon.\r\n\r\nInitially, I thought the vulnerability is located in [Doorkeeper gem for Ruby](https://github.com/doorkeeper-gem/doorkeeper). It is very popular, and I know that some of the vulnerable targets use this gem. To be clear, I tested [OAuth 2 provider example based on it](https://github.com/doorkeeper-gem/doorkeeper-provider-app) and it was safe for me. *Honestly, I'm not ruby developer, so it is not easy for me to quickly inspect doorkeeper's code and distinguish is it vulnerable or not*.\r\n\r\nHowever, I'm sure that 6 of vulnerable targets use different implementations (at least more than one). So the attack vector seems to be universal and possible by design.\r\n\r\nRace Condition for Access Token\r\n===============================\r\nAccording to [OAuth 2.0 RFC](https://tools.ietf.org/html/rfc6749), `code` obtained via callback may be used only once to generate `access_token` (and corresponding `refresh_token`).\r\n\r\nRace Condition vulnerability allows a malicious application to generate several `access_token` and `refresh_token` pairs. This leads to authentication issue when a user will revoke access for an application. One `access_token` and `refresh_token` pair would be revoked, but all the rest stay active.\r\n\r\nProof-Of-Concept\r\n------------------------\r\n *PoC description is unified and may be used for any provider*\r\n\r\n0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\r\n\r\n1) Open link for the application authorization in browser. Usually it looks like:\r\n```\r\nhttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID&redirect_uri=https://APPLICATION_REDIRECT_URI&response_type=code\r\n```\r\n\r\n2) Log into *a victim's* account (if it needed) and allow access for the application\r\n\r\n3) Obtain `code` value from callback:\r\n```\r\nhttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\r\n```\r\n\r\n4) Try to exploit Race Condition for Access Token request. I used the following script for that:\r\n```\r\n#!/bin/bash\r\ncurl --data \"grant_type=authorization_code&code=AUTHORIZATION_CODE_VALUE&client_id=APPLICATION_ID&client_secret=APPLICATION_SECRET&redirect_uri=APPLICATION_REDIRECT_URI\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\" &\r\n< ... previous line repeated 20 times ... >\r\n```\r\n\r\nFor different attempts result of its execution gives from 1 to 20 different `access_token` values (may be in pair with `refresh_token` values) for targets which has Race Condition bug (10 of 11 tested).\r\n\r\n5) Check each `access_token`. Take the simplest request from the target API and try it for each value, like:\r\n```\r\nGET /api/me?access_token=ACCESS_TOKEN_VALUE HTTP/1.1\r\nHost: OAUTH_PROVIDER_DOMAIN\r\n\r\n```\r\n\r\nUsually all `access_token` values are valid and working.\r\n\r\n6) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\r\n\r\n7) Here execution flow has two possible directions:\r\n7A) Go to **settings** or **applications** page in the victim's account and revoke access for the application. Then repeat step 5 and see if all `access_token`s become invalid or not. If all `access_token`s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one `access_token` is revoked, while all the rest stay valid.\r\n\r\n7B) Use revocation request (like `/oauth/revoke`) for one of the `access_token`s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\r\n\r\n\r\nRace Condition for Refresh Token\r\n--------------------------------\r\nWhile `code` may be used only once to obtain `access_token`, `refresh_token` often may be used only once too. In such case, Race Condition vulnerability allows an attacker to generate huge number of `access_token` and `refresh_token` pairs. This will make it very hard for a victim to revoke access for the malicious application.\r\n\r\n0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\r\n\r\n1) Open link for the application authorization in browser. Usually it looks like:\r\n```\r\nhttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID&redirect_uri=https://APPLICATION_REDIRECT_URI&response_type=code\r\n```\r\n\r\n2) Log into *a victim's* account (if it needed) and allow access for the application\r\n\r\n3) Obtain `code` value from callback:\r\n```\r\nhttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\r\n```\r\n\r\n4) Legally obtain `access_token` and `refresh_token`. Usually it may be done by request like:\r\n```\r\ncurl --data \"grant_type=authorization_code&code=AUTHORIZATION_CODE_VALUE&client_id=APPLICATION_ID&client_secret=APPLICATION_SECRET&redirect_uri=APPLICATION_REDIRECT_URI\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\"\r\n```\r\n\r\n5) Try to exploit Race Condition for `refresh_token`. I used the following script for that:\r\n```\r\n#!/bin/bash\r\ncurl --data \"grant_type=refresh_token&refresh_token=REFRESH_TOKEN_VALUE&client_id=APPLICATION_ID&client_secret=APPLICATION_SECRET\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\" &\r\n< ... previous line repeated 20 times ... >\r\n\r\n```\r\n\r\nFor different attempts result of its execution gives from 1 to 20 different `access_token` values (may be in pair with `refresh_token` values) for targets which has Race Condition bug.\r\n\r\n6) Check obtained `access_token`s as in previous Proof-of-Concept. All of them are valid and working for API.\r\n\r\n7) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\r\n\r\n8) Here execution flow has two possible directions:\r\n8A) Go to **settings** or **applications** page in the victim's account and revoke access for the application. Then repeat step 5 and see if all `access_token`s become invalid or not. If all `access_token`s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one `access_token` is revoked, while all the rest stay valid.\r\n\r\n8B) Use revocation request (like `/oauth/revoke`) for one of the `access_token`s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\r\n\r\n\r\nExploitation for `refresh_token` is more dangerous than for `access_token`, because there is no way for an attacker to fail. Each exploitation gives at least one new `refresh_token` which may be used further. Thus, number of token pairs grows exponentially.\r\n\r\nImpact\r\n======\r\nGenerating huge number of tokens for access is serious issue which violates [OAuth framework RFC](https://tools.ietf.org/html/rfc6749) and best practices. This vulnerability deprives a victim of ability to deny access for malicious application (for most of implementations tested).\r\n\r\nBecause of target (e.g `/oauth/token`) script is vulnerable to Race Condition, there are more attack vectors than I demonstrated. For example, an application may infinitely refresh its access and user would not be able to revoke access too.\r\n\r\nPut it simply\r\n-----------------\r\nOAuth API is widespread mechanism nowadays. Number of different services and applications increases so fast, that almost no one wants to have so many different accounts for all of them. This is why OAuth is popular and important. But, on the other hand, no one wants to grant access to yet another one service/application, if he knows that it is impossible for him to revoke deny access later. This is why such bypassing of access revocation should be prevented.\r\n\r\n", 
    "activity_page_count": 1, 
    "severity": {
        "rating": "medium", 
        "author_type": "Team"
    }, 
    "title": "Race Conditions in OAuth 2 API implementations", 
    "is_member_of_team?": null, 
    "vote_count": 25, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2017-10-18T14:10:46.031Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "activity_page_number": 1, 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$2,500", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "created_at": "2015-04-08T13:31:21.071Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-04-08T13:31:21.071Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "Just to update statistics. I've tested two more OAuth providers, Both of them have Race Conditions:\n* 1 is vulnerable to abuse with multiple tokens generation\n* 1 is protected from exploitation because all tokens become revoked ", 
            "markdown_message": "<p>Just to update statistics. I&#39;ve tested two more OAuth providers, Both of them have Race Conditions:</p>\n\n<ul>\n<li>1 is vulnerable to abuse with multiple tokens generation</li>\n<li>1 is protected from exploitation because all tokens become revoked </li>\n</ul>\n", 
            "type": "Activities::Comment", 
            "id": 375049, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-04-13T23:49:48.463Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-04-13T23:49:48.463Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "Let me update statistics one more time. I've tested 5 more OAuth providers (in addition to previous research):\n* 3 are vulnerable to multiple tokens generation\n* 2 are protected against this", 
            "markdown_message": "<p>Let me update statistics one more time. I&#39;ve tested 5 more OAuth providers (in addition to previous research):</p>\n\n<ul>\n<li>3 are vulnerable to multiple tokens generation</li>\n<li>2 are protected against this</li>\n</ul>\n", 
            "type": "Activities::Comment", 
            "id": 379323, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-04-21T01:15:23.322Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-04-21T01:15:23.322Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "More updates and statistics summary at the moment:\n* 27 OAuth2 providers had been tested, of which\n* 21 had Race Condition bugs\n* 15 affected with multiple valid access tokens generated via Race Condition exploitation\n* 9   had authorization flaws caused by inappropriate access revocation processing after Race Condition exploitation", 
            "markdown_message": "<p>More updates and statistics summary at the moment:</p>\n\n<ul>\n<li>27 OAuth2 providers had been tested, of which</li>\n<li>21 had Race Condition bugs</li>\n<li>15 affected with multiple valid access tokens generated via Race Condition exploitation</li>\n<li>9   had authorization flaws caused by inappropriate access revocation processing after Race Condition exploitation</li>\n</ul>\n", 
            "type": "Activities::Comment", 
            "id": 386080, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-04-21T19:06:35.115Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-04-21T19:06:35.115Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "I was referring OAuth2.0 RFC, but not posted direct requirements which are violated by exploitable Race Condition vulnerability. Here it is:\n\n1) [https://tools.ietf.org/html/rfc6749#section-4.1.2](https://tools.ietf.org/html/rfc6749#section-4.1.2) :\n```\n                        If an authorization code is used more than\n   once, the authorization server MUST deny the request and SHOULD\n   revoke (when possible) all tokens previously issued based on\n   that authorization code.  The authorization code is bound to\n   the client identifier and redirection URI.\n```\n2) [https://tools.ietf.org/html/rfc6749#section-10.5](https://tools.ietf.org/html/rfc6749#section-10.5) :\n```\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n```", 
            "markdown_message": "<p>I was referring OAuth2.0 RFC, but not posted direct requirements which are violated by exploitable Race Condition vulnerability. Here it is:</p>\n\n<p>1) <a href=\"/redirect?signature=bd1b22c06d5ebddfa1ecb38b49af3441ee202ee3&amp;url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749%23section-4.1.2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://tools.ietf.org/html/rfc6749#section-4.1.2</span><i class=\"icon-external-link\"></i></a> :</p>\n<pre class=\"highlight plaintext\"><code>                        If an authorization code is used more than\n   once, the authorization server MUST deny the request and SHOULD\n   revoke (when possible) all tokens previously issued based on\n   that authorization code.  The authorization code is bound to\n   the client identifier and redirection URI.\n</code></pre>\n<p>2) <a href=\"/redirect?signature=220633eacb2778d6d9e34370d04171f20037f9b5&amp;url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749%23section-10.5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://tools.ietf.org/html/rfc6749#section-10.5</span><i class=\"icon-external-link\"></i></a> :</p>\n<pre class=\"highlight plaintext\"><code>   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n</code></pre>", 
            "type": "Activities::Comment", 
            "id": 386637, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-04-21T20:20:24.173Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-04-21T20:20:24.173Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "I continue my research of OAuth2 implementations and found one more wide-spread attack vector. It is related to inappropriate access revocation too, so let me describe it here in comments.\n\nDetails:\n----------\nOAuth2 API makes it possible for users to grant access to their accounts to some third-side applications. Of course, users are able to manage such applications' access to their accounts and may deny access for any application. When some user denies access for the application, all `access_token`s (and `refresh_tokens` if it used) are being revoked and become invalid. But not only `access_token`s should be revoked, authorization `code`s (it is intermediate token used in OAuth2 Authorization Flow) must be revoked too. Currently most of OAuth2 API implementations do not revoke authorization `code` during access revocation. It may be exploited to restore access to user's account by malicious application after access revocation.\n\nStatistics at the moment\n-----------------------------------\n* 21 OAuth2 providers had been tested, of which\n* 11 affected with missing invalidation for authorization code after access revocation\n* 10 invalidate all authorization codes granted for certain pair of user and application\n\nProof of Concept\n------------------------\n1) Open the link for OAuth2 authorization for some application\n2) Log into your account (if needed) and click **Allow** (or **Authorize**)\n3) Copy `code` value from callback url\n4) Use `code` value to obtain `access_token`\n5) Check validity of `access_token` by sending some API request\n6) Repeat steps 1 and 2 (for most of implementations user is automatically redirected to callback page if once access granted)\n7) Copy `code` value from callback url and save it for future usage\n8) Go to account security (or *connected applications*) settings\n9) **Delete** or **Disconnect** the application used during the PoC\n10) To ensure that access is denied, repeat step 5\n11) Use `code` value from step 7 and exchange it for `access_token`\n12) Check validity of `access_token`\n\nIf `access_token` is valid, OAuth2 Provider is affected by the vulnerability.\n\nImportant notice\n------------------------\nFor real attack scenario it is important to mention the following:\na) it seems that step 6 requires interaction with user, actually it is not necessary\nb) authorization `code` obtained via callback has certain lifetime, but it is not problem too\n\nMalicious application which does not want to lose access to the user's account just need to place on its web site something like:\n```\n<html>\n\t<img src=\"https://OAUTH2-PROVIDER-DOMAIN/oauth2/authorize?client_id=%CLIENT_ID%&response_type=code&redirect_uri=https://avuln.com/callback&state=0123456789abcdef\">\n</html>\n```\n\nSuch code will \"silently\" produce new authorization code each time it has been loaded by the user:\n```\nroot@avuln:/var/log/nginx# tail -f access.log\n<...>\n<IP hidden> - - [16/Apr/2015:13:08:56 +0000] \"GET /callback?state=0123456789abcdef&code=xlDxVYdnJlsAAAAAAAAFQDUmzla7P8Jg9fM2rNxwP8U HTTP/1.1\" 200 14 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36\"\n```\n\nImpact\n======\nThe vulnerability allows an malicious application to keep its access active to a victim's account even after access revocation. This is not only authorization bypass, but it also deprives a victim ability to manage access for an application.\n\nMitigation\n========\nFor access revocation processing all authorization `code` issued for certain pair of user and application should be invalidated (as it usually being done for `access_token` values).\n", 
            "markdown_message": "<p>I continue my research of OAuth2 implementations and found one more wide-spread attack vector. It is related to inappropriate access revocation too, so let me describe it here in comments.</p>\n\n<h2 id=\"details\">Details:</h2>\n\n<p>OAuth2 API makes it possible for users to grant access to their accounts to some third-side applications. Of course, users are able to manage such applications&#39; access to their accounts and may deny access for any application. When some user denies access for the application, all <code>access_token</code>s (and <code>refresh_tokens</code> if it used) are being revoked and become invalid. But not only <code>access_token</code>s should be revoked, authorization <code>code</code>s (it is intermediate token used in OAuth2 Authorization Flow) must be revoked too. Currently most of OAuth2 API implementations do not revoke authorization <code>code</code> during access revocation. It may be exploited to restore access to user&#39;s account by malicious application after access revocation.</p>\n\n<h2 id=\"statistics-at-the-moment\">Statistics at the moment</h2>\n\n<ul>\n<li>21 OAuth2 providers had been tested, of which</li>\n<li>11 affected with missing invalidation for authorization code after access revocation</li>\n<li>10 invalidate all authorization codes granted for certain pair of user and application</li>\n</ul>\n\n<h2 id=\"proof-of-concept\">Proof of Concept</h2>\n\n<p>1) Open the link for OAuth2 authorization for some application<br>\n2) Log into your account (if needed) and click <strong>Allow</strong> (or <strong>Authorize</strong>)<br>\n3) Copy <code>code</code> value from callback url<br>\n4) Use <code>code</code> value to obtain <code>access_token</code><br>\n5) Check validity of <code>access_token</code> by sending some API request<br>\n6) Repeat steps 1 and 2 (for most of implementations user is automatically redirected to callback page if once access granted)<br>\n7) Copy <code>code</code> value from callback url and save it for future usage<br>\n8) Go to account security (or <em>connected applications</em>) settings<br>\n9) <strong>Delete</strong> or <strong>Disconnect</strong> the application used during the PoC<br>\n10) To ensure that access is denied, repeat step 5<br>\n11) Use <code>code</code> value from step 7 and exchange it for <code>access_token</code><br>\n12) Check validity of <code>access_token</code></p>\n\n<p>If <code>access_token</code> is valid, OAuth2 Provider is affected by the vulnerability.</p>\n\n<h2 id=\"important-notice\">Important notice</h2>\n\n<p>For real attack scenario it is important to mention the following:<br>\na) it seems that step 6 requires interaction with user, actually it is not necessary<br>\nb) authorization <code>code</code> obtained via callback has certain lifetime, but it is not problem too</p>\n\n<p>Malicious application which does not want to lose access to the user&#39;s account just need to place on its web site something like:</p>\n<pre class=\"highlight html\"><code><span class=\"nt\">&lt;html&gt;</span>\n    <span class=\"nt\">&lt;img</span> <span class=\"na\">src=</span><span class=\"s\">&quot;https://OAUTH2-PROVIDER-DOMAIN/oauth2/authorize?client_id=%CLIENT_ID%&amp;response_type=code&amp;redirect_uri=https://avuln.com/callback&amp;state=0123456789abcdef&quot;</span><span class=\"nt\">&gt;</span>\n<span class=\"nt\">&lt;/html&gt;</span>\n</code></pre>\n<p>Such code will &quot;silently&quot; produce new authorization code each time it has been loaded by the user:</p>\n<pre class=\"highlight plaintext\"><code>root@avuln:/var/log/nginx# tail -f access.log\n&lt;...&gt;\n&lt;IP hidden&gt; - - [16/Apr/2015:13:08:56 +0000] &quot;GET /callback?state=0123456789abcdef&amp;code=xlDxVYdnJlsAAAAAAAAFQDUmzla7P8Jg9fM2rNxwP8U HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36&quot;\n</code></pre>\n<h1 id=\"impact\">Impact</h1>\n\n<p>The vulnerability allows an malicious application to keep its access active to a victim&#39;s account even after access revocation. This is not only authorization bypass, but it also deprives a victim ability to manage access for an application.</p>\n\n<h1 id=\"mitigation\">Mitigation</h1>\n\n<p>For access revocation processing all authorization <code>code</code> issued for certain pair of user and application should be invalidated (as it usually being done for <code>access_token</code> values).</p>\n", 
            "type": "Activities::Comment", 
            "id": 386701, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-06-17T09:48:26.415Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-06-17T09:49:15.770Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "I've already prepared detailed write-up with recommendations, but cannot make it public, because not all affected providers had fixed the vulnerabilities yet.\n\nA few updates on statistics:\n\nRace Condition issue\n----------------------------------------\n* **28** OAuth providers tested\n* **23** of **28** had race condition bug, of them:\n* **5** providers produced the same `access_token` value for successful competing requests -&gt; good behavior\n* **1** provider produce different `access_token` values, but only one value is valid -&gt; not bad behavior too\n* **17** providers produce different `access_token` values and all of them are valid -&gt; bad behaviour: **RFC violated** + **unexpected flaws** caused by multiple tokens/contexts generation **are possible**\n* **10** of **17** providers had problems with revocation of access (step 8 from PoC succeeded for them) -&gt; **the worst case**: a victim sees that access is revoked, but actually *malicious* application still has access to a victim's account\n\n\nMissing revocation of Authorization Code\n-------------------------------------------------------\n* **25** OAuth providers tested\n* **14** of **25** had the vulnerability\n\n3 OAuth providers from statistics for the first issue are not included in the second one (**28 - 25 = 3**), because they have problems with revocation - it is not implemented at all or is inaccessible for user.\n", 
            "markdown_message": "<p>I&#39;ve already prepared detailed write-up with recommendations, but cannot make it public, because not all affected providers had fixed the vulnerabilities yet.</p>\n\n<p>A few updates on statistics:</p>\n\n<h2 id=\"race-condition-issue\">Race Condition issue</h2>\n\n<ul>\n<li>\n<strong>28</strong> OAuth providers tested</li>\n<li>\n<strong>23</strong> of <strong>28</strong> had race condition bug, of them:</li>\n<li>\n<strong>5</strong> providers produced the same <code>access_token</code> value for successful competing requests -&gt; good behavior</li>\n<li>\n<strong>1</strong> provider produce different <code>access_token</code> values, but only one value is valid -&gt; not bad behavior too</li>\n<li>\n<strong>17</strong> providers produce different <code>access_token</code> values and all of them are valid -&gt; bad behaviour: <strong>RFC violated</strong> + <strong>unexpected flaws</strong> caused by multiple tokens/contexts generation <strong>are possible</strong>\n</li>\n<li>\n<strong>10</strong> of <strong>17</strong> providers had problems with revocation of access (step 8 from PoC succeeded for them) -&gt; <strong>the worst case</strong>: a victim sees that access is revoked, but actually <em>malicious</em> application still has access to a victim&#39;s account</li>\n</ul>\n\n<h2 id=\"missing-revocation-of-authorization-code\">Missing revocation of Authorization Code</h2>\n\n<ul>\n<li>\n<strong>25</strong> OAuth providers tested</li>\n<li>\n<strong>14</strong> of <strong>25</strong> had the vulnerability</li>\n</ul>\n\n<p>3 OAuth providers from statistics for the first issue are not included in the second one (<strong>28 - 25 = 3</strong>), because they have problems with revocation - it is not implemented at all or is inaccessible for user.</p>\n", 
            "type": "Activities::Comment", 
            "id": 475016, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-07-03T10:19:44.919Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-07-03T10:19:44.919Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "Two more targets tested, both have race condition, one has problem with code revocation. The issue is very widely spread :)", 
            "markdown_message": "<p>Two more targets tested, both have race condition, one has problem with code revocation. The issue is very widely spread :)</p>\n", 
            "type": "Activities::Comment", 
            "id": 498983, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-22T21:48:54.769Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-22T21:48:54.769Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "Any chance to get a response here? :)", 
            "markdown_message": "<p>Any chance to get a response here? :)</p>\n", 
            "type": "Activities::Comment", 
            "id": 1029282, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-05-30T14:49:30.954Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-05-30T14:49:30.954Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "additional_data": {
                "new_severity": "Medium", 
                "old_severity": null
            }, 
            "team_handle": "internet", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportSeverityUpdated", 
            "id": 1709718, 
            "genius_execution_id": null
        }, 
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2017-05-30T14:49:40.130Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-05-30T14:49:40.130Z", 
            "actor": {
                "url": "/internet", 
                "profile": {
                    "name": "The Internet"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/38e952fcff2c0aae0d011d5cecd07e5f62ecbd63_medium.png?1383767658"
                }
            }, 
            "team_handle": "internet", 
            "bonus_amount": "0.0", 
            "bounty_amount": "2500.0", 
            "collaborator": {
                "username": "dor1s", 
                "url": "/dor1s"
            }, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BountyAwarded", 
            "id": 1709721, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "dor1s", 
                "url": "/dor1s"
            }, 
            "created_at": "2017-05-30T14:49:50.654Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-05-30T14:49:50.654Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "Thank you!", 
            "markdown_message": "<p>Thank you!</p>\n", 
            "type": "Activities::BugResolved", 
            "id": 1709723, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-09-18T14:10:46.002Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-09-18T14:10:46.002Z", 
            "actor": {
                "username": "dor1s", 
                "url": "/dor1s", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/017/930/da6461e494c2c33aa729348651e58eff4eb75727_medium.gif?1426012619"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "first_to_agree": true, 
            "message": "Finally published the blog post: https://blog.avuln.com/article/4 :)", 
            "markdown_message": "<p>Finally published the blog post: <a title=\"https://blog.avuln.com/article/4\" href=\"/redirect?signature=690af964e6099112456a307ff2033a4a02973ca0&amp;url=https%3A%2F%2Fblog.avuln.com%2Farticle%2F4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://blog.avuln.com/article/4</span><i class=\"icon-external-link\"></i></a> :)</p>\n", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 2003432, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-09-19T17:40:28.050Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-09-19T17:40:28.050Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 2006546, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-09-19T17:40:28.099Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-09-19T17:40:28.099Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "internet", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 2006547, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "dor1s", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/dor1s", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/017/930/1029bebd9cfbbd6a5c813b6ca0c9518c560ca8d5_small.gif?1426012619"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 27, 
        "name": "Improper Authentication - Generic"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -35799707.840691686, 
    "disclosed_at": "2017-09-19T17:40:28.080Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/55140", 
    "created_at": "2015-04-06T23:56:06.373Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>Most of OAuth 2 API implementations seem to have multiple Race Condition vulnerabilities for processing requests for Access Token or Refresh Token.</p>\n\n<p>Race Condition allows a malicious application to obtain several <code>access_token</code> and <code>refresh_token</code> pairs while only one pair should be generated. Further, it leads to authorization bypass when access would be revoked.</p>\n\n<p>I&#39;ve already tested for this vulnerability 11 different targets (web-services providing OAuth2 API), and 6 of them are vulnerable. Only one target seems to be certainly protected (or I just failed to catch into Race Condition time window). The rest 4 targets have Race Condition bug, but protected against further exploitation by one of the following reasons:</p>\n\n<ul>\n<li>only one of several tokens generated is valid (<strong>1 target</strong>)</li>\n<li>for any access revocation all tokens always are revoked (<strong>1 target</strong>)</li>\n<li>for all concurring requests finished successfully the same <code>access_token</code> values (or in pair with <code>refresh_token</code>) obtained (<strong>2 targets</strong>)</li>\n</ul>\n\n<p>At this moment I cannot list vulnerable targets here because of responsible disclosure, but I think it would be possible to publish their names soon.</p>\n\n<p>Initially, I thought the vulnerability is located in <a href=\"/redirect?signature=8452be066295fa3f14376b5cc0898b476d54dbc4&amp;url=https%3A%2F%2Fgithub.com%2Fdoorkeeper-gem%2Fdoorkeeper\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>Doorkeeper gem for Ruby</span><i class=\"icon-external-link\"></i></a>. It is very popular, and I know that some of the vulnerable targets use this gem. To be clear, I tested <a href=\"/redirect?signature=a99738d213e4b007247adbab3af41d06357d86ce&amp;url=https%3A%2F%2Fgithub.com%2Fdoorkeeper-gem%2Fdoorkeeper-provider-app\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>OAuth 2 provider example based on it</span><i class=\"icon-external-link\"></i></a> and it was safe for me. <em>Honestly, I&#39;m not ruby developer, so it is not easy for me to quickly inspect doorkeeper&#39;s code and distinguish is it vulnerable or not</em>.</p>\n\n<p>However, I&#39;m sure that 6 of vulnerable targets use different implementations (at least more than one). So the attack vector seems to be universal and possible by design.</p>\n\n<h1 id=\"race-condition-for-access-token\">Race Condition for Access Token</h1>\n\n<p>According to <a href=\"/redirect?signature=4bf94a3da731b8d40bea59eb6d9f5a08ea5c85b1&amp;url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>OAuth 2.0 RFC</span><i class=\"icon-external-link\"></i></a>, <code>code</code> obtained via callback may be used only once to generate <code>access_token</code> (and corresponding <code>refresh_token</code>).</p>\n\n<p>Race Condition vulnerability allows a malicious application to generate several <code>access_token</code> and <code>refresh_token</code> pairs. This leads to authentication issue when a user will revoke access for an application. One <code>access_token</code> and <code>refresh_token</code> pair would be revoked, but all the rest stay active.</p>\n\n<h2 id=\"proof-of-concept\">Proof-Of-Concept</h2>\n\n<p><em>PoC description is unified and may be used for any provider</em></p>\n\n<p>0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application</p>\n\n<p>1) Open link for the application authorization in browser. Usually it looks like:</p>\n<pre class=\"highlight plaintext\"><code>https://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID&amp;redirect_uri=https://APPLICATION_REDIRECT_URI&amp;response_type=code\n</code></pre>\n<p>2) Log into <em>a victim&#39;s</em> account (if it needed) and allow access for the application</p>\n\n<p>3) Obtain <code>code</code> value from callback:</p>\n<pre class=\"highlight plaintext\"><code>https://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\n</code></pre>\n<p>4) Try to exploit Race Condition for Access Token request. I used the following script for that:</p>\n<pre class=\"highlight shell\"><code><span class=\"c\">#!/bin/bash</span>\ncurl --data <span class=\"s2\">&quot;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE_VALUE&amp;client_id=APPLICATION_ID&amp;client_secret=APPLICATION_SECRET&amp;redirect_uri=APPLICATION_REDIRECT_URI&quot;</span> <span class=\"s2\">&quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token&quot;</span> &amp;\n&lt; ... previous line repeated 20 <span class=\"nb\">times</span> ... &gt;\n</code></pre>\n<p>For different attempts result of its execution gives from 1 to 20 different <code>access_token</code> values (may be in pair with <code>refresh_token</code> values) for targets which has Race Condition bug (10 of 11 tested).</p>\n\n<p>5) Check each <code>access_token</code>. Take the simplest request from the target API and try it for each value, like:</p>\n<pre class=\"highlight plaintext\"><code>GET /api/me?access_token=ACCESS_TOKEN_VALUE HTTP/1.1\nHost: OAUTH_PROVIDER_DOMAIN\n\n</code></pre>\n<p>Usually all <code>access_token</code> values are valid and working.</p>\n\n<p>6) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.</p>\n\n<p>7) Here execution flow has two possible directions:<br>\n7A) Go to <strong>settings</strong> or <strong>applications</strong> page in the victim&#39;s account and revoke access for the application. Then repeat step 5 and see if all <code>access_token</code>s become invalid or not. If all <code>access_token</code>s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one <code>access_token</code> is revoked, while all the rest stay valid.</p>\n\n<p>7B) Use revocation request (like <code>/oauth/revoke</code>) for one of the <code>access_token</code>s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).</p>\n\n<h2 id=\"race-condition-for-refresh-token\">Race Condition for Refresh Token</h2>\n\n<p>While <code>code</code> may be used only once to obtain <code>access_token</code>, <code>refresh_token</code> often may be used only once too. In such case, Race Condition vulnerability allows an attacker to generate huge number of <code>access_token</code> and <code>refresh_token</code> pairs. This will make it very hard for a victim to revoke access for the malicious application.</p>\n\n<p>0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application</p>\n\n<p>1) Open link for the application authorization in browser. Usually it looks like:</p>\n<pre class=\"highlight plaintext\"><code>https://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID&amp;redirect_uri=https://APPLICATION_REDIRECT_URI&amp;response_type=code\n</code></pre>\n<p>2) Log into <em>a victim&#39;s</em> account (if it needed) and allow access for the application</p>\n\n<p>3) Obtain <code>code</code> value from callback:</p>\n<pre class=\"highlight plaintext\"><code>https://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\n</code></pre>\n<p>4) Legally obtain <code>access_token</code> and <code>refresh_token</code>. Usually it may be done by request like:</p>\n<pre class=\"highlight plaintext\"><code>curl --data &quot;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE_VALUE&amp;client_id=APPLICATION_ID&amp;client_secret=APPLICATION_SECRET&amp;redirect_uri=APPLICATION_REDIRECT_URI&quot; &quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token&quot;\n</code></pre>\n<p>5) Try to exploit Race Condition for <code>refresh_token</code>. I used the following script for that:</p>\n<pre class=\"highlight shell\"><code><span class=\"c\">#!/bin/bash</span>\ncurl --data <span class=\"s2\">&quot;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN_VALUE&amp;client_id=APPLICATION_ID&amp;client_secret=APPLICATION_SECRET&quot;</span> <span class=\"s2\">&quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token&quot;</span> &amp;\n&lt; ... previous line repeated 20 <span class=\"nb\">times</span> ... &gt;\n\n</code></pre>\n<p>For different attempts result of its execution gives from 1 to 20 different <code>access_token</code> values (may be in pair with <code>refresh_token</code> values) for targets which has Race Condition bug.</p>\n\n<p>6) Check obtained <code>access_token</code>s as in previous Proof-of-Concept. All of them are valid and working for API.</p>\n\n<p>7) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.</p>\n\n<p>8) Here execution flow has two possible directions:<br>\n8A) Go to <strong>settings</strong> or <strong>applications</strong> page in the victim&#39;s account and revoke access for the application. Then repeat step 5 and see if all <code>access_token</code>s become invalid or not. If all <code>access_token</code>s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one <code>access_token</code> is revoked, while all the rest stay valid.</p>\n\n<p>8B) Use revocation request (like <code>/oauth/revoke</code>) for one of the <code>access_token</code>s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).</p>\n\n<p>Exploitation for <code>refresh_token</code> is more dangerous than for <code>access_token</code>, because there is no way for an attacker to fail. Each exploitation gives at least one new <code>refresh_token</code> which may be used further. Thus, number of token pairs grows exponentially.</p>\n\n<h1 id=\"impact\">Impact</h1>\n\n<p>Generating huge number of tokens for access is serious issue which violates <a href=\"/redirect?signature=4bf94a3da731b8d40bea59eb6d9f5a08ea5c85b1&amp;url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>OAuth framework RFC</span><i class=\"icon-external-link\"></i></a> and best practices. This vulnerability deprives a victim of ability to deny access for malicious application (for most of implementations tested).</p>\n\n<p>Because of target (e.g <code>/oauth/token</code>) script is vulnerable to Race Condition, there are more attack vectors than I demonstrated. For example, an application may infinitely refresh its access and user would not be able to revoke access too.</p>\n\n<h2 id=\"put-it-simply\">Put it simply</h2>\n\n<p>OAuth API is widespread mechanism nowadays. Number of different services and applications increases so fast, that almost no one wants to have so many different accounts for all of them. This is why OAuth is popular and important. But, on the other hand, no one wants to grant access to yet another one service/application, if he knows that it is impossible for him to revoke deny access later. This is why such bypassing of access revocation should be prevented.</p>\n", 
    "severity_rating": "medium", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "", 
            "about": "Hack all the things.", 
            "twitter_handle": null, 
            "name": "The Internet"
        }, 
        "handle": "internet", 
        "url": "https://hackerone.com/internet", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/020/b94983d2ec09553c3e08f98cc718cb17e01112e6_small.png?1383767658", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/38e952fcff2c0aae0d011d5cecd07e5f62ecbd63_medium.png?1383767658"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 20, 
        "default_currency": "usd"
    }, 
    "is_published": false
}