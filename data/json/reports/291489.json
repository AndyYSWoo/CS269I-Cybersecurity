{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": true, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": "2017-12-05T06:09:37.360Z", 
    "voters": [
        "jokebookservice1", 
        "heeeeen", 
        "corb3nik", 
        "soiax", 
        "theraz0r", 
        "ronak_9889", 
        "eveeez", 
        "geeknik", 
        "axolotl", 
        "craxerbikash", 
        "and 4 more..."
    ], 
    "facebook_team?": false, 
    "has_bounty?": false, 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 291489, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2017-12-05T02:22:03.101Z", 
    "vulnerability_information": "Brief\n-----\nThere is a lack of sanitation checks when handling Garlic messages in the kovri I2P router. Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.\n\nTechnical Details:\n===========\n* Code Version: Taken from Github on the 18th of November 2017 - commit 5aafe6608519d31e537c97b24ea7b23aa372dd5b\n* Vulnerable File: src\\core\\router\\garlic.h\n* Vulnerable Function: GarlicDestination::HandleGarlicPayload\n\nThe function is responsible to parse and handle Garlic Payloads: several independent Garlic Cloves.\nWhen handling a clove with a delivery type of \"DeliveryTypeTunnel\" there are insufficient checks on the message, before it is wrapped and sent onward:\n```cpp\n    GarlicDeliveryType delivery_type = (GarlicDeliveryType)((flag >> 5) & 0x03);\n    switch (delivery_type) {\n      case eGarlicDeliveryTypeLocal:\n        LOG(debug) << \"GarlicDestination: Garlic type local\";\n        HandleI2NPMessage(buf, len, from);\n      break;\n      case eGarlicDeliveryTypeDestination:\n        LOG(debug) << \"GarlicDestination: Garlic type destination\";\n        buf += 32;  // destination. check it later or for multiple destinations\n        HandleI2NPMessage(buf, len, from);\n      break;\n      case eGarlicDeliveryTypeTunnel: {\n        LOG(debug) << \"GarlicDestination: Garlic type tunnel\";\n        // gateway_hash and gateway_tunnel sequence is reverted\n        std::uint8_t* gateway_hash = buf;\n        buf += 32;\n        std::uint32_t gateway_tunnel = bufbe32toh(buf);\n        buf += 4;\n        std::shared_ptr<kovri::core::OutboundTunnel> tunnel;\n        if (from && from->GetTunnelPool())\n          tunnel = from->GetTunnelPool()->GetNextOutboundTunnel();\n        // EI [BUG-TRACE] : The payload length is based on an unchecked length field\n        // EI             : from the just found I2NP message contained in the clove.\n        // EI\t          : When creating and sending this message onward we may leak\n        // EI             : heap memory data to the destination node [18/11/2017]\n        if (tunnel) {  // we have send it through an outbound tunnel\n          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n          tunnel->SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n        } else {\n          LOG(debug)\n            << \"GarlicDestination: no outbound tunnels available for garlic clove\";\n        }\n        break;\n      }\n      case eGarlicDeliveryTypeRouter:\n        LOG(warning) << \"GarlicDestination: Garlic type router not supported\";\n        buf += 32;\n      break;\n      default:\n        LOG(error)\n          << \"GarlicDestination: unknown garlic delivery type \"\n          << static_cast<int>(delivery_type);\n    }\n    buf += kovri::core::GetI2NPMessageLength(buf);  // I2NP\n    buf += 4;  // CloveID\n    buf += 8;  // Date\n    buf += 3;  // Certificate\n    // EI [BUG_TRACE] : This check is too late since the I2NP message was already sent. [18/11/2017]\n    if (buf - buf1  > static_cast<int>(len)) {\n      LOG(error) << \"GarlicDestination: clove is too long\";\n      break;\n    }\n```\n\nProposed Fix\n---------------\nThe inner I2NP message is parsed and forwarded using it's own length field BEFORE this field is checked for consistency. There is a good sanitation check in the bottom of the function, but the check is preformed only AFTER the message is sent.\n\nThe proposed fix is to copy the current code check to the vulnerable case, and to preform it before the new message is created:\n```cpp\n    case eGarlicDeliveryTypeTunnel: {\n        LOG(debug) << \"GarlicDestination: Garlic type tunnel\";\n        // gateway_hash and gateway_tunnel sequence is reverted\n        std::uint8_t* gateway_hash = buf;\n        buf += 32;\n        std::uint32_t gateway_tunnel = bufbe32toh(buf);\n        buf += 4;\n        std::shared_ptr<kovri::core::OutboundTunnel> tunnel;\n        if (from && from->GetTunnelPool())\n          tunnel = from->GetTunnelPool()->GetNextOutboundTunnel();\n        // EI [BUG-FIX] : added this new check\n        if (buf + kovri::core::GetI2NPMessageLength(buf) + 4 + 8 + 3 - buf1  > static_cast<int>(len)) {\n          LOG(error) << \"GarlicDestination: clove is too long\";\n          break;\n        }\n        if (tunnel) {  // we have send it through an outbound tunnel\n          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n          tunnel->SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n        } else {\n          LOG(debug)\n            << \"GarlicDestination: no outbound tunnels available for garlic clove\";\n        }\n        break;\n      }\n```\n\nImplications\n--------------\nSince the original message is allocated on the heap, this message can **leak massive amounts of heap data** to the receiving node (message lengths can be even 32KB). This data contains previous messages, currently treated messages, and many other sensitive data-structures of the I2P router.\n\nIn case there are any questions regarding my findings I will be more than happy to help.", 
    "activity_page_count": 1, 
    "severity": {
        "metrics": {
            "confidentiality": "high", 
            "privileges_required": "low", 
            "user_interaction": "none", 
            "attack_vector": "network", 
            "attack_complexity": "low", 
            "scope": "changed", 
            "integrity": "none", 
            "availability": "none"
        }, 
        "rating": "high", 
        "score": 7.7, 
        "author_type": "User"
    }, 
    "title": "Kovri: potential buffer over-read in garlic clove handling + I2NP message creation", 
    "is_member_of_team?": null, 
    "vote_count": 14, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2018-01-04T02:22:03.443Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "activity_page_number": 1, 
    "readable_substate": "Resolved", 
    "public": true, 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "created_at": "2017-11-21T00:02:40.517Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-21T00:02:40.517Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "Hi Eyal,\n\nFirstly, welcome to the Monero community - and thank you for your report! If I may ask, how did you find out about Kovri and HackerOne? We're glad to see you.\n\nSecondly, important disclaimers:\n\n- Kovri is pre-alpha, and pre-alpha for a reason. This is not my code nor have I given it my seal of approval. Much of Kovri development has been mostly rewriting the spaghetti code anti-pattern raw pointer nightmare of i2pd.\n- This is not the first time a raw leaks have arose from the pre-forked code nor will it be the last case until QA is complete. See [here](https://github.com/monero-project/kovri/issues/65), [here](https://github.com/monero-project/kovri/issues/64), and [here](https://github.com/monero-project/kovri/commit/82650a25de708bd4cc34608cf200bb58fb2e42bc).\n- I have not ensured any QA on tunnel/I2NP as noted [in this issue](https://github.com/monero-project/kovri/issues/511) (garlic is implied though I should probably update the issue for verbosity) and, with the exception of at least two small commits, I've literally not done any *directly-related* work on the garlic implementation nor have I sat down with the implementation to make all the necessary changes.\n- Though I understand the appeal of your issue title, do note that:\n  - OpenSSL was initially released in 1998 and has had continous releases since then.\n  - OpenSSL has become the crux of the internet's security and safety backbone for what's possibly been trillions of dollars of e-commerce since browser https was first implemented.\n  - OpenSSL has had 100's if not 1000's of contributors/reviewers since 1998. Kovri has only 1 full-time developer since last year and only a handful of contributors.\n- Months ago, we discussed the need to have HackerOne reports for Kovri only apply to crypto and research because of the massive amount of known issues that have yet to be resolved e.g., if we release bounty for everyone of these kinds of reports, the bounty fund would go broke. These types reports are literally \"like shooting fish in a barrel\" because the code we forked from was so poorly designed and written - and there is still much more core code review needed. Unfortunately, this discussion never made it to HackerOne and there is still a [meta issue](https://github.com/monero-project/meta/issues/83) for this. As such, we'll have to discuss internally how to resolve the bounty situation but **I'm sure you will receive a reward** because, in this case, we haven't accurately reported Kovri guidelines (I can only do much on my own).\n\nWith that said, let's elaborate on the issue and take a look deeper (the issue is not endemic to just tunnel delivery type):\n\n```diff\ndiff --git a/src/core/router/i2np.cc b/src/core/router/i2np.cc\nindex 55a7d123..d2c97626 100644\n--- a/src/core/router/i2np.cc\n+++ b/src/core/router/i2np.cc\n@@ -107,14 +107,25 @@ std::unique_ptr<I2NPMessage> CreateI2NPMessage(\n     msg->len += len;\n   } else {\n     LOG(error) << \"I2NPMessage: message length \" << len << \" exceeds max length\";\n+    // TODO(anonimal): ...then don't return the message...\n   }\n   msg->FillI2NPMessageHeader(msg_type, reply_msg_ID);\n   return msg;\n }\n \n+// TDDO(anonimal):                                                                                                                                                                                               \n+//   Theoretically, and despite the signed type, len passed has the potential to be 64k (value given in 2 bytes 0xffff)                                                                                          \n+//   but, because of I2NP fragmentation + alignment, the max should be no more than 62708 bytes (61.2k for tunnel delivery mode).                                                                                \n+//                                                                                                                                                                                                               \n+//   Now, msg->max_len is at a minimum 4k (\"short\" message) or at most 32k depending on message type.                                                                                                            \n+//   The below sanity test ensures that passed len is < (4k || 32k) *BUT* that still leaves potential for copying over                                                                                           \n+//   ((msg->max_len - 1) - len) amount of memory (memory after payload, potentially uninitialized) into the message buffer                                                                                       \n+//   which is then sent through the tunnel.  TODO(anonimal): ensure callers never send incorrect length to begin with.                                                                                           \n+//                                                                                                                                                                                                               \n+//   Note: NTCP limits message size to to 16378 bytes and SSU limits (should) to 32k.                                                                                                                            \n std::shared_ptr<I2NPMessage> CreateI2NPMessage(                                                                                                                                                                  \n     const std::uint8_t* buf,                                                                                                                                                                                     \n-    int len,                                                                                                                                                                                                     \n+    int len,  // TODO(anonimal): uint16_t, and caller should ensure no overflow                                                                                                                                  \n     std::shared_ptr<kovri::core::InboundTunnel> from) {                                                                                                                                                          \n   std::unique_ptr<I2NPMessage> msg = NewI2NPMessage();\n   if (msg->offset + len < msg->max_len) {\n@@ -123,6 +134,7 @@ std::shared_ptr<I2NPMessage> CreateI2NPMessage(\n     msg->from = from;\n   } else {\n     LOG(error) << \"I2NPMessage: message length \" << len << \" exceeds max length\";\n+    // TODO(anonimal): now why would we want to send an empty message?!...\n   }\n   return ToSharedI2NPMessage(std::move(msg));\n }\n@@ -644,6 +656,7 @@ std::unique_ptr<I2NPMessage> CreateTunnelGatewayMsg(\n   return msg;\n }\n \n+// TODO(anonimal): s/size_t/uint16_t/\n std::size_t GetI2NPMessageLength(\n     const std::uint8_t* msg) {\n   return bufbe16toh(msg + I2NP_HEADER_SIZE_OFFSET) + I2NP_HEADER_SIZE;\n```\n\nNow, let's elaborate more on this patch (also note the TODOs and another raw memory leak that I've marked in all caps):\n\n\n```diff\ndiff --git a/src/core/router/garlic.cc b/src/core/router/garlic.cc\nindex b6c9ad23..86e8cf0e 100644\n--- a/src/core/router/garlic.cc\n+++ b/src/core/router/garlic.cc\n@@ -264,7 +264,7 @@ std::size_t GarlicRoutingSession::CreateAESBlock(\n   block_size += len;\n   std::size_t rem = block_size % 16;\n   if (rem)\n-    block_size += (16-rem);  // padding\n+    block_size += (16-rem);  // TODO(anonimal): MUST BE RANDOM PADDING!\n   // TODO(anonimal): this try block should be larger or handled entirely by caller\n   try {\n     m_Encryption.Encrypt(buf, block_size, buf);\n@@ -571,11 +571,49 @@ void GarlicDestination::HandleAESBlock(\n   }\n }\n \n+// TODO(anonimal): this may be the only caller that checks received garlic message payload length\n void GarlicDestination::HandleGarlicPayload(\n     std::uint8_t* buf,\n     std::size_t len,\n-    std::shared_ptr<kovri::core::InboundTunnel> from) {\n+    std::shared_ptr<kovri::core::InboundTunnel> from)\n+{\n+  LOG(trace) << \"GarlicDestination: \" << __func__\n+             << \": inbound tunnel ID: \" << from->GetTunnelID()\n+             << \": purported length: \" << len << GetFormattedHex(buf, len);\n+\n+  // Save state\n   const std::uint8_t* buf1 = buf;\n+\n+  // Payload offset after I2NP message\n+  enum Clove : std::uint8_t\n+  {                                                                                                                                                                                                              \n+    ID = 4,                                                                                                                                                                                                      \n+    Date = 8,                                                                                                                                                                                                    \n+    Cert = 3                                                                                                                                                                                                     \n+  };                                                                                                                                                                                                             \n+                                                                                                                                                                                                                 \n+  // Validate clove length after processing but before creating message / sending through tunnel                                                                                                                 \n+  auto check_clove_len = [buf1, len](std::uint8_t*& buf, bool increment) {                                                                                                                                       \n+    // I2NP length                                                                                                                                                                                               \n+    const std::uint16_t msg_len = GetI2NPMessageLength(buf);                                                                                                                                                     \n+    LOG(debug) << \"GarlicDestination: I2NP message len=\" << msg_len;                                                                                                                                             \n+                                                                                                                                                                                                                 \n+    const std::uint16_t offset =                                                                                                                                                                                 \n+        msg_len + Clove::ID + Clove::Date + Clove::Cert;                                                                                                                                                         \n+    LOG(debug) << \"GarlicDestination: garlic payload offset=\" << offset;                                                                                                                                         \n+\n+    // Sanity test\n+    if ((buf + offset) - buf1 > static_cast<int>(len))\n+      // TODO(anonimal): in this case, do we want to throw out the entire payload? If not, don't throw.\n+      throw std::runtime_error(\"GarlicDestination: clove is too long\");\n+\n+    // Increment to ensure all given cloves are checked\n+    if (increment)\n+      buf += offset;\n+\n+    return msg_len;\n+  };\n+\n   std::size_t num_cloves = buf[0];\n   LOG(debug) << \"GarlicDestination: \" << num_cloves << \" cloves\";\n   buf++;\n@@ -609,8 +647,8 @@ void GarlicDestination::HandleGarlicPayload(\n         std::shared_ptr<kovri::core::OutboundTunnel> tunnel;\n         if (from && from->GetTunnelPool())\n           tunnel = from->GetTunnelPool()->GetNextOutboundTunnel();\n-        if (tunnel) {  // we have send it through an outbound tunnel\n-          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n+        if (tunnel) {  // we must send it through an outbound tunnel\n+          auto msg = CreateI2NPMessage(buf, check_clove_len(buf, false), from);\n           tunnel->SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n         } else {\n           LOG(debug)\n@@ -626,15 +664,9 @@ void GarlicDestination::HandleGarlicPayload(\n         LOG(error)\n           << \"GarlicDestination: unknown garlic delivery type \"\n           << static_cast<int>(delivery_type);\n+        // TODO(anonimal): we should throw, pending responsible callers\n     }\n-    buf += kovri::core::GetI2NPMessageLength(buf);  // I2NP\n-    buf += 4;  // CloveID\n-    buf += 8;  // Date\n-    buf += 3;  // Certificate\n-    if (buf - buf1  > static_cast<int>(len)) {\n-      LOG(error) << \"GarlicDestination: clove is too long\";\n-      break;\n-    }\n+    check_clove_len(buf, true);\n   }\n }\n \n@@ -691,6 +723,7 @@ void GarlicDestination::DeliveryStatusSent(\n   m_CreatedSessions[msg_ID] = session;\n }\n \n+// TODO(anonimal): at worst, the message isn't ACKd\n void GarlicDestination::HandleDeliveryStatusMessage(\n     std::shared_ptr<I2NPMessage> msg) {\n     std::uint32_t msg_ID = bufbe32toh(msg->GetPayload()); {\n```\n\nThis performs the sanity test while improving maintainability, documentation, and logging (though throwing may break things that shouldn't break nor should be able to break in the first place if a callee throws). Like your patch, the only fallback to this patch is that the check is called twice for 2 cloves or more but, again, this is a patch. Improvements are welcome.\n\n>Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.\n\nCan you provide a PoC exploit? Looking at this function alone and at no other controls, the potential leak is obvious - but ultimately the claim is still speculative. Without a PoC exploit, this report merely points out already-documented design issues. Also note that transport/tunnel/garlic message handling in I2P is convoluted and has many caveats. Though we could theoretically conjure any 2 byte size for payload length or any size > actual clove length (and the memory does appear to be uninitialized), are you certain that no other checks are in place in any of the callers or clove creation functions? Hint: look in the surrounding areas around all calls to htobe16buf(buf, len). And, mind you, this would need to be exploited *before* payload hash is created or else verify will fail (AFAICT).\n\nThis report came at an odd time since I had plans to be AFK all week after Monday and, as such, I can't look further into the issue or even my own questions until the weekend or next Monday at the latest. Despite being pre-alpha, without a release, and the lack of a PoC exploit, a patch should be applied regardless - so I will check-in this week before the weekend to ensure that this issue is resolved in a timely manner.\n\nThanks again, Eyal", 
            "markdown_message": "<p>Hi Eyal,</p>\n\n<p>Firstly, welcome to the Monero community - and thank you for your report! If I may ask, how did you find out about Kovri and HackerOne? We&#39;re glad to see you.</p>\n\n<p>Secondly, important disclaimers:</p>\n\n<ul>\n<li>Kovri is pre-alpha, and pre-alpha for a reason. This is not my code nor have I given it my seal of approval. Much of Kovri development has been mostly rewriting the spaghetti code anti-pattern raw pointer nightmare of i2pd.</li>\n<li>This is not the first time a raw leaks have arose from the pre-forked code nor will it be the last case until QA is complete. See <a href=\"/redirect?signature=4f5efe991f57909b87ef406e6ff3318b26aafd59&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fissues%2F65\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>here</span><i class=\"icon-external-link\"></i></a>, <a href=\"/redirect?signature=dae5d3eb27813533566b3656d71a468bce379dd9&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fissues%2F64\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>here</span><i class=\"icon-external-link\"></i></a>, and <a href=\"/redirect?signature=0f81f0de97e4382cbec0d219d581113a652fba97&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fcommit%2F82650a25de708bd4cc34608cf200bb58fb2e42bc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>here</span><i class=\"icon-external-link\"></i></a>.</li>\n<li>I have not ensured any QA on tunnel/I2NP as noted <a href=\"/redirect?signature=6eda308bb9580d6c6627404391b5b8f97a007621&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fissues%2F511\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>in this issue</span><i class=\"icon-external-link\"></i></a> (garlic is implied though I should probably update the issue for verbosity) and, with the exception of at least two small commits, I&#39;ve literally not done any <em>directly-related</em> work on the garlic implementation nor have I sat down with the implementation to make all the necessary changes.</li>\n<li>Though I understand the appeal of your issue title, do note that:\n\n<ul>\n<li>OpenSSL was initially released in 1998 and has had continous releases since then.</li>\n<li>OpenSSL has become the crux of the internet&#39;s security and safety backbone for what&#39;s possibly been trillions of dollars of e-commerce since browser https was first implemented.</li>\n<li>OpenSSL has had 100&#39;s if not 1000&#39;s of contributors/reviewers since 1998. Kovri has only 1 full-time developer since last year and only a handful of contributors.</li>\n</ul>\n</li>\n<li>Months ago, we discussed the need to have HackerOne reports for Kovri only apply to crypto and research because of the massive amount of known issues that have yet to be resolved e.g., if we release bounty for everyone of these kinds of reports, the bounty fund would go broke. These types reports are literally &quot;like shooting fish in a barrel&quot; because the code we forked from was so poorly designed and written - and there is still much more core code review needed. Unfortunately, this discussion never made it to HackerOne and there is still a <a href=\"/redirect?signature=0e8e6b6f145ad9249ace007c56491f2f395cab10&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmeta%2Fissues%2F83\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>meta issue</span><i class=\"icon-external-link\"></i></a> for this. As such, we&#39;ll have to discuss internally how to resolve the bounty situation but <strong>I&#39;m sure you will receive a reward</strong> because, in this case, we haven&#39;t accurately reported Kovri guidelines (I can only do much on my own).</li>\n</ul>\n\n<p>With that said, let&#39;s elaborate on the issue and take a look deeper (the issue is not endemic to just tunnel delivery type):</p>\n<pre class=\"highlight diff\"><code><span class=\"gh\">diff --git a/src/core/router/i2np.cc b/src/core/router/i2np.cc\nindex 55a7d123..d2c97626 100644\n</span><span class=\"gd\">--- a/src/core/router/i2np.cc\n</span><span class=\"gi\">+++ b/src/core/router/i2np.cc\n</span><span class=\"gu\">@@ -107,14 +107,25 @@ std::unique_ptr&lt;I2NPMessage&gt; CreateI2NPMessage(\n</span>     msg-&gt;len += len;\n   } else {\n     LOG(error) &lt;&lt; &quot;I2NPMessage: message length &quot; &lt;&lt; len &lt;&lt; &quot; exceeds max length&quot;;\n<span class=\"gi\">+    // TODO(anonimal): ...then don&#39;t return the message...\n</span>   }\n   msg-&gt;FillI2NPMessageHeader(msg_type, reply_msg_ID);\n   return msg;\n }\n\n<span class=\"gi\">+// TDDO(anonimal):                                                                                                                                                                                               \n+//   Theoretically, and despite the signed type, len passed has the potential to be 64k (value given in 2 bytes 0xffff)                                                                                          \n+//   but, because of I2NP fragmentation + alignment, the max should be no more than 62708 bytes (61.2k for tunnel delivery mode).                                                                                \n+//                                                                                                                                                                                                               \n+//   Now, msg-&gt;max_len is at a minimum 4k (&quot;short&quot; message) or at most 32k depending on message type.                                                                                                            \n+//   The below sanity test ensures that passed len is &lt; (4k || 32k) *BUT* that still leaves potential for copying over                                                                                           \n+//   ((msg-&gt;max_len - 1) - len) amount of memory (memory after payload, potentially uninitialized) into the message buffer                                                                                       \n+//   which is then sent through the tunnel.  TODO(anonimal): ensure callers never send incorrect length to begin with.                                                                                           \n+//                                                                                                                                                                                                               \n+//   Note: NTCP limits message size to to 16378 bytes and SSU limits (should) to 32k.                                                                                                                            \n</span> std::shared_ptr&lt;I2NPMessage&gt; CreateI2NPMessage(                                                                                                                                                                  \n     const std::uint8_t* buf,                                                                                                                                                                                     \n<span class=\"gd\">-    int len,                                                                                                                                                                                                     \n</span><span class=\"gi\">+    int len,  // TODO(anonimal): uint16_t, and caller should ensure no overflow                                                                                                                                  \n</span>     std::shared_ptr&lt;kovri::core::InboundTunnel&gt; from) {                                                                                                                                                          \n   std::unique_ptr&lt;I2NPMessage&gt; msg = NewI2NPMessage();\n   if (msg-&gt;offset + len &lt; msg-&gt;max_len) {\n<span class=\"gu\">@@ -123,6 +134,7 @@ std::shared_ptr&lt;I2NPMessage&gt; CreateI2NPMessage(\n</span>     msg-&gt;from = from;\n   } else {\n     LOG(error) &lt;&lt; &quot;I2NPMessage: message length &quot; &lt;&lt; len &lt;&lt; &quot; exceeds max length&quot;;\n<span class=\"gi\">+    // TODO(anonimal): now why would we want to send an empty message?!...\n</span>   }\n   return ToSharedI2NPMessage(std::move(msg));\n }\n<span class=\"gu\">@@ -644,6 +656,7 @@ std::unique_ptr&lt;I2NPMessage&gt; CreateTunnelGatewayMsg(\n</span>   return msg;\n }\n\n<span class=\"gi\">+// TODO(anonimal): s/size_t/uint16_t/\n</span> std::size_t GetI2NPMessageLength(\n     const std::uint8_t* msg) {\n   return bufbe16toh(msg + I2NP_HEADER_SIZE_OFFSET) + I2NP_HEADER_SIZE;\n</code></pre>\n<p>Now, let&#39;s elaborate more on this patch (also note the TODOs and another raw memory leak that I&#39;ve marked in all caps):</p>\n<pre class=\"highlight diff\"><code><span class=\"gh\">diff --git a/src/core/router/garlic.cc b/src/core/router/garlic.cc\nindex b6c9ad23..86e8cf0e 100644\n</span><span class=\"gd\">--- a/src/core/router/garlic.cc\n</span><span class=\"gi\">+++ b/src/core/router/garlic.cc\n</span><span class=\"gu\">@@ -264,7 +264,7 @@ std::size_t GarlicRoutingSession::CreateAESBlock(\n</span>   block_size += len;\n   std::size_t rem = block_size % 16;\n   if (rem)\n<span class=\"gd\">-    block_size += (16-rem);  // padding\n</span><span class=\"gi\">+    block_size += (16-rem);  // TODO(anonimal): MUST BE RANDOM PADDING!\n</span>   // TODO(anonimal): this try block should be larger or handled entirely by caller\n   try {\n     m_Encryption.Encrypt(buf, block_size, buf);\n<span class=\"gu\">@@ -571,11 +571,49 @@ void GarlicDestination::HandleAESBlock(\n</span>   }\n }\n\n<span class=\"gi\">+// TODO(anonimal): this may be the only caller that checks received garlic message payload length\n</span> void GarlicDestination::HandleGarlicPayload(\n     std::uint8_t* buf,\n     std::size_t len,\n<span class=\"gd\">-    std::shared_ptr&lt;kovri::core::InboundTunnel&gt; from) {\n</span><span class=\"gi\">+    std::shared_ptr&lt;kovri::core::InboundTunnel&gt; from)\n+{\n+  LOG(trace) &lt;&lt; &quot;GarlicDestination: &quot; &lt;&lt; __func__\n+             &lt;&lt; &quot;: inbound tunnel ID: &quot; &lt;&lt; from-&gt;GetTunnelID()\n+             &lt;&lt; &quot;: purported length: &quot; &lt;&lt; len &lt;&lt; GetFormattedHex(buf, len);\n+\n+  // Save state\n</span>   const std::uint8_t* buf1 = buf;\n<span class=\"gi\">+\n+  // Payload offset after I2NP message\n+  enum Clove : std::uint8_t\n+  {                                                                                                                                                                                                              \n+    ID = 4,                                                                                                                                                                                                      \n+    Date = 8,                                                                                                                                                                                                    \n+    Cert = 3                                                                                                                                                                                                     \n+  };                                                                                                                                                                                                             \n+                                                                                                                                                                                                                 \n+  // Validate clove length after processing but before creating message / sending through tunnel                                                                                                                 \n+  auto check_clove_len = [buf1, len](std::uint8_t*&amp; buf, bool increment) {                                                                                                                                       \n+    // I2NP length                                                                                                                                                                                               \n+    const std::uint16_t msg_len = GetI2NPMessageLength(buf);                                                                                                                                                     \n+    LOG(debug) &lt;&lt; &quot;GarlicDestination: I2NP message len=&quot; &lt;&lt; msg_len;                                                                                                                                             \n+                                                                                                                                                                                                                 \n+    const std::uint16_t offset =                                                                                                                                                                                 \n+        msg_len + Clove::ID + Clove::Date + Clove::Cert;                                                                                                                                                         \n+    LOG(debug) &lt;&lt; &quot;GarlicDestination: garlic payload offset=&quot; &lt;&lt; offset;                                                                                                                                         \n+\n+    // Sanity test\n+    if ((buf + offset) - buf1 &gt; static_cast&lt;int&gt;(len))\n+      // TODO(anonimal): in this case, do we want to throw out the entire payload? If not, don&#39;t throw.\n+      throw std::runtime_error(&quot;GarlicDestination: clove is too long&quot;);\n+\n+    // Increment to ensure all given cloves are checked\n+    if (increment)\n+      buf += offset;\n+\n+    return msg_len;\n+  };\n+\n</span>   std::size_t num_cloves = buf[0];\n   LOG(debug) &lt;&lt; &quot;GarlicDestination: &quot; &lt;&lt; num_cloves &lt;&lt; &quot; cloves&quot;;\n   buf++;\n<span class=\"gu\">@@ -609,8 +647,8 @@ void GarlicDestination::HandleGarlicPayload(\n</span>         std::shared_ptr&lt;kovri::core::OutboundTunnel&gt; tunnel;\n         if (from &amp;&amp; from-&gt;GetTunnelPool())\n           tunnel = from-&gt;GetTunnelPool()-&gt;GetNextOutboundTunnel();\n<span class=\"gd\">-        if (tunnel) {  // we have send it through an outbound tunnel\n-          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n</span><span class=\"gi\">+        if (tunnel) {  // we must send it through an outbound tunnel\n+          auto msg = CreateI2NPMessage(buf, check_clove_len(buf, false), from);\n</span>           tunnel-&gt;SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n         } else {\n           LOG(debug)\n<span class=\"gu\">@@ -626,15 +664,9 @@ void GarlicDestination::HandleGarlicPayload(\n</span>         LOG(error)\n           &lt;&lt; &quot;GarlicDestination: unknown garlic delivery type &quot;\n           &lt;&lt; static_cast&lt;int&gt;(delivery_type);\n<span class=\"gi\">+        // TODO(anonimal): we should throw, pending responsible callers\n</span>     }\n<span class=\"gd\">-    buf += kovri::core::GetI2NPMessageLength(buf);  // I2NP\n-    buf += 4;  // CloveID\n-    buf += 8;  // Date\n-    buf += 3;  // Certificate\n-    if (buf - buf1  &gt; static_cast&lt;int&gt;(len)) {\n-      LOG(error) &lt;&lt; &quot;GarlicDestination: clove is too long&quot;;\n-      break;\n-    }\n</span><span class=\"gi\">+    check_clove_len(buf, true);\n</span>   }\n }\n\n<span class=\"gu\">@@ -691,6 +723,7 @@ void GarlicDestination::DeliveryStatusSent(\n</span>   m_CreatedSessions[msg_ID] = session;\n }\n\n<span class=\"gi\">+// TODO(anonimal): at worst, the message isn&#39;t ACKd\n</span> void GarlicDestination::HandleDeliveryStatusMessage(\n     std::shared_ptr&lt;I2NPMessage&gt; msg) {\n     std::uint32_t msg_ID = bufbe32toh(msg-&gt;GetPayload()); {\n</code></pre>\n<p>This performs the sanity test while improving maintainability, documentation, and logging (though throwing may break things that shouldn&#39;t break nor should be able to break in the first place if a callee throws). Like your patch, the only fallback to this patch is that the check is called twice for 2 cloves or more but, again, this is a patch. Improvements are welcome.</p>\n\n<blockquote>\n<p>Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.</p>\n</blockquote>\n\n<p>Can you provide a PoC exploit? Looking at this function alone and at no other controls, the potential leak is obvious - but ultimately the claim is still speculative. Without a PoC exploit, this report merely points out already-documented design issues. Also note that transport/tunnel/garlic message handling in I2P is convoluted and has many caveats. Though we could theoretically conjure any 2 byte size for payload length or any size &gt; actual clove length (and the memory does appear to be uninitialized), are you certain that no other checks are in place in any of the callers or clove creation functions? Hint: look in the surrounding areas around all calls to htobe16buf(buf, len). And, mind you, this would need to be exploited <em>before</em> payload hash is created or else verify will fail (AFAICT).</p>\n\n<p>This report came at an odd time since I had plans to be AFK all week after Monday and, as such, I can&#39;t look further into the issue or even my own questions until the weekend or next Monday at the latest. Despite being pre-alpha, without a release, and the lack of a PoC exploit, a patch should be applied regardless - so I will check-in this week before the weekend to ensure that this issue is resolved in a timely manner.</p>\n\n<p>Thanks again, Eyal</p>\n", 
            "type": "Activities::Comment", 
            "id": 2171766, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-21T00:03:38.633Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-21T00:03:38.633Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BugNeedsMoreInfo", 
            "id": 2171769, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-21T08:12:20.410Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-21T08:12:20.410Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "First thing first, I saw your project through hackerOne and decided to check if I can found something interesting in it.\n\nRegarding your fix: I personally would use unt32_t for the types in the check to avoid a possible integer-overflow in the assignment into offset. Such overflow will cause the size checks to pass with a possible length of ~0xFFFF.\n\nRegarding the PoC, since I didn't use a model to check my findings, I looked very carefully on all of the rellevant code. From the buffer allocation / free, to the entire message handling flow. In addition, this message was just decrypted and so no one else could have checked this length field before the vulnerable function. Again, I point to an attack by a node that properly signed and encrypted a hostile clove, and so the hash won't be a problem, nor does the message needs to be just as the source node should have created it.\n\nCode trail:\n* HandleAESBlock: decrypts into \"buf\" and advances it beyond the tags, key, hash and flags. Calls the payload handling with buf.\n* HandleGarlicPayload: parses \"num_cloves\" and runs in a loop to parse each clove from \"buf\". Creating the message according to the length field.\n* GetI2PMessageLength: bufbe16toh() + header size\n* bufbe16toh: be16toh(buf16toh(buf))\nAnd none of these last two function has any check / can validate this parsed value against the real message length. If the message length will be 1000 than even a length field of 2000 will leak ~1000 bytes and none of these functions can check it.\n\nLater on, inside CreateI2PMessage \"len\" just needs to be smaller the max message length of I2P, and the data will be copied to the buffer of the newly created message.\n\nP.S. I should prefer to demonstrate a full PoC but I don't think I have the knowledge needed to bring up a functioning model including two nodes properly communicating with each other.\n\nHope this answers the questions.", 
            "markdown_message": "<p>First thing first, I saw your project through hackerOne and decided to check if I can found something interesting in it.</p>\n\n<p>Regarding your fix: I personally would use unt32_t for the types in the check to avoid a possible integer-overflow in the assignment into offset. Such overflow will cause the size checks to pass with a possible length of ~0xFFFF.</p>\n\n<p>Regarding the PoC, since I didn&#39;t use a model to check my findings, I looked very carefully on all of the rellevant code. From the buffer allocation / free, to the entire message handling flow. In addition, this message was just decrypted and so no one else could have checked this length field before the vulnerable function. Again, I point to an attack by a node that properly signed and encrypted a hostile clove, and so the hash won&#39;t be a problem, nor does the message needs to be just as the source node should have created it.</p>\n\n<p>Code trail:</p>\n\n<ul>\n<li>HandleAESBlock: decrypts into &quot;buf&quot; and advances it beyond the tags, key, hash and flags. Calls the payload handling with buf.</li>\n<li>HandleGarlicPayload: parses &quot;num_cloves&quot; and runs in a loop to parse each clove from &quot;buf&quot;. Creating the message according to the length field.</li>\n<li>GetI2PMessageLength: bufbe16toh() + header size</li>\n<li>bufbe16toh: be16toh(buf16toh(buf))\nAnd none of these last two function has any check / can validate this parsed value against the real message length. If the message length will be 1000 than even a length field of 2000 will leak ~1000 bytes and none of these functions can check it.</li>\n</ul>\n\n<p>Later on, inside CreateI2PMessage &quot;len&quot; just needs to be smaller the max message length of I2P, and the data will be copied to the buffer of the newly created message.</p>\n\n<p>P.S. I should prefer to demonstrate a full PoC but I don&#39;t think I have the knowledge needed to bring up a functioning model including two nodes properly communicating with each other.</p>\n\n<p>Hope this answers the questions.</p>\n", 
            "type": "Activities::BugNew", 
            "id": 2172232, 
            "genius_execution_id": null
        }, 
        {
            "attachments": [
                {
                    "url": "https://hackerone-us-west-2-production-attachments.s3-us-west-2.amazonaws.com/000/242/132/699946df8fca4b245540453e64542ecf72df1978/kovri_info-leak_PoC.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQTRM4X5HG%2F20181206%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20181206T222859Z&X-Amz-Expires=3600&X-Amz-Security-Token=FQoGZXIvYXdzEA8aDDs%2B%2FH8tFp9eaL3SuyK3A4v0Gz1Pk4vLeyx%2Fa%2BOUYIBLln%2BHhEjo8aKsDgcWA0AVPWHQ1CqE69K0fwPJtemp0NnMHwpItZaKfQu2ndzpg6QamoxmJU6CxIEWtJEY3Xtdf2COsdrDtLDojEJ9Bsgq2dXSYC00tKxrlTs4yvW6oAYTu01sZU0MCDpTX84p3oRDZuLOTobhBvHMBRwkOe5yM9PnearXzpjHD9w6d9G0IdijQ15s%2Br%2FCrRq1RQ6%2FGlZaDOuMAFvLZ%2BDU%2BQ4elR42FJO7oqNOhTb7xFUKWMGUZD2l9vrtaQYBWgy8vLJL1PHKNL79uTgKO2gWJuruy5%2FR7g8iF%2F%2BDA%2FXyg6nD5MjJy8mSf4BsfZTsJ7bQ%2BmI19CRcsvBZU%2BD1gUjQkVgOsXdeI4LcCwhSIkIHIAnZLc3YhPCinZgj4lT9UYAmI6j6Ig003H%2B2wt4Gf4YVmv60G6zU1H8wWbJ%2Fm9tXcPEMDdtt2yoQpjl%2FLHFVDNhvjZwxcRsctZU64Qaim%2FPjSts6oYmu4TCHG6yWfeMPRxHXWIQV8xe%2BCLaMnof047dAbkRq5Dx8XgGLGEXX%2FVUX%2F8kf%2FiekmYRSZTqEyMUolrmm4AU%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=1ed1ab190b0cd79aa6f3f46d538824c46ac439b1c9bd8129ae08096649e151b2", 
                    "type": "image/png", 
                    "id": 242132, 
                    "filename": "kovri_info-leak_PoC.png"
                }
            ], 
            "automated_response": false, 
            "created_at": "2017-11-24T23:21:45.069Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-24T23:21:45.069Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "PoC\n====\nI managed to bring up a test environment, and added debug traces to the kovri router I compiled:\n* My traces starts with \"EI-DEBUG\"\n* After building the new I2NP message with the leaked information, I also traced the message according to it''s (hostile) length\nHere is the relevant (textual) trace:\n\n```\n[2017.11.24 22:56:53.218001] [0xb12f9b40] [debug]   GarlicDestination: 2 cloves\n[2017.11.24 22:56:53.218038] [0xb12f9b40] [debug]   GarlicDestination: Garlic type tunnel\n[2017.11.24 22:56:53.218074] [0xb12f9b40] [trace]   EI-DEBUG: eGarlicDeliveryTypeTunnel original length:1333\n[2017.11.24 22:56:53.218113] [0xb12f9b40] [trace]   EI-DEBUG: I2NPMessage using length:16400\n[2017.11.24 22:56:53.218152] [0xb12f9b40] [trace]   EI-DEBUG: PutI2NPMsg() with eGarlicDeliveryTypeTunnel:\n```\nSince the formatting of the markdown messes up the log traces, I uploaded it as a picture. The trace itself prints the entire 16400 bytes of the message, however I though it won't be effective to load more screenshots of the message dump.", 
            "markdown_message": "<h1 id=\"poc\">PoC</h1>\n\n<p>I managed to bring up a test environment, and added debug traces to the kovri router I compiled:</p>\n\n<ul>\n<li>My traces starts with &quot;EI-DEBUG&quot;</li>\n<li>After building the new I2NP message with the leaked information, I also traced the message according to it&#39;&#39;s (hostile) length\nHere is the relevant (textual) trace:</li>\n</ul>\n<pre class=\"highlight plaintext\"><code>[2017.11.24 22:56:53.218001] [0xb12f9b40] [debug]   GarlicDestination: 2 cloves\n[2017.11.24 22:56:53.218038] [0xb12f9b40] [debug]   GarlicDestination: Garlic type tunnel\n[2017.11.24 22:56:53.218074] [0xb12f9b40] [trace]   EI-DEBUG: eGarlicDeliveryTypeTunnel original length:1333\n[2017.11.24 22:56:53.218113] [0xb12f9b40] [trace]   EI-DEBUG: I2NPMessage using length:16400\n[2017.11.24 22:56:53.218152] [0xb12f9b40] [trace]   EI-DEBUG: PutI2NPMsg() with eGarlicDeliveryTypeTunnel:\n</code></pre>\n<p>Since the formatting of the markdown messes up the log traces, I uploaded it as a picture. The trace itself prints the entire 16400 bytes of the message, however I though it won&#39;t be effective to load more screenshots of the message dump.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2181336, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-25T18:02:48.937Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-25T18:02:48.937Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "Since I am experienced with the process of issuing a CVE, with multiple CNAs, should I issue the CVE to help you with the process? The CVE itself will be private (marked as \"reserved\" CVE) until a public disclosure will happen, and the public disclosure will only happen after your approve it (For example, after the patches will be committed to the git repo).\n\nIn any case I am waiting for your reply, and will like to know if there is a specific CNA you prefer/recommend for this process.\n\nThanks again for your attention and fast response.", 
            "markdown_message": "<p>Since I am experienced with the process of issuing a CVE, with multiple CNAs, should I issue the CVE to help you with the process? The CVE itself will be private (marked as &quot;reserved&quot; CVE) until a public disclosure will happen, and the public disclosure will only happen after your approve it (For example, after the patches will be committed to the git repo).</p>\n\n<p>In any case I am waiting for your reply, and will like to know if there is a specific CNA you prefer/recommend for this process.</p>\n\n<p>Thanks again for your attention and fast response.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2181924, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-28T01:29:17.189Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-28T01:29:17.189Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": ">First thing first, I saw your project through hackerOne and decided to check if I can found something interesting in it.\n\nGreat, thank you. There are plenty more issues to find - that will be certain.\n\n>Regarding your fix: I personally would use unt32_t for the types in the check to avoid a possible integer-overflow in the assignment into offset. Such overflow will cause the size checks to pass with a possible length of ~0xFFFF.\n\nCan you prove **with code** that this is even possible? IIRC, this was not possible in our current implementation as I explicitly discussed the issue in my first response. I'm now getting back to this issue though after being AFK, so I can review further this week in case I missed something. In the meantime, *please* provide **code** PoC for any claims.\n\n>Code trail:\n>And none of these last two function has any check / can validate this parsed value against the real message length\n\nYes, I know, this was already implied/discussed in my first response - but this is not a **code** PoC exploit.\n\n>kovri_info-leak_PoC.png\n\nThis is not a **code** PoC exploit. A scenario (and screenshot) has the potential to be manipulated to fit this control. That is why we require an *actual* **code** PoC exploit. Where is the **code** PoC exploit?\n\n>Since I am experienced with the process of issuing a CVE, with multiple CNAs, should I issue the CVE to help you with the process?\n\nNo. This is not CVE worthy as we have **no** releases. *Please* read my first response again regarding release/development status/state. Also, there is no **code** PoC exploit to confirm the hypotheticals. We need a reproducible **code** PoC exploit. Once we start having releases, we can then discuss CVE requirements for potential *future* issues, but not this one. Also, bounty cannot be released without at first seeing a **code** PoC exploit.\n\n>In any case I am waiting for your reply, and will like to know if there is a specific CNA you prefer/recommend for this process.\n\nPlease read our [Vulnerability Response Process](https://github.com/monero-project/kovri#vulnerability-response). If anything is not clear, please feel free to ask.\n\nNote: please provide any **code PoC** as a git-diff. You can paste inline or attach as a patch.", 
            "markdown_message": "<blockquote>\n<p>First thing first, I saw your project through hackerOne and decided to check if I can found something interesting in it.</p>\n</blockquote>\n\n<p>Great, thank you. There are plenty more issues to find - that will be certain.</p>\n\n<blockquote>\n<p>Regarding your fix: I personally would use unt32_t for the types in the check to avoid a possible integer-overflow in the assignment into offset. Such overflow will cause the size checks to pass with a possible length of ~0xFFFF.</p>\n</blockquote>\n\n<p>Can you prove <strong>with code</strong> that this is even possible? IIRC, this was not possible in our current implementation as I explicitly discussed the issue in my first response. I&#39;m now getting back to this issue though after being AFK, so I can review further this week in case I missed something. In the meantime, <em>please</em> provide <strong>code</strong> PoC for any claims.</p>\n\n<blockquote>\n<p>Code trail:<br>\nAnd none of these last two function has any check / can validate this parsed value against the real message length</p>\n</blockquote>\n\n<p>Yes, I know, this was already implied/discussed in my first response - but this is not a <strong>code</strong> PoC exploit.</p>\n\n<blockquote>\n<p>kovri_info-leak_PoC.png</p>\n</blockquote>\n\n<p>This is not a <strong>code</strong> PoC exploit. A scenario (and screenshot) has the potential to be manipulated to fit this control. That is why we require an <em>actual</em> <strong>code</strong> PoC exploit. Where is the <strong>code</strong> PoC exploit?</p>\n\n<blockquote>\n<p>Since I am experienced with the process of issuing a CVE, with multiple CNAs, should I issue the CVE to help you with the process?</p>\n</blockquote>\n\n<p>No. This is not CVE worthy as we have <strong>no</strong> releases. <em>Please</em> read my first response again regarding release/development status/state. Also, there is no <strong>code</strong> PoC exploit to confirm the hypotheticals. We need a reproducible <strong>code</strong> PoC exploit. Once we start having releases, we can then discuss CVE requirements for potential <em>future</em> issues, but not this one. Also, bounty cannot be released without at first seeing a <strong>code</strong> PoC exploit.</p>\n\n<blockquote>\n<p>In any case I am waiting for your reply, and will like to know if there is a specific CNA you prefer/recommend for this process.</p>\n</blockquote>\n\n<p>Please read our <a href=\"/redirect?signature=492aed98c5f825d89097f35eed641352d0dca5a8&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%23vulnerability-response\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>Vulnerability Response Process</span><i class=\"icon-external-link\"></i></a>. If anything is not clear, please feel free to ask.</p>\n\n<p>Note: please provide any <strong>code PoC</strong> as a git-diff. You can paste inline or attach as a patch.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2185506, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-28T04:07:04.672Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-28T04:07:04.672Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "I don't understand why the harsh tones are needed in this discussion. If this is the first post you mention **code** PoC then there is no need to \"yell\" it with bold 8 times... And regarding the CVE, I did read your vulnerability response process and that is the reason I offered to help you in the process, you cant ignore my offer if you don't think it is rellevant.\n\nThis is the first time a project blames me of fabricating a PoC, and I have a long record with many IBB projects and major companies. Normally when one explains the code path in a complex system like yours, the developers try to help from their side in bringing up a test model, a job that took me more than 12 hours on last friday, and was done so I won't interfere with the live kovri network.\n\nI understood your stand, and now you request an additional code PoC that your fix does suffer from an IoF vulnerability, so I will organize my setup scripts and will send you the code for:\n1. A hostile kovri client that triggers the attack on a compiled regular kovri router\n2. A hostile kovri client that triggers the attack on your proposed patched kovri router\nBoth will be in a cloned kovri version of the repo at my git account. I just don't understand yet how the git dif on the attacker side will help you anyway.\n\nSince this is the middle of a work week, I will try to deliver all of this until Sunday, as I work full time and can't work on this seriously before the weekend.\n", 
            "markdown_message": "<p>I don&#39;t understand why the harsh tones are needed in this discussion. If this is the first post you mention <strong>code</strong> PoC then there is no need to &quot;yell&quot; it with bold 8 times... And regarding the CVE, I did read your vulnerability response process and that is the reason I offered to help you in the process, you cant ignore my offer if you don&#39;t think it is rellevant.</p>\n\n<p>This is the first time a project blames me of fabricating a PoC, and I have a long record with many IBB projects and major companies. Normally when one explains the code path in a complex system like yours, the developers try to help from their side in bringing up a test model, a job that took me more than 12 hours on last friday, and was done so I won&#39;t interfere with the live kovri network.</p>\n\n<p>I understood your stand, and now you request an additional code PoC that your fix does suffer from an IoF vulnerability, so I will organize my setup scripts and will send you the code for:</p>\n\n<ol>\n<li>A hostile kovri client that triggers the attack on a compiled regular kovri router</li>\n<li>A hostile kovri client that triggers the attack on your proposed patched kovri router\nBoth will be in a cloned kovri version of the repo at my git account. I just don&#39;t understand yet how the git dif on the attacker side will help you anyway.</li>\n</ol>\n\n<p>Since this is the middle of a work week, I will try to deliver all of this until Sunday, as I work full time and can&#39;t work on this seriously before the weekend.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2185667, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-28T22:24:04.007Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-28T22:24:04.007Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": ">I don't understand why the harsh tones are needed in this discussion.\n\nI think you're misinterpreting my English. As a native speaker, I can assure you that there was no harsh tone. Because you overlooked what I had originally said, highlighting important words in bold usually helps with the visual aspect of skimming text.\n\n>If this is the first post you mention code PoC\n\nWe've had no problems with any other reports providing code PoC. Code PoC is implied but some people miss this fact. We will provided an addendum to the VRP.\n\n>This is the first time a project blames me of fabricating a PoC\n\nNo one blamed you for fabricating anything. We specifically said *\"A scenario (and screenshot) has the potential to be manipulated to fit this control. That is why we require an actual code PoC exploit.\"* In vulnerability response, a person's word means nothing: only the code matters. This applies to me or anyone else. We've received actual code PoC for nearly every other Monero project report, so I don't see why you or anyone else (including myself) should be any exception to the rule.\n\n>Normally when one explains the code path in a complex system like yours, the developers try to help from their side in bringing up a test model\n\n1. You had originally said *\"Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.\"* which implies that you were successfully able to do so. If you were successfully able to do so, you wouldn't need me to explain the code path as you would have demonstrated that you understood the components and concepts involved.\n\n2. How am I to know that you need help if you don't ask questions? AFAICT, a majority of your response has been assumptions and accusations.\n\n3. You missed some very, *very*, important parts of my original message:\n\n>>Kovri is pre-alpha\n>>I have not ensured any QA on tunnel/I2NP as noted in this issue (garlic is implied though I should probably update the issue for verbosity)\n\nSo, any work that we do will almost certainly be rewritten or thrown out. It's not cost-effective to dwell on an area of a pre-Alpha codebase that needs more than just patches.\n\n>you cant ignore my offer if you don't think it is rellevant.\n\n\"Relevant\". And no one ignored your offer. We simply corrected your invalid assumption that a CVE was required.\n\n>now you request an additional code PoC that your fix does suffer from an IoF vulnerability, \n\nBy my patch you mean yours because ultimately what I provided is simple a wrapper for your patch... ?\n\n>I just don't understand yet how the git dif on the attacker side will help you anyway.\n\nThen you don't understand how this network works. If you want to learn more about Kovri and I2P, you're welcome to come ask questions in our [support section](https://github.com/monero-project/kovri#support).\n\n>Since this is the middle of a work week, I will try to deliver all of this until Sunday, as I work full time and can't work on this seriously before the weekend.\n\nGreat, we appreciate your contributions. At this point we would like to move on the following:\n\n1. Apply the single-line patch that you first proposed. Though the patch doesn't solve all problems of this area, this area of Kovri needs official review beyond the scope of this report.\n2. Because we have no official releases, the remaining portions of the Monero VRP after point 6 are not applicable. For internal use only, we will classify this issue as MEDIUM as defined in the Monero VRP: *\"or must be carefully exploited\"*.\n3. Give you credit in the git-log for your single-line patch. While your further work in this area will be appreciated, your patch is sufficient enough to close the report while we continue pre-Alpha development in this area. The remaining issues can be addressed with the TODOs in my patch. Any future related issues - while we're in pre-Alpha - can be resolved directly on github.\n4. Even though we don't intend to provide bounty before a Beta release, we will send you a complimentary XMR for your effort. Because HackerOne doesn't distribute XMR bounty through their service (and we don't offer fiat bounties), you will need to provide an XMR address for us to send XMR to (if you wish to have the bounty). Note: [this VRP caveat](https://github.com/monero-project/kovri/issues/630) will be implemented effective immediately for future H1 issues (as I mentioned in my original response). Future bounty will also only be available (a much larger amount of bounty) after [this](https://github.com/monero-project/meta/issues/83) is resolved.\n\n\nOn a sidenote: if you would like to make a steady, significant amount of XMR (either during our pre-Alpha and Alpha stages or beyond), you can create an [FFS proposal](https://github.com/monero-project/meta/issues/63) to work part time on Kovri. For an example FFS proposal, see [here](https://forum.getmonero.org/9/work-in-progress/86967/anonimal-s-kovri-full-time-development-funding-thread).\n\nPlease feel free to ask any questions if any of the aforementioned was not clear. You can also visit https://getmonero.org and reddit's /r/Monero for more information on how to use and trade Monero. Thank you.", 
            "markdown_message": "<blockquote>\n<p>I don&#39;t understand why the harsh tones are needed in this discussion.</p>\n</blockquote>\n\n<p>I think you&#39;re misinterpreting my English. As a native speaker, I can assure you that there was no harsh tone. Because you overlooked what I had originally said, highlighting important words in bold usually helps with the visual aspect of skimming text.</p>\n\n<blockquote>\n<p>If this is the first post you mention code PoC</p>\n</blockquote>\n\n<p>We&#39;ve had no problems with any other reports providing code PoC. Code PoC is implied but some people miss this fact. We will provided an addendum to the VRP.</p>\n\n<blockquote>\n<p>This is the first time a project blames me of fabricating a PoC</p>\n</blockquote>\n\n<p>No one blamed you for fabricating anything. We specifically said <em>&quot;A scenario (and screenshot) has the potential to be manipulated to fit this control. That is why we require an actual code PoC exploit.&quot;</em> In vulnerability response, a person&#39;s word means nothing: only the code matters. This applies to me or anyone else. We&#39;ve received actual code PoC for nearly every other Monero project report, so I don&#39;t see why you or anyone else (including myself) should be any exception to the rule.</p>\n\n<blockquote>\n<p>Normally when one explains the code path in a complex system like yours, the developers try to help from their side in bringing up a test model</p>\n</blockquote>\n\n<ol>\n<li><p>You had originally said <em>&quot;Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.&quot;</em> which implies that you were successfully able to do so. If you were successfully able to do so, you wouldn&#39;t need me to explain the code path as you would have demonstrated that you understood the components and concepts involved.</p></li>\n<li><p>How am I to know that you need help if you don&#39;t ask questions? AFAICT, a majority of your response has been assumptions and accusations.</p></li>\n<li><p>You missed some very, <em>very</em>, important parts of my original message:</p></li>\n</ol>\n\n<blockquote>\n<blockquote>\n<p>Kovri is pre-alpha<br>\nI have not ensured any QA on tunnel/I2NP as noted in this issue (garlic is implied though I should probably update the issue for verbosity)</p>\n</blockquote>\n</blockquote>\n\n<p>So, any work that we do will almost certainly be rewritten or thrown out. It&#39;s not cost-effective to dwell on an area of a pre-Alpha codebase that needs more than just patches.</p>\n\n<blockquote>\n<p>you cant ignore my offer if you don&#39;t think it is rellevant.</p>\n</blockquote>\n\n<p>&quot;Relevant&quot;. And no one ignored your offer. We simply corrected your invalid assumption that a CVE was required.</p>\n\n<blockquote>\n<p>now you request an additional code PoC that your fix does suffer from an IoF vulnerability, </p>\n</blockquote>\n\n<p>By my patch you mean yours because ultimately what I provided is simple a wrapper for your patch... ?</p>\n\n<blockquote>\n<p>I just don&#39;t understand yet how the git dif on the attacker side will help you anyway.</p>\n</blockquote>\n\n<p>Then you don&#39;t understand how this network works. If you want to learn more about Kovri and I2P, you&#39;re welcome to come ask questions in our <a href=\"/redirect?signature=29ce1f8e7c78c2a2b6b52ee28a8bc0f2e41d9c25&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%23support\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>support section</span><i class=\"icon-external-link\"></i></a>.</p>\n\n<blockquote>\n<p>Since this is the middle of a work week, I will try to deliver all of this until Sunday, as I work full time and can&#39;t work on this seriously before the weekend.</p>\n</blockquote>\n\n<p>Great, we appreciate your contributions. At this point we would like to move on the following:</p>\n\n<ol>\n<li>Apply the single-line patch that you first proposed. Though the patch doesn&#39;t solve all problems of this area, this area of Kovri needs official review beyond the scope of this report.</li>\n<li>Because we have no official releases, the remaining portions of the Monero VRP after point 6 are not applicable. For internal use only, we will classify this issue as MEDIUM as defined in the Monero VRP: <em>&quot;or must be carefully exploited&quot;</em>.</li>\n<li>Give you credit in the git-log for your single-line patch. While your further work in this area will be appreciated, your patch is sufficient enough to close the report while we continue pre-Alpha development in this area. The remaining issues can be addressed with the TODOs in my patch. Any future related issues - while we&#39;re in pre-Alpha - can be resolved directly on github.</li>\n<li>Even though we don&#39;t intend to provide bounty before a Beta release, we will send you a complimentary XMR for your effort. Because HackerOne doesn&#39;t distribute XMR bounty through their service (and we don&#39;t offer fiat bounties), you will need to provide an XMR address for us to send XMR to (if you wish to have the bounty). Note: <a href=\"/redirect?signature=3916521b5a3a7d998f2186bdd5d15d19a9bf53d7&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fissues%2F630\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>this VRP caveat</span><i class=\"icon-external-link\"></i></a> will be implemented effective immediately for future H1 issues (as I mentioned in my original response). Future bounty will also only be available (a much larger amount of bounty) after <a href=\"/redirect?signature=0e8e6b6f145ad9249ace007c56491f2f395cab10&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmeta%2Fissues%2F83\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>this</span><i class=\"icon-external-link\"></i></a> is resolved.</li>\n</ol>\n\n<p>On a sidenote: if you would like to make a steady, significant amount of XMR (either during our pre-Alpha and Alpha stages or beyond), you can create an <a href=\"/redirect?signature=2c41b18f2c0239e183db6ca483cf2e93fb9c2879&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmeta%2Fissues%2F63\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>FFS proposal</span><i class=\"icon-external-link\"></i></a> to work part time on Kovri. For an example FFS proposal, see <a href=\"/redirect?signature=d5a027521ad5e5fcd9a5b8f56a6b5188806bbed5&amp;url=https%3A%2F%2Fforum.getmonero.org%2F9%2Fwork-in-progress%2F86967%2Fanonimal-s-kovri-full-time-development-funding-thread\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>here</span><i class=\"icon-external-link\"></i></a>.</p>\n\n<p>Please feel free to ask any questions if any of the aforementioned was not clear. You can also visit <a title=\"https://getmonero.org\" href=\"/redirect?signature=09a3ca93cd6ed4793c81055c82c83590fb3f34f2&amp;url=https%3A%2F%2Fgetmonero.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://getmonero.org</span><i class=\"icon-external-link\"></i></a> and reddit&#39;s /r/Monero for more information on how to use and trade Monero. Thank you.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2187688, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-29T00:20:21.619Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-29T00:20:21.619Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "additional_data": {
                "new_title": "Kovri: potential buffer over-read in garlic clove handling + I2NP message creation", 
                "old_title": "Kovri heartbleed-style vulnerability"
            }, 
            "team_handle": "monero", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportTitleUpdated", 
            "id": 2187846, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt"
            }, 
            "created_at": "2017-11-29T00:45:19.348Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-29T00:45:19.348Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "Note: @aerodudrizzt, we will also mark this issue with \"Set Award\" -> \"Swag\" once you provide an XMR address and after we send the funds.", 
            "markdown_message": "<p>Note: <a href=\"/aerodudrizzt\">@aerodudrizzt</a>, we will also mark this issue with &quot;Set Award&quot; -&gt; &quot;Swag&quot; once you provide an XMR address and after we send the funds.</p>\n", 
            "type": "Activities::BugResolved", 
            "id": 2187879, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-01T15:27:09.539Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-01T15:27:09.539Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "First thing first, I apologize for the language I used in this conversation. After all we both want to know that the vulnerability is indeed exploitable, and a code PoC is the best way for it. In addition, we both want the vulnerability to be properly patched, and so there is no need to argue.\n\nCode PoC\n-----------\nAs promised, I am now attaching the code PoC for the reported vulnerability.\nMy full documented test setup can be found in an encrypted compressed zip folder in my website:\nhttp://www.cs.tau.ac.il/~eyalitki/Upload/HackerOne/PoC.zip\nThe password for the archive is: \"kovrianonimal\".\n\nMore Info\n-----------\nThe PoC includes the victim kovri router, and my modified attacker router. The submission includes the entire project, including:\n* Full code for both routers (including the compiled binaries that I've used in my demo)\n* Configuration folders for each router - the setup was on an isolated test i2p network, with only these two nodes\n* Logs of both routers, produced during the exploit demonstration\n\nVulnerability Impact (Severity)\n---------------------------------\n* Since the vulnerability was demonstrated in a live setup, which you can re-create using the code PoC I attached, I ask that the ticket's description will reflect that the vulnerability is more than \"potential\".\n* Since this is an exploitable major information-leak I hope you will find it qualified to the 500 XMR minimum bounty you mentioned in your FFS.\n\nProposed Patch\n-----------------\nThe patch you proposed will indeed block the attack, more info can be found in the README.txt in the archive.\n\nLogistics:\n----------\nMy monero wallet address is:\n49q5B492UgjJMPQ3j2Zs246LzMmVvdNxoj3VGnBCQf2pAKt2rmQ6fag8jwFG7QUfmT1iDVmnmNVAUKNvNeYhYQxhCXeYRRE\nIn case there is any problem with it I will be more than happy to help.\n\nThanks for the very fast replies, especially relative to other bug bounty projects, and for the time you dedicated to my ticket.\nEyal Itkin.\n", 
            "markdown_message": "<p>First thing first, I apologize for the language I used in this conversation. After all we both want to know that the vulnerability is indeed exploitable, and a code PoC is the best way for it. In addition, we both want the vulnerability to be properly patched, and so there is no need to argue.</p>\n\n<h2 id=\"code-poc\">Code PoC</h2>\n\n<p>As promised, I am now attaching the code PoC for the reported vulnerability.<br>\nMy full documented test setup can be found in an encrypted compressed zip folder in my website:<br>\n<a title=\"http://www.cs.tau.ac.il/~eyalitki/Upload/HackerOne/PoC.zip\" href=\"/redirect?signature=16b32e0dcddf43278dcc0c3463ccb54c16527b80&amp;url=http%3A%2F%2Fwww.cs.tau.ac.il%2F%7Eeyalitki%2FUpload%2FHackerOne%2FPoC.zip\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://www.cs.tau.ac.il/~eyalitki/Upload/HackerOne/PoC.zip</span><i class=\"icon-external-link\"></i></a><br>\nThe password for the archive is: &quot;kovrianonimal&quot;.</p>\n\n<h2 id=\"more-info\">More Info</h2>\n\n<p>The PoC includes the victim kovri router, and my modified attacker router. The submission includes the entire project, including:</p>\n\n<ul>\n<li>Full code for both routers (including the compiled binaries that I&#39;ve used in my demo)</li>\n<li>Configuration folders for each router - the setup was on an isolated test i2p network, with only these two nodes</li>\n<li>Logs of both routers, produced during the exploit demonstration</li>\n</ul>\n\n<h2 id=\"vulnerability-impact-severity\">Vulnerability Impact (Severity)</h2>\n\n<ul>\n<li>Since the vulnerability was demonstrated in a live setup, which you can re-create using the code PoC I attached, I ask that the ticket&#39;s description will reflect that the vulnerability is more than &quot;potential&quot;.</li>\n<li>Since this is an exploitable major information-leak I hope you will find it qualified to the 500 XMR minimum bounty you mentioned in your FFS.</li>\n</ul>\n\n<h2 id=\"proposed-patch\">Proposed Patch</h2>\n\n<p>The patch you proposed will indeed block the attack, more info can be found in the README.txt in the archive.</p>\n\n<h2 id=\"logistics\">Logistics:</h2>\n\n<p>My monero wallet address is:<br>\n49q5B492UgjJMPQ3j2Zs246LzMmVvdNxoj3VGnBCQf2pAKt2rmQ6fag8jwFG7QUfmT1iDVmnmNVAUKNvNeYhYQxhCXeYRRE<br>\nIn case there is any problem with it I will be more than happy to help.</p>\n\n<p>Thanks for the very fast replies, especially relative to other bug bounty projects, and for the time you dedicated to my ticket.<br>\nEyal Itkin.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2193879, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-02T00:18:43.547Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-02T00:18:43.547Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": ">My full documented test setup can be found in an encrypted compressed zip folder in my website\n\nPlease don't link to your website. If you wish to share any files, please upload them to HackerOne. This is for security and accountability purposes. Also, you do not need to upload any binaries.\n\n>the setup was on an isolated test i2p network, with only these two nodes\n>Since the vulnerability was demonstrated in a live setup, which you can re-create using the code PoC I attached, I ask that the ticket's description will reflect that the vulnerability is more than \"potential\".\n\nOnly two nodes? You cannot reproduce the network with simply two nodes. I can't verify if you indeed only used two nodes (see above about uploading files) but if you wish to prove this issue as *not* potential, you'll need to make your case using real tunnels with real hops - preferably using the testnet we already have in place (modifications are welcome).\n\n>Since this is an exploitable major information-leak I hope you will find it qualified to the 500 XMR minimum bounty you mentioned in your FFS\n\nI'm afraid you're terribly confused. 500 XMR was for the minimum bounty **fund** - not for a minimum bug bounty **payout**. Nowhere in the FFS does it state that a *single* bug will be rewarded 500 XMR. In fact, nowhere in our policy or VRP does it state that any pre-Alpha kovri bug will receive *any* XMR. This is because we've only recently started using HackerOne and had yet to finish working out [the details](https://github.com/monero-project/meta/pull/142). Please review those details for future bug bounty payout.\n\nOur offer of 1 XMR was a token of appreciation. We will be able to send that XMR no later than the end of next week.\n\nWe look forward to future reports. Happy hacking!", 
            "markdown_message": "<blockquote>\n<p>My full documented test setup can be found in an encrypted compressed zip folder in my website</p>\n</blockquote>\n\n<p>Please don&#39;t link to your website. If you wish to share any files, please upload them to HackerOne. This is for security and accountability purposes. Also, you do not need to upload any binaries.</p>\n\n<blockquote>\n<p>the setup was on an isolated test i2p network, with only these two nodes<br>\nSince the vulnerability was demonstrated in a live setup, which you can re-create using the code PoC I attached, I ask that the ticket&#39;s description will reflect that the vulnerability is more than &quot;potential&quot;.</p>\n</blockquote>\n\n<p>Only two nodes? You cannot reproduce the network with simply two nodes. I can&#39;t verify if you indeed only used two nodes (see above about uploading files) but if you wish to prove this issue as <em>not</em> potential, you&#39;ll need to make your case using real tunnels with real hops - preferably using the testnet we already have in place (modifications are welcome).</p>\n\n<blockquote>\n<p>Since this is an exploitable major information-leak I hope you will find it qualified to the 500 XMR minimum bounty you mentioned in your FFS</p>\n</blockquote>\n\n<p>I&#39;m afraid you&#39;re terribly confused. 500 XMR was for the minimum bounty <strong>fund</strong> - not for a minimum bug bounty <strong>payout</strong>. Nowhere in the FFS does it state that a <em>single</em> bug will be rewarded 500 XMR. In fact, nowhere in our policy or VRP does it state that any pre-Alpha kovri bug will receive <em>any</em> XMR. This is because we&#39;ve only recently started using HackerOne and had yet to finish working out <a href=\"/redirect?signature=bc69796092cdc17489ded51e8763b7a58ecabb7b&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmeta%2Fpull%2F142\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>the details</span><i class=\"icon-external-link\"></i></a>. Please review those details for future bug bounty payout.</p>\n\n<p>Our offer of 1 XMR was a token of appreciation. We will be able to send that XMR no later than the end of next week.</p>\n\n<p>We look forward to future reports. Happy hacking!</p>\n", 
            "type": "Activities::Comment", 
            "id": 2195112, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-02T11:17:54.722Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-02T11:17:54.722Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "Hey,\n\nI just want to clarify our current standing point:\n\n1. The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability. This means that by definition the size of the network means nothing - as any rogue user on the network with a modified client can trigger the execution. The size of the network simply doesn't mean anything.\n\n1. This is one of the first projects I encounter that not only has no clear guidelines on how much are different bugs worth, but you also acknowledge yourself that the bounty definitions are not explicit and therefore you actually edited the description text while we were working on this bug: [Monero HackerOne policy change](https://hackerone.com/monero/policy_versions?change=3564319#), [Kovri bounty readme policy change](https://github.com/monero-project/kovri/commit/4ae89fc5ae002a08e1ecb44b201caf2e3ca34899), [Monero projects bug bounty declaration]( https://github.com/monero-project/meta/issues/39#issuecomment-289310019). I think that this acknowledgement does mean that there is a problem here at least to some extent.\n\n1. In order for future researchers (not only me) to know we are putting our efforts towards the benefits of the project in an ideal way, it would help if you would respond on what you actually need for it to be considered a PoC. In the comment on November 28 I outlined what I were proposing for the PoC (setting up a rouge client and router which enables the vulnerability to be easily seen). At no point whatsoever you said it's insufficient (due to network size) - you only said that after I already had put a significant amount of time on showing that.\n\n    To some extent, when a researcher is working to improve your project and describes in advance what and how he is going to provide, any reservation to the proposed PoC method shall be defined in advance rather than \"that this is not enough\", once the work is already done.\n\n    As long as I don't get clear definitive criterias on what needs to be done to prove the vulnerability, I have no reason to continue working on this. So far you did not show that you tried verifying that the PoC code works. Your offer of 1 XMR for this entire effort is simply not respecting the time I have put so far nor your published policy.\n\n1. I do believe that at this point it should be trivial to any core worker on the project to reproduce this on the test network. I'd be more than happy to provide any help you need and answer questions, but at this point what remains is engineering testing to verify the required fix on the network and not a security research.\n\n    Just for a reference, i2pd needed less than 12 hours from my report on this issue, to realize the problem and deploy a fix - so if you don't want to build the setup yourself, you can probably rely on the good folks there to see the vulnerability is real. Their fix can be tracked using CVE 2017-17066, and it will be published soon under version 2.17.\n\n1. The code PoC was uploaded as an encrypted archive to my site since it is unresponsible for any security researcher to uploaded a full exploit script into a ticket that might be publicly published someday. The archive was encrypted with a password that I gave you, such that your project would be able to use the PoC and not everyone on the internet. Once you confirm that you have downloaded my test environment I can remove it from my website, so the exploit won't be available to third parties from harming unpatched clients while the vulnerability will be a 1-day. Please explain why this form of submission has any accountability problems.\n\n1. Finally, it's unfortunate the guidelines regarding the part that my report is not \"bounty worth\" were blurry and that it was further updated after my report. I think there's real justification to reward my work per the published information as I showed in the above links.", 
            "markdown_message": "<p>Hey,</p>\n\n<p>I just want to clarify our current standing point:</p>\n\n<ol>\n<li><p>The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability. This means that by definition the size of the network means nothing - as any rogue user on the network with a modified client can trigger the execution. The size of the network simply doesn&#39;t mean anything.</p></li>\n<li><p>This is one of the first projects I encounter that not only has no clear guidelines on how much are different bugs worth, but you also acknowledge yourself that the bounty definitions are not explicit and therefore you actually edited the description text while we were working on this bug: <a href=\"https://hackerone.com/monero/policy_versions?change=3564319\">Monero HackerOne policy change</a>, <a href=\"/redirect?signature=df9fdeac164b369d1ab941d7b001cda7d7ea1d3e&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fkovri%2Fcommit%2F4ae89fc5ae002a08e1ecb44b201caf2e3ca34899\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>Kovri bounty readme policy change</span><i class=\"icon-external-link\"></i></a>, <a href=\"/redirect?signature=6aa3d85b8c02fa75ffb20fccd0f1e29903e4d87e&amp;url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmeta%2Fissues%2F39%23issuecomment-289310019\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>Monero projects bug bounty declaration</span><i class=\"icon-external-link\"></i></a>. I think that this acknowledgement does mean that there is a problem here at least to some extent.</p></li>\n<li>\n<p>In order for future researchers (not only me) to know we are putting our efforts towards the benefits of the project in an ideal way, it would help if you would respond on what you actually need for it to be considered a PoC. In the comment on November 28 I outlined what I were proposing for the PoC (setting up a rouge client and router which enables the vulnerability to be easily seen). At no point whatsoever you said it&#39;s insufficient (due to network size) - you only said that after I already had put a significant amount of time on showing that.</p>\n\n<p>To some extent, when a researcher is working to improve your project and describes in advance what and how he is going to provide, any reservation to the proposed PoC method shall be defined in advance rather than &quot;that this is not enough&quot;, once the work is already done.</p>\n\n<p>As long as I don&#39;t get clear definitive criterias on what needs to be done to prove the vulnerability, I have no reason to continue working on this. So far you did not show that you tried verifying that the PoC code works. Your offer of 1 XMR for this entire effort is simply not respecting the time I have put so far nor your published policy.</p>\n</li>\n<li>\n<p>I do believe that at this point it should be trivial to any core worker on the project to reproduce this on the test network. I&#39;d be more than happy to provide any help you need and answer questions, but at this point what remains is engineering testing to verify the required fix on the network and not a security research.</p>\n\n<p>Just for a reference, i2pd needed less than 12 hours from my report on this issue, to realize the problem and deploy a fix - so if you don&#39;t want to build the setup yourself, you can probably rely on the good folks there to see the vulnerability is real. Their fix can be tracked using CVE 2017-17066, and it will be published soon under version 2.17.</p>\n</li>\n<li><p>The code PoC was uploaded as an encrypted archive to my site since it is unresponsible for any security researcher to uploaded a full exploit script into a ticket that might be publicly published someday. The archive was encrypted with a password that I gave you, such that your project would be able to use the PoC and not everyone on the internet. Once you confirm that you have downloaded my test environment I can remove it from my website, so the exploit won&#39;t be available to third parties from harming unpatched clients while the vulnerability will be a 1-day. Please explain why this form of submission has any accountability problems.</p></li>\n<li><p>Finally, it&#39;s unfortunate the guidelines regarding the part that my report is not &quot;bounty worth&quot; were blurry and that it was further updated after my report. I think there&#39;s real justification to reward my work per the published information as I showed in the above links.</p></li>\n</ol>\n", 
            "type": "Activities::Comment", 
            "id": 2195681, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T01:21:32.280Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T01:21:32.280Z", 
            "actor": {
                "url": "/monero", 
                "profile": {
                    "name": "Monero"
                }, 
                "ibb": false, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/007/731/3428da1efb473c529a0d2e5836012a846f8b8d1e_medium.png?1484006970"
                }
            }, 
            "team_handle": "monero", 
            "message": ">The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability.\n\nNo one contested this.\n\n>This means that by definition the size of the network means nothing - as any rogue user on the network with a modified client can trigger the execution. The size of the network simply doesn't mean anything.\n\n1. Interesting, because earlier you had said `After all we both want to know that the vulnerability is indeed exploitable, and a code PoC is the best way for it.` So, since you refuse to attach PoC exploit code to this issue, how can either of those statements have be validated (rhetorical question)?\n\n>The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability. This means that by definition the size of the network means nothing\n\n1. Yes, trivial code vulnerability. Yes, not a protocol vulnerability. No, size matters. If a vulnerability **requires** tunnels to first be built using a tunnel pool built from a set of routers, this requires a myriad of other checks and factors to successfully pass throughout tunnel/I2NP and transports which, in this case, would need to pass messages of certain sizes. Since we haven't implemented 0 hop tunnels yet, your test setup sounds very inaccurate. Again, I cannot confirm because you've refused to upload PoC to HackerOne.\n\n2. Again, I've never claimed that this wasn't a vulnerability nor that it wasn't exploitable but since you kept making demands that X was Y, I asked that you prove Y, not X. A simple code-diff would've proven the claim but instead you've chosen to run around in circles.\n\n>This is one of the first projects I encounter that not only has no clear guidelines on how much are different bugs worth\n\n1. Monero is not a company nor is it a government entity. Monero is built entirely by the community. Monero is not governed by any single person. This also applies to Kovri. If you want to add guidelines, then add them.\n\n2. Monero developers have realized that there time is more fruitfully spent being paid for actual work instead of ad-hoc bug-bounty hunting. If you need a more granular tier, contribute to the open pull request that I linked above.\n\n>Your offer of 1 XMR for this entire effort is simply not respecting the time I have put so far nor your published policy.\n\nYou've not respected your own time by making assumptions instead of doing basic research. You haven't asked questions nor have you become involved with the community. In this report, you've only asked one question! Look at your responses! **All this whining and complaining... and demanding any bug-bounty reward for a one-line patch to unreleased pre-Alpha software in an area that has yet to undergo official QA - it's laughable!**.\n\nIf you're ever unsure about your \"reward\", look at a project's policy before reporting. If what you desire is not explicitly noted then ask questions and get involved before living on assumptions. How foolish to do otherwise. Never in our VRP was a bounty amount of any kind ever explicitly stated. This was because we had yet to collaborate on the question of bounty. Now that we bounty in place, once the aforementioned PR is merged, you and everyone else can benefit from a wealth of bounty potential.\n\n>The code PoC was uploaded as an encrypted archive to my site since it is unresponsible for any security researcher to uploaded a full exploit script into a ticket that might be publicly published someday. The archive was encrypted with a password that I gave you, such that your project would be able to use the PoC and not everyone on the internet. \n\n**This is exactly why HackerOne was invented**: to protect their users from each other and to act as a mitigating entity between two or more parties. If you don't want to **use** HackerOne, then don't use it! Ironically, anonymity networks defend against the very targeted surveillance that you are endorsing we succumb to.\n\n>less than 12 hours from my report on this issue, to realize the problem and deploy a fix\n\n1. Interesting, earlier you said `Thanks again for your attention and fast response.`\n\n2. You submitted your report over the weekend. The VRP specifically says \"no more than 3 working days\". If you don't understand what most of the world understands as \"working days\" (no one else has misunderstood), then I can't help you.\n\n3. To quote myself, because you continue to slide this discussion: `This report came at an odd time since I had plans to be AFK all week after Monday and, as such, I can't look further into the issue or even my own questions until the weekend or next Monday at the latest. Despite being pre-alpha, without a release, and the lack of a PoC exploit, a patch should be applied regardless - so I will check-in this week before the weekend to ensure that this issue is resolved in a timely manner.` And it has been resolved in a timely manner. **Read the VRP**. These are industry-standard bullet points.\n\n>good folks\n\nWas that before or after they watermarked their routers for months after releasing (rhetorical question)?\n\n>to see the vulnerability is real.\n\nNo one contested that the vulnerability wasn't real. For the Nth time, for this report, said reality of functional exploitation has yet to be proven with a HackerOne attached code PoC exploit. As discussed earlier, we both addressed the need for the patch and that it should be promptly applied. **The patch was promptly applied, and this is no longer an issue**. Have you actually read anything I've written in any detail (rhetorical question)?\n\nAs promised, we will send the 1 XMR to the address you gave and, as promised, we will send the transaction this week. Should you be interested, links to find various market values are in the aforementioned VRP github PR link.\n\nGet involved in the community: the Monero community is large and growing. We can help you understand the value of cryptocurrency. Visit us on IRC or on /r/Monero if you have any further questions.\n\nTo clarify, again: this issue is no longer an issue and thus will be locked. Defer to github for any subsequent pre-Alpha reports and the VRP for bounty details.\n\nHappy hacking!", 
            "markdown_message": "<blockquote>\n<p>The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability.</p>\n</blockquote>\n\n<p>No one contested this.</p>\n\n<blockquote>\n<p>This means that by definition the size of the network means nothing - as any rogue user on the network with a modified client can trigger the execution. The size of the network simply doesn&#39;t mean anything.</p>\n</blockquote>\n\n<ol>\n<li>Interesting, because earlier you had said <code>After all we both want to know that the vulnerability is indeed exploitable, and a code PoC is the best way for it.</code> So, since you refuse to attach PoC exploit code to this issue, how can either of those statements have be validated (rhetorical question)?</li>\n</ol>\n\n<blockquote>\n<p>The vulnerability I found is a trivial code vulnerability and not a protocol vulnerability. This means that by definition the size of the network means nothing</p>\n</blockquote>\n\n<ol>\n<li><p>Yes, trivial code vulnerability. Yes, not a protocol vulnerability. No, size matters. If a vulnerability <strong>requires</strong> tunnels to first be built using a tunnel pool built from a set of routers, this requires a myriad of other checks and factors to successfully pass throughout tunnel/I2NP and transports which, in this case, would need to pass messages of certain sizes. Since we haven&#39;t implemented 0 hop tunnels yet, your test setup sounds very inaccurate. Again, I cannot confirm because you&#39;ve refused to upload PoC to HackerOne.</p></li>\n<li><p>Again, I&#39;ve never claimed that this wasn&#39;t a vulnerability nor that it wasn&#39;t exploitable but since you kept making demands that X was Y, I asked that you prove Y, not X. A simple code-diff would&#39;ve proven the claim but instead you&#39;ve chosen to run around in circles.</p></li>\n</ol>\n\n<blockquote>\n<p>This is one of the first projects I encounter that not only has no clear guidelines on how much are different bugs worth</p>\n</blockquote>\n\n<ol>\n<li><p>Monero is not a company nor is it a government entity. Monero is built entirely by the community. Monero is not governed by any single person. This also applies to Kovri. If you want to add guidelines, then add them.</p></li>\n<li><p>Monero developers have realized that there time is more fruitfully spent being paid for actual work instead of ad-hoc bug-bounty hunting. If you need a more granular tier, contribute to the open pull request that I linked above.</p></li>\n</ol>\n\n<blockquote>\n<p>Your offer of 1 XMR for this entire effort is simply not respecting the time I have put so far nor your published policy.</p>\n</blockquote>\n\n<p>You&#39;ve not respected your own time by making assumptions instead of doing basic research. You haven&#39;t asked questions nor have you become involved with the community. In this report, you&#39;ve only asked one question! Look at your responses! <strong>All this whining and complaining... and demanding any bug-bounty reward for a one-line patch to unreleased pre-Alpha software in an area that has yet to undergo official QA - it&#39;s laughable!</strong>.</p>\n\n<p>If you&#39;re ever unsure about your &quot;reward&quot;, look at a project&#39;s policy before reporting. If what you desire is not explicitly noted then ask questions and get involved before living on assumptions. How foolish to do otherwise. Never in our VRP was a bounty amount of any kind ever explicitly stated. This was because we had yet to collaborate on the question of bounty. Now that we bounty in place, once the aforementioned PR is merged, you and everyone else can benefit from a wealth of bounty potential.</p>\n\n<blockquote>\n<p>The code PoC was uploaded as an encrypted archive to my site since it is unresponsible for any security researcher to uploaded a full exploit script into a ticket that might be publicly published someday. The archive was encrypted with a password that I gave you, such that your project would be able to use the PoC and not everyone on the internet. </p>\n</blockquote>\n\n<p><strong>This is exactly why HackerOne was invented</strong>: to protect their users from each other and to act as a mitigating entity between two or more parties. If you don&#39;t want to <strong>use</strong> HackerOne, then don&#39;t use it! Ironically, anonymity networks defend against the very targeted surveillance that you are endorsing we succumb to.</p>\n\n<blockquote>\n<p>less than 12 hours from my report on this issue, to realize the problem and deploy a fix</p>\n</blockquote>\n\n<ol>\n<li><p>Interesting, earlier you said <code>Thanks again for your attention and fast response.</code></p></li>\n<li><p>You submitted your report over the weekend. The VRP specifically says &quot;no more than 3 working days&quot;. If you don&#39;t understand what most of the world understands as &quot;working days&quot; (no one else has misunderstood), then I can&#39;t help you.</p></li>\n<li><p>To quote myself, because you continue to slide this discussion: <code>This report came at an odd time since I had plans to be AFK all week after Monday and, as such, I can&#39;t look further into the issue or even my own questions until the weekend or next Monday at the latest. Despite being pre-alpha, without a release, and the lack of a PoC exploit, a patch should be applied regardless - so I will check-in this week before the weekend to ensure that this issue is resolved in a timely manner.</code> And it has been resolved in a timely manner. <strong>Read the VRP</strong>. These are industry-standard bullet points.</p></li>\n</ol>\n\n<blockquote>\n<p>good folks</p>\n</blockquote>\n\n<p>Was that before or after they watermarked their routers for months after releasing (rhetorical question)?</p>\n\n<blockquote>\n<p>to see the vulnerability is real.</p>\n</blockquote>\n\n<p>No one contested that the vulnerability wasn&#39;t real. For the Nth time, for this report, said reality of functional exploitation has yet to be proven with a HackerOne attached code PoC exploit. As discussed earlier, we both addressed the need for the patch and that it should be promptly applied. <strong>The patch was promptly applied, and this is no longer an issue</strong>. Have you actually read anything I&#39;ve written in any detail (rhetorical question)?</p>\n\n<p>As promised, we will send the 1 XMR to the address you gave and, as promised, we will send the transaction this week. Should you be interested, links to find various market values are in the aforementioned VRP github PR link.</p>\n\n<p>Get involved in the community: the Monero community is large and growing. We can help you understand the value of cryptocurrency. Visit us on IRC or on /r/Monero if you have any further questions.</p>\n\n<p>To clarify, again: this issue is no longer an issue and thus will be locked. Defer to github for any subsequent pre-Alpha reports and the VRP for bounty details.</p>\n\n<p>Happy hacking!</p>\n", 
            "type": "Activities::CommentsClosed", 
            "id": 2200742, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T02:18:39.812Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T02:19:40.360Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "JFTR:\n\n>Was that before or after they watermarked their routers for months after releasing (rhetorical question)?\n\nThis is in reference to a pre-Kovri incident where they argued *against* the dangers of raw-memory leaks. Such leaks were fixed in the aforementioned links that I posted earlier in this report.", 
            "markdown_message": "<p>JFTR:</p>\n\n<blockquote>\n<p>Was that before or after they watermarked their routers for months after releasing (rhetorical question)?</p>\n</blockquote>\n\n<p>This is in reference to a pre-Kovri incident where they argued <em>against</em> the dangers of raw-memory leaks. Such leaks were fixed in the aforementioned links that I posted earlier in this report.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2200820, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt"
            }, 
            "created_at": "2017-12-05T02:19:54.722Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T02:23:58.361Z", 
            "actor": {
                "url": "/monero", 
                "profile": {
                    "name": "Monero"
                }, 
                "ibb": false, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/007/731/3428da1efb473c529a0d2e5836012a846f8b8d1e_medium.png?1484006970"
                }
            }, 
            "team_handle": "monero", 
            "message": "1 XMR sent to address 49q5B492UgjJMPQ3j2Zs246LzMmVvdNxoj3VGnBCQf2pAKt2rmQ6fag8jwFG7QUfmT1iDVmnmNVAUKNvNeYhYQxhCXeYRRE\n\n```\nTransaction successfully submitted, transaction <547f1db38774e7fa41720bfb55d7fbe712bf37a07123fe1bf30c964f9bc1a5d1>\n```", 
            "markdown_message": "<p>1 XMR sent to address 49q5B492UgjJMPQ3j2Zs246LzMmVvdNxoj3VGnBCQf2pAKt2rmQ6fag8jwFG7QUfmT1iDVmnmNVAUKNvNeYhYQxhCXeYRRE</p>\n<pre class=\"highlight plaintext\"><code>Transaction successfully submitted, transaction &lt;547f1db38774e7fa41720bfb55d7fbe712bf37a07123fe1bf30c964f9bc1a5d1&gt;\n</code></pre>", 
            "type": "Activities::SwagAwarded", 
            "id": 2200821, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T02:22:03.142Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T02:22:03.142Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "first_to_agree": true, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 2200822, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T06:09:37.406Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T06:09:37.406Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "I agree to a public disclosure. We will let the world decide if 1 XMR for GarlicRust is reasonable or not.\nThe PoC details are still attached, in case any reasercher will want to recreate the setup.", 
            "markdown_message": "<p>I agree to a public disclosure. We will let the world decide if 1 XMR for GarlicRust is reasonable or not.<br>\nThe PoC details are still attached, in case any reasercher will want to recreate the setup.</p>\n", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 2200980, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T06:09:37.500Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T06:09:37.500Z", 
            "actor": {
                "username": "aerodudrizzt", 
                "url": "/aerodudrizzt", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/098/646/dd4a57adcca0f309d5866361ff6cf9a683425281_medium.png?1483983167"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 2200981, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-12-05T10:56:04.150Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-12-05T10:56:04.150Z", 
            "actor": {
                "username": "anonimal", 
                "url": "/anonimal", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/040/857/5d3774e5d965a4122d4364133d467ea77fc31acd_medium.png?1449305173"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "monero", 
            "message": ">We will let the world decide if 1 XMR for GarlicRust is reasonable or not.\n\nAs a member of the world, for a pre-Alpha *unreleased* software, with **no VRP bug bounty in place at the time of report** (as mentioned many times so far), in an area with no QA completed, and a reporter (you) who still refuses to attach PoC to HackerOne in a responsible manner, and among the myriad of other provable points that I have made in this report (and of which you continue to ignore); I think the 1 XMR token of appreciation is more than reasonable. Any more tokens of appreciation would be a disservice to other potential researchers who knew the state of the VRP and have instead chosen to wait before beginning their research.\n\nImportant note: I have been in talks with HackerOne since December of 2015. They are fully aware that we do not provide cash bounty and are also fully aware that we provide only \"swag\" as a bug bounty (they explicitly do not support offering monero bounty). If you have a problem with the HackerOne interface not reporting this information to you, and seeing as you continue to not ask questions, take up the issue with them. Otherwise, **read and abide by the VRP as it is the official document of which we also abide by; regardless of its state in development**.\n\nThank you, and happy hacking.", 
            "markdown_message": "<blockquote>\n<p>We will let the world decide if 1 XMR for GarlicRust is reasonable or not.</p>\n</blockquote>\n\n<p>As a member of the world, for a pre-Alpha <em>unreleased</em> software, with <strong>no VRP bug bounty in place at the time of report</strong> (as mentioned many times so far), in an area with no QA completed, and a reporter (you) who still refuses to attach PoC to HackerOne in a responsible manner, and among the myriad of other provable points that I have made in this report (and of which you continue to ignore); I think the 1 XMR token of appreciation is more than reasonable. Any more tokens of appreciation would be a disservice to other potential researchers who knew the state of the VRP and have instead chosen to wait before beginning their research.</p>\n\n<p>Important note: I have been in talks with HackerOne since December of 2015. They are fully aware that we do not provide cash bounty and are also fully aware that we provide only &quot;swag&quot; as a bug bounty (they explicitly do not support offering monero bounty). If you have a problem with the HackerOne interface not reporting this information to you, and seeing as you continue to not ask questions, take up the issue with them. Otherwise, <strong>read and abide by the VRP as it is the official document of which we also abide by; regardless of its state in development</strong>.</p>\n\n<p>Thank you, and happy hacking.</p>\n", 
            "type": "Activities::Comment", 
            "id": 2201358, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "aerodudrizzt", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/aerodudrizzt", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/098/646/6dd706f25a4db060df25b01c8609c8f1762533f0_small.png?1483983167"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 18, 
        "name": "Information Disclosure"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -29102815.591105685, 
    "disclosed_at": "2017-12-05T06:09:37.460Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/291489", 
    "created_at": "2017-11-18T12:42:53.852Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<h2 id=\"brief\">Brief</h2>\n\n<p>There is a lack of sanitation checks when handling Garlic messages in the kovri I2P router. Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.</p>\n\n<h1 id=\"technical-details\">Technical Details:</h1>\n\n<ul>\n<li>Code Version: Taken from Github on the 18th of November 2017 - commit 5aafe6608519d31e537c97b24ea7b23aa372dd5b</li>\n<li>Vulnerable File: src\\core\\router\\garlic.h</li>\n<li>Vulnerable Function: GarlicDestination::HandleGarlicPayload</li>\n</ul>\n\n<p>The function is responsible to parse and handle Garlic Payloads: several independent Garlic Cloves.<br>\nWhen handling a clove with a delivery type of &quot;DeliveryTypeTunnel&quot; there are insufficient checks on the message, before it is wrapped and sent onward:</p>\n<pre class=\"highlight cpp\"><code>    <span class=\"n\">GarlicDeliveryType</span> <span class=\"n\">delivery_type</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">GarlicDeliveryType</span><span class=\"p\">)((</span><span class=\"n\">flag</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x03</span><span class=\"p\">);</span>\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">delivery_type</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">case</span> <span class=\"n\">eGarlicDeliveryTypeLocal</span><span class=\"p\">:</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: Garlic type local&quot;</span><span class=\"p\">;</span>\n        <span class=\"n\">HandleI2NPMessage</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">,</span> <span class=\"n\">from</span><span class=\"p\">);</span>\n      <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"k\">case</span> <span class=\"n\">eGarlicDeliveryTypeDestination</span><span class=\"p\">:</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: Garlic type destination&quot;</span><span class=\"p\">;</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">32</span><span class=\"p\">;</span>  <span class=\"c1\">// destination. check it later or for multiple destinations\n</span>        <span class=\"n\">HandleI2NPMessage</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">,</span> <span class=\"n\">from</span><span class=\"p\">);</span>\n      <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"k\">case</span> <span class=\"n\">eGarlicDeliveryTypeTunnel</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: Garlic type tunnel&quot;</span><span class=\"p\">;</span>\n        <span class=\"c1\">// gateway_hash and gateway_tunnel sequence is reverted\n</span>        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">uint8_t</span><span class=\"o\">*</span> <span class=\"n\">gateway_hash</span> <span class=\"o\">=</span> <span class=\"n\">buf</span><span class=\"p\">;</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">32</span><span class=\"p\">;</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">uint32_t</span> <span class=\"n\">gateway_tunnel</span> <span class=\"o\">=</span> <span class=\"n\">bufbe32toh</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">);</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">OutboundTunnel</span><span class=\"o\">&gt;</span> <span class=\"n\">tunnel</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">from</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">from</span><span class=\"o\">-&gt;</span><span class=\"n\">GetTunnelPool</span><span class=\"p\">())</span>\n          <span class=\"n\">tunnel</span> <span class=\"o\">=</span> <span class=\"n\">from</span><span class=\"o\">-&gt;</span><span class=\"n\">GetTunnelPool</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">GetNextOutboundTunnel</span><span class=\"p\">();</span>\n        <span class=\"c1\">// EI [BUG-TRACE] : The payload length is based on an unchecked length field\n</span>        <span class=\"c1\">// EI             : from the just found I2NP message contained in the clove.\n</span>        <span class=\"c1\">// EI             : When creating and sending this message onward we may leak\n</span>        <span class=\"c1\">// EI             : heap memory data to the destination node [18/11/2017]\n</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tunnel</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// we have send it through an outbound tunnel\n</span>          <span class=\"k\">auto</span> <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">CreateI2NPMessage</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">GetI2NPMessageLength</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">),</span> <span class=\"n\">from</span><span class=\"p\">);</span>\n          <span class=\"n\">tunnel</span><span class=\"o\">-&gt;</span><span class=\"n\">SendTunnelDataMsg</span><span class=\"p\">(</span><span class=\"n\">gateway_hash</span><span class=\"p\">,</span> <span class=\"n\">gateway_tunnel</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span>\n            <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: no outbound tunnels available for garlic clove&quot;</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"k\">case</span> <span class=\"n\">eGarlicDeliveryTypeRouter</span><span class=\"p\">:</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">warning</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: Garlic type router not supported&quot;</span><span class=\"p\">;</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">32</span><span class=\"p\">;</span>\n      <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span>\n          <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: unknown garlic delivery type &quot;</span>\n          <span class=\"o\">&lt;&lt;</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">delivery_type</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">GetI2NPMessageLength</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">);</span>  <span class=\"c1\">// I2NP\n</span>    <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>  <span class=\"c1\">// CloveID\n</span>    <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">8</span><span class=\"p\">;</span>  <span class=\"c1\">// Date\n</span>    <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>  <span class=\"c1\">// Certificate\n</span>    <span class=\"c1\">// EI [BUG_TRACE] : This check is too late since the I2NP message was already sent. [18/11/2017]\n</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">buf</span> <span class=\"o\">-</span> <span class=\"n\">buf1</span>  <span class=\"o\">&gt;</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: clove is too long&quot;</span><span class=\"p\">;</span>\n      <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n</code></pre>\n<h2 id=\"proposed-fix\">Proposed Fix</h2>\n\n<p>The inner I2NP message is parsed and forwarded using it&#39;s own length field BEFORE this field is checked for consistency. There is a good sanitation check in the bottom of the function, but the check is preformed only AFTER the message is sent.</p>\n\n<p>The proposed fix is to copy the current code check to the vulnerable case, and to preform it before the new message is created:</p>\n<pre class=\"highlight cpp\"><code>    <span class=\"k\">case</span> <span class=\"n\">eGarlicDeliveryTypeTunnel</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: Garlic type tunnel&quot;</span><span class=\"p\">;</span>\n        <span class=\"c1\">// gateway_hash and gateway_tunnel sequence is reverted\n</span>        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">uint8_t</span><span class=\"o\">*</span> <span class=\"n\">gateway_hash</span> <span class=\"o\">=</span> <span class=\"n\">buf</span><span class=\"p\">;</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">32</span><span class=\"p\">;</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">uint32_t</span> <span class=\"n\">gateway_tunnel</span> <span class=\"o\">=</span> <span class=\"n\">bufbe32toh</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">);</span>\n        <span class=\"n\">buf</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">OutboundTunnel</span><span class=\"o\">&gt;</span> <span class=\"n\">tunnel</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">from</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">from</span><span class=\"o\">-&gt;</span><span class=\"n\">GetTunnelPool</span><span class=\"p\">())</span>\n          <span class=\"n\">tunnel</span> <span class=\"o\">=</span> <span class=\"n\">from</span><span class=\"o\">-&gt;</span><span class=\"n\">GetTunnelPool</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">GetNextOutboundTunnel</span><span class=\"p\">();</span>\n        <span class=\"c1\">// EI [BUG-FIX] : added this new check\n</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">buf</span> <span class=\"o\">+</span> <span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">GetI2NPMessageLength</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">4</span> <span class=\"o\">+</span> <span class=\"mi\">8</span> <span class=\"o\">+</span> <span class=\"mi\">3</span> <span class=\"o\">-</span> <span class=\"n\">buf1</span>  <span class=\"o\">&gt;</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n          <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: clove is too long&quot;</span><span class=\"p\">;</span>\n          <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tunnel</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// we have send it through an outbound tunnel\n</span>          <span class=\"k\">auto</span> <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">CreateI2NPMessage</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">kovri</span><span class=\"o\">::</span><span class=\"n\">core</span><span class=\"o\">::</span><span class=\"n\">GetI2NPMessageLength</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">),</span> <span class=\"n\">from</span><span class=\"p\">);</span>\n          <span class=\"n\">tunnel</span><span class=\"o\">-&gt;</span><span class=\"n\">SendTunnelDataMsg</span><span class=\"p\">(</span><span class=\"n\">gateway_hash</span><span class=\"p\">,</span> <span class=\"n\">gateway_tunnel</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"n\">LOG</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">)</span>\n            <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GarlicDestination: no outbound tunnels available for garlic clove&quot;</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n</code></pre>\n<h2 id=\"implications\">Implications</h2>\n\n<p>Since the original message is allocated on the heap, this message can <strong>leak massive amounts of heap data</strong> to the receiving node (message lengths can be even 32KB). This data contains previous messages, currently treated messages, and many other sensitive data-structures of the I2P router.</p>\n\n<p>In case there are any questions regarding my findings I will be more than happy to help.</p>\n", 
    "severity_rating": "high", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "https://getmonero.org", 
            "about": " Monero: the secure, private, untraceable cryptocurrency", 
            "twitter_handle": "monerocurrency", 
            "name": "Monero"
        }, 
        "handle": "monero", 
        "url": "https://hackerone.com/monero", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/007/731/e9db7ce84f372b423c4d212b494be78c2e0a571e_small.png?1484006970", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/007/731/3428da1efb473c529a0d2e5836012a846f8b8d1e_medium.png?1484006970"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 7731, 
        "default_currency": "usd"
    }, 
    "is_published": false
}