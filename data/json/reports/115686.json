{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [
        "jensec", 
        "eveeez", 
        "geeknik", 
        "fa1rlight", 
        "craxerbikash", 
        "japz", 
        "sh3r1", 
        "captianamerica5"
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 115686, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2017-10-27T13:13:57.752Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "[tor] pre-emptive defenses, potential vulnerabilities", 
    "is_member_of_team?": null, 
    "vote_count": 8, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2017-11-26T13:13:57.886Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$500", 
    "attachments": [
        {
            "file_name": "do_getpass.c", 
            "type": "text/x-c", 
            "id": 72882, 
            "expiring_url": "https://hackerone-us-west-2-production-attachments.s3-us-west-2.amazonaws.com/000/072/882/cddc74dce8b0c1cb33f907909f3b239881514b9b/do_getpass.c?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ2IMG7FL4%2F20181206%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20181206T222918Z&X-Amz-Expires=3600&X-Amz-Security-Token=FQoGZXIvYXdzEA8aDHPJ1yKYcYWYj%2F9LNiK3AzyAo4x%2BPxakyZiJlRkk9M72fGqw4SrPH5qRWwrCEzUaWrTNXkqpALXRS4Q9wnQBmHJ21tNzuwZNzHm1q41ngqtlwpJP4F8P9DJ8J86pGXCj5zxKl27Xdyrp0yXro5KHbNg%2FMI31tP3CPajYLHppvbpzE4HgT6%2BgX56T9THRU9i0iPR2sPERJ5V8T5PqNGlaAxkIH%2BcDEYPwwdeod1TBqaVJeTbSTUwavuHFWj8I9aJc5ijS9LvHWHNGB5FXbFATn8ghcjqVzqIroA9nxNuPJ2vxIaAor9r4p%2Fy1e5TWqKKtSEWtQu68kIwE8NsRg80HQRso%2BCvRE8ecUk4iHSIS0Q3jmxteI2SvJRO0qZ3QaRjTDGmiTz95bj%2F%2F4H%2BR7Jy4C8RK9HLXC%2BPnDh%2FazH%2BgKdjL01iP%2BgzbXEnOyhh3IA5Imss19EK%2B2EWDifocttquTy%2F9L1a3OBtcs43O1R7Q7IURroixlPAhRunZI2Z9MyZSlDzcJsSgY9uPguXfm%2BdDi6ysAHwhyXucVtSiReGyNvDkzSArwNHacFF2yzh47gdSbs3NLHHvBIWOzk4ozBhf5yrOj2mTit4ouKem4AU%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=8fd179ba7cbeac439c3323d976e6ca027ed4e48104302609e18be483198d69f9"
        }, 
        {
            "file_name": "base64_decode.c", 
            "type": "text/x-c", 
            "id": 72883, 
            "expiring_url": "https://hackerone-us-west-2-production-attachments.s3-us-west-2.amazonaws.com/000/072/883/2a81f5207bb56e2e25405dafcbf323265d2a04fc/base64_decode.c?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ2IMG7FL4%2F20181206%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20181206T222918Z&X-Amz-Expires=3600&X-Amz-Security-Token=FQoGZXIvYXdzEA8aDHPJ1yKYcYWYj%2F9LNiK3AzyAo4x%2BPxakyZiJlRkk9M72fGqw4SrPH5qRWwrCEzUaWrTNXkqpALXRS4Q9wnQBmHJ21tNzuwZNzHm1q41ngqtlwpJP4F8P9DJ8J86pGXCj5zxKl27Xdyrp0yXro5KHbNg%2FMI31tP3CPajYLHppvbpzE4HgT6%2BgX56T9THRU9i0iPR2sPERJ5V8T5PqNGlaAxkIH%2BcDEYPwwdeod1TBqaVJeTbSTUwavuHFWj8I9aJc5ijS9LvHWHNGB5FXbFATn8ghcjqVzqIroA9nxNuPJ2vxIaAor9r4p%2Fy1e5TWqKKtSEWtQu68kIwE8NsRg80HQRso%2BCvRE8ecUk4iHSIS0Q3jmxteI2SvJRO0qZ3QaRjTDGmiTz95bj%2F%2F4H%2BR7Jy4C8RK9HLXC%2BPnDh%2FazH%2BgKdjL01iP%2BgzbXEnOyhh3IA5Imss19EK%2B2EWDifocttquTy%2F9L1a3OBtcs43O1R7Q7IURroixlPAhRunZI2Z9MyZSlDzcJsSgY9uPguXfm%2BdDi6ysAHwhyXucVtSiReGyNvDkzSArwNHacFF2yzh47gdSbs3NLHHvBIWOzk4ozBhf5yrOj2mTit4ouKem4AU%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=22833cb5c47afb709235ac0e36d25ae421257b08f25ad401cb05c2ff74efb0a0"
        }, 
        {
            "file_name": "write_escaped_data.c", 
            "type": "text/x-c", 
            "id": 72884, 
            "expiring_url": "https://hackerone-us-west-2-production-attachments.s3-us-west-2.amazonaws.com/000/072/884/54688db732a59d28081d671200cfc4b7efe26e79/write_escaped_data.c?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ2IMG7FL4%2F20181206%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20181206T222918Z&X-Amz-Expires=3600&X-Amz-Security-Token=FQoGZXIvYXdzEA8aDHPJ1yKYcYWYj%2F9LNiK3AzyAo4x%2BPxakyZiJlRkk9M72fGqw4SrPH5qRWwrCEzUaWrTNXkqpALXRS4Q9wnQBmHJ21tNzuwZNzHm1q41ngqtlwpJP4F8P9DJ8J86pGXCj5zxKl27Xdyrp0yXro5KHbNg%2FMI31tP3CPajYLHppvbpzE4HgT6%2BgX56T9THRU9i0iPR2sPERJ5V8T5PqNGlaAxkIH%2BcDEYPwwdeod1TBqaVJeTbSTUwavuHFWj8I9aJc5ijS9LvHWHNGB5FXbFATn8ghcjqVzqIroA9nxNuPJ2vxIaAor9r4p%2Fy1e5TWqKKtSEWtQu68kIwE8NsRg80HQRso%2BCvRE8ecUk4iHSIS0Q3jmxteI2SvJRO0qZ3QaRjTDGmiTz95bj%2F%2F4H%2BR7Jy4C8RK9HLXC%2BPnDh%2FazH%2BgKdjL01iP%2BgzbXEnOyhh3IA5Imss19EK%2B2EWDifocttquTy%2F9L1a3OBtcs43O1R7Q7IURroixlPAhRunZI2Z9MyZSlDzcJsSgY9uPguXfm%2BdDi6ysAHwhyXucVtSiReGyNvDkzSArwNHacFF2yzh47gdSbs3NLHHvBIWOzk4ozBhf5yrOj2mTit4ouKem4AU%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=6fa468b67a24d64c2f722f3201eb155eac3734941b12a2cddd7c19d87095f72a"
        }
    ], 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "created_at": "2016-02-10T12:04:49.026Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-02-10T12:04:49.026Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Looks like I ruined the layout a bit in the ```write_escaped_data``` chapter, I had meant to put the listing of that function there.", 
            "markdown_message": "<p>Looks like I ruined the layout a bit in the <code>write_escaped_data</code> chapter, I had meant to put the listing of that function there.</p>\n", 
            "type": "Activities::Comment", 
            "id": 792713, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-02-13T01:23:52.546Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-02-13T01:23:52.546Z", 
            "actor": {
                "username": "asn", 
                "url": "/asn", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Hello guido,\n\nthanks for the new bug reports!\n\nI'll forward them to more Tor devs tomorrow, and handle them all next week.\n\nLet me know if you are in a hurry and I will allocate extra resources to this end.\n\nThanks!", 
            "markdown_message": "<p>Hello guido,</p>\n\n<p>thanks for the new bug reports!</p>\n\n<p>I&#39;ll forward them to more Tor devs tomorrow, and handle them all next week.</p>\n\n<p>Let me know if you are in a hurry and I will allocate extra resources to this end.</p>\n\n<p>Thanks!</p>\n", 
            "type": "Activities::Comment", 
            "id": 796542, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-02-13T11:39:47.461Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-02-13T11:39:47.461Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Not in a hurry, take your time :).\n\nGuido", 
            "markdown_message": "<p>Not in a hurry, take your time :).</p>\n\n<p>Guido</p>\n", 
            "type": "Activities::Comment", 
            "id": 796774, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-02T23:18:03.478Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-02T23:18:03.478Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Hi, could you please comment on this one?", 
            "markdown_message": "<p>Hi, could you please comment on this one?</p>\n", 
            "type": "Activities::Comment", 
            "id": 821763, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-03T14:48:00.910Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-03T14:48:00.910Z", 
            "actor": {
                "username": "asn", 
                "url": "/asn", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Hello there,\n\nthe fact that this report contains multiple bugs makes it hard to analyze and figure out it's reward.\n\nAfter discussion with other Tor devs, we are mainly concerned about the bug in `write_escaped_data` but we can't find a nice way to remotely trigger it either.\n\nThe `base64_decode()` bug is also interesting but we couldn't find a place where we call it with such huge strings from the network.  The size of most directory documents are restricted by size. If you can find such a codepath, please let us know.\n\nWith the current state of this bug report, we are considering rewarding $500 to this bug report, mainly because of the two bugs above.\n\nI will let this open some more in case you get more time to analyze this.\n\nThanks again!\n", 
            "markdown_message": "<p>Hello there,</p>\n\n<p>the fact that this report contains multiple bugs makes it hard to analyze and figure out it&#39;s reward.</p>\n\n<p>After discussion with other Tor devs, we are mainly concerned about the bug in <code>write_escaped_data</code> but we can&#39;t find a nice way to remotely trigger it either.</p>\n\n<p>The <code>base64_decode()</code> bug is also interesting but we couldn&#39;t find a place where we call it with such huge strings from the network.  The size of most directory documents are restricted by size. If you can find such a codepath, please let us know.</p>\n\n<p>With the current state of this bug report, we are considering rewarding $500 to this bug report, mainly because of the two bugs above.</p>\n\n<p>I will let this open some more in case you get more time to analyze this.</p>\n\n<p>Thanks again!</p>\n", 
            "type": "Activities::Comment", 
            "id": 822610, 
            "genius_execution_id": null
        }, 
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2016-03-08T16:59:22.472Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-08T16:59:22.472Z", 
            "actor": {
                "url": "/torproject", 
                "profile": {
                    "name": "Tor"
                }, 
                "ibb": false, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/001/800/f60c4e0509668a31fcd9604fc653ef8a43f2e5c4_medium.jpg?1453239375"
                }
            }, 
            "team_handle": "torproject", 
            "bounty_amount": "500.0", 
            "collaborator": {
                "username": "guido", 
                "url": "/guido"
            }, 
            "message": "Awarding $500 here. Will update the ticket when we file the bugs on the bug tracker.\nThanks!", 
            "markdown_message": "<p>Awarding $500 here. Will update the ticket when we file the bugs on the bug tracker.<br>\nThanks!</p>\n", 
            "type": "Activities::BountyAwarded", 
            "id": 829270, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-08T22:39:35.622Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-08T22:39:35.622Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Thanks!!", 
            "markdown_message": "<p>Thanks!!</p>\n", 
            "type": "Activities::Comment", 
            "id": 829914, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-23T09:06:25.158Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-23T09:06:25.158Z", 
            "actor": {
                "username": "geko", 
                "url": "/geko", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BugTriaged", 
            "id": 864330, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-05-26T14:58:07.044Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-05-26T14:58:07.044Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "Can this one too be marked as \"resolved\" when you're ready? Thanks.", 
            "markdown_message": "<p>Can this one too be marked as &quot;resolved&quot; when you&#39;re ready? Thanks.</p>\n", 
            "type": "Activities::Comment", 
            "id": 985190, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "guido", 
                "url": "/guido"
            }, 
            "created_at": "2016-05-26T16:27:49.098Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-05-26T16:27:49.098Z", 
            "actor": {
                "username": "asn", 
                "url": "/asn", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "message": "there you go. Sorry. Pretty new to this hackerone thing :)", 
            "markdown_message": "<p>there you go. Sorry. Pretty new to this hackerone thing :)</p>\n", 
            "type": "Activities::BugResolved", 
            "id": 985368, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-10-27T13:13:57.793Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-10-27T13:13:57.793Z", 
            "actor": {
                "username": "asn", 
                "url": "/asn", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "torproject", 
            "first_to_agree": true, 
            "message": "Handled as part of tor's tickets #19281 and #19222.", 
            "markdown_message": "<p>Handled as part of tor&#39;s tickets <a href=\"/reports/19281\">#19281</a> and <a href=\"/reports/19222\">#19222</a>.</p>\n", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 2108317, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2017-11-26T13:14:04.258Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2017-11-26T13:14:04.258Z", 
            "actor": {
                "url": "/torproject", 
                "profile": {
                    "name": "Tor"
                }, 
                "ibb": false, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/001/800/f60c4e0509668a31fcd9604fc653ef8a43f2e5c4_medium.jpg?1453239375"
                }
            }, 
            "team_handle": "torproject", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 2182463, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "guido", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/guido", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/002/983/bc1fffcbbb736a8fa94816a1961b7b76725881eb_small.jpg?1403536399"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 57, 
        "name": "Violation of Secure Design Principles"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -32433320.261474553, 
    "disclosed_at": "2017-11-26T13:14:04.234Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/115686", 
    "created_at": "2016-02-10T12:02:55.218Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<h1 id=\"replacing-all-tor_malloc-calls-with-tor_calloc-and-tor_malloc_zero\">Replacing all <code>tor_malloc</code> calls with tor_calloc and <code>tor_malloc_zero</code>\n</h1>\n\n<p>Zeroing memory upon allocating it will prevent vulnerabilities that consist of transmitting data buffers which are not wholly initialized with the intended data (or contain remnants of previous contents).</p>\n\n<p>Pseudocode:</p>\n<pre class=\"highlight c\"><code><span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">outbuffer</span> <span class=\"o\">=</span> <span class=\"n\">tor_malloc</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span>\n<span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">outbuffer</span><span class=\"p\">,</span> <span class=\"n\">inbuffer</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">);</span>\n<span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">outbuffer</span><span class=\"p\">);</span>\n</code></pre>\n<p>If <code>i</code> is the result of a calculation whose outcome is <u>presumed</u> to align with the outbuffer&#39;s size (100), but in practice is prone to a corner-case where the result is in fact less than 100, then whatever uninitialized memory is present in the allocated heap memory will be transmitted to the other party.</p>\n\n<p>But if you&#39;re using <code>tor_malloc_zero</code> instead, then the uninitialized memory would simply consist of zeroes, and thus useless for a malicious recipient of the buffer.</p>\n\n<p><code>tor_calloc</code> is like <code>tor_malloc_zero</code> in that it zeroes the allocated memory before disclosing it to the invoking function, and moreover has the property of accepting two size_t parameters and verifying whether the product (result of multiplication) is prone to an overflow, and fails if it is. Therefore, it is ideal to use as a substitute for manual multiplication in preparation for a <code>tor_malloc</code> or <code>tor_malloc_zero</code>:</p>\n<pre class=\"highlight c\"><code><span class=\"n\">tor_malloc</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">some_struct_t</span><span class=\"p\">));</span>\n</code></pre>\n<p>In instances such as this, it is again <u>presumed</u> that the product of <code>n</code> and the <code>sizeof</code> cannot result in an overflow. Even when this is fairly obvious, I&#39;d say there is no reason to delegate the multiplication to <code>tor_calloc</code> that offers a hard guarantee that the multiplication is safe. As your code grows, and the value of <code>n</code> starts hinging on factors that may not be immediately obvious, or if fields are added to some_struct_t in order to cater to future requirements, overflows may become a reality without the protection that <code>tor_calloc</code> offers.</p>\n\n<h1 id=\"potential-heap-corruption-via-write_escaped_data-in-control-c\">Potential heap corruption via <code>write_escaped_data</code> in control.c</h1>\n\n<p>/** Given a &lt;b&gt;len&lt;/b&gt;-character string in &lt;b&gt;data&lt;/b&gt;, made of lines</p>\n\n<ul>\n<li>terminated by CRLF, allocate a new string in *&lt;b&gt;out&lt;/b&gt;, and copy the</li>\n<li>contents of &lt;b&gt;data&lt;/b&gt; into *&lt;b&gt;out&lt;/b&gt;, adding a period before any period</li>\n<li>that appears at the start of a line, and adding a period-CRLF line at</li>\n<li>the end. Replace all LF characters sequences with CRLF.  Return the number</li>\n<li>of bytes in <em>&lt;b&gt;out&lt;/b&gt;.\n*/\nSTATIC size_t\nwrite_escaped_data(const char *data, size_t len, char **out)\n{\nsize_t sz_out = len+8;\nchar *outp;\nconst char *start = data, *end;\nint i;\nint start_of_line;\nfor (i=0; i&lt;(int)len; ++i) {\nif (data[i]== &#39;\\n&#39;)\n  sz_out += 2; /</em> Maybe add a CR; maybe add a dot. <em>/\n}\n*out = outp = tor_malloc(sz_out+1);\nend = data+len;\nstart_of_line = 1;\nwhile (data &lt; end) {\nif (*data == &#39;\\n&#39;) {\n  if (data &gt; start &amp;&amp; data[-1] != &#39;\\r&#39;)\n    *outp++ = &#39;\\r&#39;;\n  start_of_line = 1;\n} else if (*data == &#39;.&#39;) {\n  if (start_of_line) {\n    start_of_line = 0;\n    *outp++ = &#39;.&#39;;\n  }\n} else {\n  start_of_line = 0;\n}\n*outp++ = *data++;\n}\nif (outp &lt; *out+2 || fast_memcmp(outp-2, &quot;\\r\\n&quot;, 2)) {\n*outp++ = &#39;\\r&#39;;\n*outp++ = &#39;\\n&#39;;\n}\n*outp++ = &#39;.&#39;;\n*outp++ = &#39;\\r&#39;;\n*outp++ = &#39;\\n&#39;;\n*outp = &#39;\\0&#39;; /</em> NUL-terminate just in case. */\ntor_assert((outp - *out) &lt;= (int)sz_out);\nreturn outp - *out;\n}</li>\n</ul>\n\n<p>There are two potential vulnerabilities lurking here:</p>\n\n<ol>\n<li>If the input size (<code>len</code>) &gt;= 0x80000000, then this loop will not execute at all:</li>\n</ol>\n<pre class=\"highlight c\"><code>  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"n\">len</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">==</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">)</span>\n      <span class=\"n\">sz_out</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"cm\">/* Maybe add a CR; maybe add a dot. */</span>\n  <span class=\"p\">}</span>\n</code></pre>\n<p>Because the condition <code>i&lt;(int)len</code> is effectively <code>i&lt;(negative number)</code> and <code>i</code> is intialized to 0, this can never be true. As a result of this, the output buffer (whose size is based on sz_out) is too small to hold the result for an input buffer containing &#39;\\n&#39; characters.<br>\nTriggering this is typically only feasible on a 64-bit system, because if the input buffer is &gt;= 0x80000000 bytes, then sz_out is set to 0x80000008 bytes, and allocating such an amount twice (one for the input buffer, and one for the output buffer) is not possible on a 32-bit system.</p>\n\n<ol>\n<li>If the equation (number of &#39;\\n&#39; characters in input buffer * 2 + size of input buffer) exceeds 0xFFFFFFFF, then this will cause heap corruption on a 32-bit system, because sz_out overflows.</li>\n</ol>\n\n<p>See my attached proof of concept. Compile and execute like this:</p>\n<pre class=\"highlight c\"><code><span class=\"n\">gcc</span> <span class=\"o\">-</span><span class=\"n\">fsanitize</span><span class=\"o\">=</span><span class=\"n\">address</span> <span class=\"o\">-</span><span class=\"n\">fomit</span><span class=\"o\">-</span><span class=\"n\">frame</span><span class=\"o\">-</span><span class=\"n\">pointer</span> <span class=\"n\">write_escaped_data</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"p\">;</span> <span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">out</span> <span class=\"mi\">1</span>\n<span class=\"n\">gcc</span> <span class=\"o\">-</span><span class=\"n\">m32</span> <span class=\"o\">-</span><span class=\"n\">fsanitize</span><span class=\"o\">=</span><span class=\"n\">address</span> <span class=\"o\">-</span><span class=\"n\">fomit</span><span class=\"o\">-</span><span class=\"n\">frame</span><span class=\"o\">-</span><span class=\"n\">pointer</span> <span class=\"n\">write_escaped_data</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"p\">;</span> <span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">out</span> <span class=\"mi\">2</span>\n</code></pre>\n<p>As for real exploitability, I spent some effort on creating a real, remote proof of concept for this, but because the data that write_escaped_data may process is the result a multitude of (to me) intricate processes it is hard to come up with a reliable attack.</p>\n\n<p><code>write_escaped_data</code> draws data from all the getinfo_helper_* functions (via <code>handle_control_getinfo</code> and <code>handle_getinfo_helper</code>) as well as the amalgate of many potentially many, reasonably large strings in <code>control_event_networkstatus_changed_helper</code>: </p>\n<pre class=\"highlight c\"><code>  <span class=\"n\">SMARTLIST_FOREACH</span><span class=\"p\">(</span><span class=\"n\">statuses</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">routerstatus_t</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">rs</span><span class=\"p\">,</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">networkstatus_getinfo_helper_single</span><span class=\"p\">(</span><span class=\"n\">rs</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"k\">continue</span><span class=\"p\">;</span>\n      <span class=\"n\">smartlist_add</span><span class=\"p\">(</span><span class=\"n\">strs</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n\n  <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">smartlist_join_strings</span><span class=\"p\">(</span><span class=\"n\">strs</span><span class=\"p\">,</span> <span class=\"s\">&quot;&quot;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n  <span class=\"n\">write_escaped_data</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">strlen</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">),</span> <span class=\"o\">&amp;</span><span class=\"n\">esc</span><span class=\"p\">);</span>\n</code></pre>\n<h1 id=\"base64_decode-potential-heap-corruption-on-32-bit-systems\">base64_decode potential heap corruption on 32-bit systems</h1>\n<pre class=\"highlight c\"><code><span class=\"kt\">int</span>\n<span class=\"nf\">base64_decode</span><span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">dest</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">destlen</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">srclen</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"p\">...</span>\n<span class=\"p\">...</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">destlen</span> <span class=\"o\">&lt;</span> <span class=\"p\">(</span><span class=\"n\">srclen</span><span class=\"o\">*</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">destlen</span> <span class=\"o\">&gt;</span> <span class=\"n\">SIZE_T_CEILING</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n</code></pre>\n<p>The problem here is that the multiplication (by 3) occurs before the division (by 4).</p>\n\n<p>For source strings larger than 0xFFFFFFFF / 3 == 0x55555555, an overflow will occur within this calculation. If the result of the overflow-affected calculation is smaller than what <code>destlen</code> is, then this check will be passed and memory will be corrupted.</p>\n\n<p>See my proof of concept:</p>\n<pre class=\"highlight plaintext\"><code>$ gcc -m32 -fsanitize=address -fomit-frame-pointer base64_decode.c; ./a.out \n=================================================================\n==32449== ERROR: AddressSanitizer: stack-buffer-overflow on address 0xfff6fe04 at pc 0x804898b bp 0xfff6fcf8 sp 0xfff6fcec\n...\n...\n</code></pre>\n<h1 id=\"potential-heap-corruption-in-do_getpass-in-routerkeys-c\">Potential heap corruption in do_getpass in routerkeys.c</h1>\n\n<p>At present this cannot be triggered, but, unless this code was designed like this on purpose and you&#39;re aware of the weakness, you might want to revisit it.</p>\n\n<p><code>do_getpass</code> contains this code:</p>\n<pre class=\"highlight c\"><code>  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">twice</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"n\">msg</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"s\">&quot;One more time:&quot;</span><span class=\"p\">;</span>\n    <span class=\"kt\">size_t</span> <span class=\"n\">p2len</span> <span class=\"o\">=</span> <span class=\"n\">strlen</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p2len</span> <span class=\"o\">&lt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">))</span>\n      <span class=\"n\">p2len</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">);</span>\n    <span class=\"n\">prompt2</span> <span class=\"o\">=</span> <span class=\"n\">tor_malloc</span><span class=\"p\">(</span><span class=\"n\">strlen</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">memset</span><span class=\"p\">(</span><span class=\"n\">prompt2</span><span class=\"p\">,</span> <span class=\"sc\">&#39; &#39;</span><span class=\"p\">,</span> <span class=\"n\">p2len</span><span class=\"p\">);</span>\n    <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">prompt2</span> <span class=\"o\">+</span> <span class=\"n\">p2len</span> <span class=\"o\">-</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">),</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">));</span>\n\n    <span class=\"n\">buf2</span> <span class=\"o\">=</span> <span class=\"n\">tor_malloc_zero</span><span class=\"p\">(</span><span class=\"n\">buflen</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n</code></pre>\n<p>There is only one call to this function in the code for which twice == 1:</p>\n<pre class=\"highlight plaintext\"><code>  if (do_getpass(&quot;Enter new passphrase:&quot;, pwbuf0, sizeof(pwbuf0), 1,\n                 get_options()) &lt; 0) {\n    log_warn(LD_OR, &quot;NO/failed passphrase&quot;);\n    return -1;\n  }\n</code></pre>\n<p>This will not trigger a memory corruption, but if the first parameter had been shorter, it would:</p>\n\n<p>Compile and run like this:</p>\n<pre class=\"highlight plaintext\"><code>$ gcc -fomit-frame-pointer -fsanitize=address do_getpass.c \n$ ./a.out &quot;Enter new passphrase:&quot;\n$ ./a.out &quot;Enter new passphrase&quot;\n$ ./a.out &quot;Enter new passphras&quot;\n$ ./a.out &quot;Enter new passphra&quot;\n$ ./a.out &quot;Enter new passphr&quot;\n$ ./a.out &quot;Enter new passph&quot;\n$ ./a.out &quot;Enter new passp&quot;\n$ ./a.out &quot;Enter new pass&quot;\n$ ./a.out &quot;Enter new pas&quot;\n\n==7883== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000dffe at pc 0x400c0a bp 0x7fff8d9c22e0 sp 0x7fff8d9c22d8\n...\n...\n</code></pre>\n<p>So it&#39;s not really a vulnerability at present, but I thought I&#39;d mention it to you since it struck me as odd and it could become a problem if you pass a dynamic, potentially short string (for ex. created with snprintf) to do_getpass.</p>\n", 
    "vulnerability_information": "Replacing all ```tor_malloc``` calls with tor_calloc and ```tor_malloc_zero```\n==============================================================\n\nZeroing memory upon allocating it will prevent vulnerabilities that consist of transmitting data buffers which are not wholly initialized with the intended data (or contain remnants of previous contents).\n\nPseudocode:\n```c\nchar* outbuffer = tor_malloc(100);\nmemcpy(outbuffer, inbuffer, i);\nsend(outbuffer);\n```\n\nIf ```i``` is the result of a calculation whose outcome is _presumed_ to align with the outbuffer's size (100), but in practice is prone to a corner-case where the result is in fact less than 100, then whatever uninitialized memory is present in the allocated heap memory will be transmitted to the other party.\n\nBut if you're using ```tor_malloc_zero``` instead, then the uninitialized memory would simply consist of zeroes, and thus useless for a malicious recipient of the buffer.\n\n```tor_calloc``` is like ```tor_malloc_zero``` in that it zeroes the allocated memory before disclosing it to the invoking function, and moreover has the property of accepting two size_t parameters and verifying whether the product (result of multiplication) is prone to an overflow, and fails if it is. Therefore, it is ideal to use as a substitute for manual multiplication in preparation for a ```tor_malloc``` or ```tor_malloc_zero```:\n\n```c\ntor_malloc(n * sizeof(some_struct_t));\n```\n\nIn instances such as this, it is again _presumed_ that the product of ```n``` and the ```sizeof``` cannot result in an overflow. Even when this is fairly obvious, I'd say there is no reason to delegate the multiplication to ```tor_calloc``` that offers a hard guarantee that the multiplication is safe. As your code grows, and the value of ```n``` starts hinging on factors that may not be immediately obvious, or if fields are added to some_struct_t in order to cater to future requirements, overflows may become a reality without the protection that ```tor_calloc``` offers.\n\nPotential heap corruption via ```write_escaped_data``` in control.c\n==============================================================\n/** Given a <b>len</b>-character string in <b>data</b>, made of lines\n * terminated by CRLF, allocate a new string in *<b>out</b>, and copy the\n * contents of <b>data</b> into *<b>out</b>, adding a period before any period\n * that appears at the start of a line, and adding a period-CRLF line at\n * the end. Replace all LF characters sequences with CRLF.  Return the number\n * of bytes in *<b>out</b>.\n */\nSTATIC size_t\nwrite_escaped_data(const char *data, size_t len, char **out)\n{\n  size_t sz_out = len+8;\n  char *outp;\n  const char *start = data, *end;\n  int i;\n  int start_of_line;\n  for (i=0; i<(int)len; ++i) {\n    if (data[i]== '\\n')\n      sz_out += 2; /* Maybe add a CR; maybe add a dot. */\n  }\n  *out = outp = tor_malloc(sz_out+1);\n  end = data+len;\n  start_of_line = 1;\n  while (data < end) {\n    if (*data == '\\n') {\n      if (data > start && data[-1] != '\\r')\n        *outp++ = '\\r';\n      start_of_line = 1;\n    } else if (*data == '.') {\n      if (start_of_line) {\n        start_of_line = 0;\n        *outp++ = '.';\n      }\n    } else {\n      start_of_line = 0;\n    }\n    *outp++ = *data++;\n  }\n  if (outp < *out+2 || fast_memcmp(outp-2, \"\\r\\n\", 2)) {\n    *outp++ = '\\r';\n    *outp++ = '\\n';\n  }\n  *outp++ = '.';\n  *outp++ = '\\r';\n  *outp++ = '\\n';\n  *outp = '\\0'; /* NUL-terminate just in case. */\n  tor_assert((outp - *out) <= (int)sz_out);\n  return outp - *out;\n}\n\nThere are two potential vulnerabilities lurking here:\n\n1. If the input size (```len```) >= 0x80000000, then this loop will not execute at all:\n        \n```c\n  for (i=0; i<(int)len; ++i) {\n    if (data[i]== '\\n')\n      sz_out += 2; /* Maybe add a CR; maybe add a dot. */\n  }\n```\n\nBecause the condition ```i<(int)len``` is effectively ```i<(negative number)``` and ```i``` is intialized to 0, this can never be true. As a result of this, the output buffer (whose size is based on sz_out) is too small to hold the result for an input buffer containing '\\n' characters.\nTriggering this is typically only feasible on a 64-bit system, because if the input buffer is >= 0x80000000 bytes, then sz_out is set to 0x80000008 bytes, and allocating such an amount twice (one for the input buffer, and one for the output buffer) is not possible on a 32-bit system.\n\n2. If the equation (number of '\\n' characters in input buffer * 2 + size of input buffer) exceeds 0xFFFFFFFF, then this will cause heap corruption on a 32-bit system, because sz_out overflows.\n\nSee my attached proof of concept. Compile and execute like this:\n\n```c\ngcc -fsanitize=address -fomit-frame-pointer write_escaped_data.c; ./a.out 1\ngcc -m32 -fsanitize=address -fomit-frame-pointer write_escaped_data.c; ./a.out 2\n```\n\nAs for real exploitability, I spent some effort on creating a real, remote proof of concept for this, but because the data that write_escaped_data may process is the result a multitude of (to me) intricate processes it is hard to come up with a reliable attack.\n\n```write_escaped_data``` draws data from all the getinfo_helper_* functions (via ```handle_control_getinfo``` and ```handle_getinfo_helper```) as well as the amalgate of many potentially many, reasonably large strings in ```control_event_networkstatus_changed_helper```: \n\n```c\n  SMARTLIST_FOREACH(statuses, const routerstatus_t *, rs,\n    {\n      s = networkstatus_getinfo_helper_single(rs);\n      if (!s) continue;\n      smartlist_add(strs, s);\n    });\n\n  s = smartlist_join_strings(strs, \"\", 0, NULL);\n  write_escaped_data(s, strlen(s), &esc);\n```\n\nbase64_decode potential heap corruption on 32-bit systems\n==============================================================\n```c\nint\nbase64_decode(char *dest, size_t destlen, const char *src, size_t srclen)\n{\n...\n...\n  if (destlen < (srclen*3)/4)\n    return -1;\n  if (destlen > SIZE_T_CEILING)\n    return -1;\n```\n\nThe problem here is that the multiplication (by 3) occurs before the division (by 4).\n\nFor source strings larger than 0xFFFFFFFF / 3 == 0x55555555, an overflow will occur within this calculation. If the result of the overflow-affected calculation is smaller than what ```destlen``` is, then this check will be passed and memory will be corrupted.\n\nSee my proof of concept:\n\n```\n$ gcc -m32 -fsanitize=address -fomit-frame-pointer base64_decode.c; ./a.out \n=================================================================\n==32449== ERROR: AddressSanitizer: stack-buffer-overflow on address 0xfff6fe04 at pc 0x804898b bp 0xfff6fcf8 sp 0xfff6fcec\n...\n...\n```\n\nPotential heap corruption in do_getpass in routerkeys.c\n==============================================================\nAt present this cannot be triggered, but, unless this code was designed like this on purpose and you're aware of the weakness, you might want to revisit it.\n\n```do_getpass``` contains this code:\n```c\n  if (twice) {\n    const char msg[] = \"One more time:\";\n    size_t p2len = strlen(prompt) + 1;\n    if (p2len < sizeof(msg))\n      p2len = sizeof(msg);\n    prompt2 = tor_malloc(strlen(prompt)+1);\n    memset(prompt2, ' ', p2len);\n    memcpy(prompt2 + p2len - sizeof(msg), msg, sizeof(msg));\n\n    buf2 = tor_malloc_zero(buflen);\n  }\n```\n\nThere is only one call to this function in the code for which twice == 1:\n\n```code\n  if (do_getpass(\"Enter new passphrase:\", pwbuf0, sizeof(pwbuf0), 1,\n                 get_options()) < 0) {\n    log_warn(LD_OR, \"NO/failed passphrase\");\n    return -1;\n  }\n```\n\nThis will not trigger a memory corruption, but if the first parameter had been shorter, it would:\n\nCompile and run like this:\n\n```\n$ gcc -fomit-frame-pointer -fsanitize=address do_getpass.c \n$ ./a.out \"Enter new passphrase:\"\n$ ./a.out \"Enter new passphrase\"\n$ ./a.out \"Enter new passphras\"\n$ ./a.out \"Enter new passphra\"\n$ ./a.out \"Enter new passphr\"\n$ ./a.out \"Enter new passph\"\n$ ./a.out \"Enter new passp\"\n$ ./a.out \"Enter new pass\"\n$ ./a.out \"Enter new pas\"\n\n==7883== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000dffe at pc 0x400c0a bp 0x7fff8d9c22e0 sp 0x7fff8d9c22d8\n...\n...\n```\n\nSo it's not really a vulnerability at present, but I thought I'd mention it to you since it struck me as odd and it could become a problem if you pass a dynamic, potentially short string (for ex. created with snprintf) to do_getpass.", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "https://www.torproject.org/", 
            "about": "Anonymity Online", 
            "twitter_handle": "torproject", 
            "name": "Tor"
        }, 
        "handle": "torproject", 
        "url": "https://hackerone.com/torproject", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/001/800/fe36670e5f7b7381549279801c447ae8a3ee12b0_small.jpg?1453239375", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/001/800/f60c4e0509668a31fcd9604fc653ef8a43f2e5c4_medium.jpg?1453239375"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 1800, 
        "default_currency": "usd"
    }, 
    "is_published": false
}