{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": "2016-03-31T21:41:43.070Z", 
    "voters": [
        "geeknik", 
        "dyabla"
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "1000.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 110352, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2016-03-20T03:44:22.929Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "Perl 5.22 VDir::MapPathA/W Out-of-bounds Reads and Buffer Over-reads", 
    "is_member_of_team?": null, 
    "vote_count": 2, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2016-04-19T03:44:23.099Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$1,000", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2016-03-20T03:43:57.725Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-20T03:43:57.725Z", 
            "actor": {
                "url": "/ibb-perl", 
                "profile": {
                    "name": "Perl (IBB)"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/030/61f6fc128a6334a8f80c75f7e7385f1842d774fe_medium.png?1383737333"
                }
            }, 
            "team_handle": "ibb-perl", 
            "bounty_amount": "1000.0", 
            "collaborator": {
                "username": "johnleitch", 
                "url": "/johnleitch"
            }, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BountyAwarded", 
            "id": 856326, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "johnleitch", 
                "url": "/johnleitch"
            }, 
            "created_at": "2016-03-20T03:44:08.138Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-20T03:44:08.138Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ibb-perl", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BugResolved", 
            "id": 856399, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-20T03:44:22.965Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-20T03:44:22.965Z", 
            "actor": {
                "username": "arice", 
                "url": "/arice", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/74e2a8a31fee27a0c9b3d1d90dd64f4e38b2fb1c_medium.jpeg?1466604112"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ibb-perl", 
            "first_to_agree": true, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 856504, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-31T21:41:43.116Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-31T21:41:43.116Z", 
            "actor": {
                "username": "johnleitch", 
                "url": "/johnleitch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ibb-perl", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 880860, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-03-31T21:41:43.330Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-03-31T21:41:43.330Z", 
            "actor": {
                "username": "johnleitch", 
                "url": "/johnleitch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ibb-perl", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 880861, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "johnleitch", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/johnleitch", 
        "profile_picture_urls": {
            "small": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 2, 
        "name": "Memory Corruption - Generic"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -83099487.2771044, 
    "disclosed_at": "2016-03-31T21:41:43.301Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/110352", 
    "created_at": "2016-01-13T00:19:09.718Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>I have reported multiple vulnerabilities in Perl that have now been fixed.</p>\n\n<p><a title=\"https://rt.perl.org/Public/Bug/Display.html?id=126755\" href=\"/redirect?signature=124f8c16b4b67da8f54b58ef7541d0669d7b442f&amp;url=https%3A%2F%2Frt.perl.org%2FPublic%2FBug%2FDisplay.html%3Fid%3D126755\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://rt.perl.org/Public/Bug/Display.html?id=126755</span><i class=\"icon-external-link\"></i></a></p>\n\n<hr>\n\n<p>Perl 5.22 suffers from two out-of-bounds read and multiple small buffer over-read vulnerabilities in the VDir::MapPathA and VDir::MapPathW functions that could potentially be exploited to achieve arbitrary code execution. The out-of-bounds read issues exist because the functions in question do not validate that the chr argument passed to DriveIndex, which calculates an index:</p>\n<pre class=\"highlight plaintext\"><code>inline int DriveIndex(char chr)\n{\nif (chr == &#39;\\\\&#39; || chr == &#39;/&#39;)\n    return (&#39;Z&#39;-&#39;A&#39;)+1;\nreturn (chr | 0x20)-&#39;a&#39;;\n};\n</code></pre>\n<p>In the VDir::MapPathA function, DriveIndex is called with a potentially untrusted value, pInName,  and the return value is then passed to GetDirA:</p>\n\n<p>char <em>VDir::MapPathA(const char *pInName)<br>\n{   /</em><br>\n     * possiblities -- relative path or absolute path with or without drive letter<br>\n     * OR UNC name<br>\n     */<br>\n    [...]</p>\n<pre class=\"highlight plaintext\"><code>if (pInName[1] == &#39;:&#39;) {\n[...]\n}\nelse {\n    /* relative path with drive letter */\n    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n    strcat(szBuffer, &amp;pInName[2]);\n    if(strlen(szBuffer) &gt; MAX_PATH)\n    szBuffer[MAX_PATH] = &#39;\\0&#39;;\n\n    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n}\n}\nelse {\n[...]\n}\n\nreturn szLocalBufferA;\n</code></pre>\n<p>}</p>\n\n<p>GetDirA then uses the unbounded index argument to index into dirTableA, a fixed length char pointer array.</p>\n<pre class=\"highlight plaintext\"><code>inline const char *GetDirA(int index)\n{\nchar *ptr = dirTableA[index];\nif (!ptr) {\n    /* simulate the existence of this drive */\n    ptr = szLocalBufferA;\n    ptr[0] = &#39;A&#39; + index;\n    ptr[1] = &#39;:&#39;;\n    ptr[2] = &#39;\\\\&#39;;\n    ptr[3] = 0;\n}\nreturn ptr;\n};\n</code></pre>\n<p>In cases where index is attacker controlled, this behavior can be used to read outside of the dirTableA array. This is especially problematic because the value returned is then copied to a fixed length buffer using strcpy:</p>\n\n<p>strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));</p>\n\n<p>If an attacker can manipulate the layout of memory to trick GetDirA into returning a string larger than szBuffer, a buffer overflow will occur. The issue in VDir::MapPathW is nearly identical..</p>\n\n<p>Further, multiple small and less critical buffer over-reads exist in both VDir::MapPathA and VDir::MapPathW:</p>\n\n<p>char <em>VDir::MapPathA(const char *pInName)<br>\n{   /</em><br>\n     * possiblities -- relative path or absolute path with or without drive letter<br>\n     * OR UNC name<br>\n     */<br>\n    [...]</p>\n<pre class=\"highlight plaintext\"><code>if (!length) &lt;&lt;&lt; Check here confirms the buffer is at least of length 2 (including null) before continuing execution.\nreturn (char*)pInName;\n\n[...]\n\nif (pInName[1] == &#39;:&#39;) { &lt;&lt;&lt; While technically no over-read can occur here, pInName is a single character, this checks the null terminator.\n/* has drive letter */\nif (IsPathSep(pInName[2])) { &lt;&lt;&lt;&lt; This could cause an over-read because the string could possibly be of length 2 (including null).\n    /* absolute with drive letter */\n    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n}\nelse {\n    /* relative path with drive letter */\n    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n    strcat(szBuffer, &amp;pInName[2]); &lt;&lt;&lt;&lt; This could cause an over-read for the same reason.\n    if(strlen(szBuffer) &gt; MAX_PATH)\n    szBuffer[MAX_PATH] = &#39;\\0&#39;;\n\n    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n}\n}\nelse {\n[...]\n}\n}\n\nreturn szLocalBufferA;\n</code></pre>\n<p>}</p>\n\n<p>To observe the out-of-bounds read vulnerability in VDir::MapPathA, the following script can be executed while Perl is under a debugger:</p>\n\n<p>print glob &quot;]:&quot;;</p>\n\n<p>Which will result in an exception similar to the following:</p>\n\n<p>(f78.1dd8): Access violation - code c0000005 (first chance)<br>\nFirst chance exceptions are reported before any exception handling.<br>\nThis exception may be expected and handled.<br>\neax=0081d62c ebx=0081dae2 ecx=765c7377 edx=7eff3920 esi=0081dae0 edi=0081d62c<br>\neip=747613a0 esp=0081d608 ebp=74744fac iopl=0         nv up ei pl nz na pe nc<br>\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206<br>\nMSVCR110!strcat+0x71:<br>\n747613a0 8a11            mov     dl,byte ptr [ecx]          ds:002b:765c7377=??<br>\n0:000&gt; k<br>\nChildEBP RetAddr<br>\n0081d608 709059ea MSVCR110!strcat+0x71<br>\n0081d940 7090688e perl523!VDir::MapPathA+0xdd<br>\n0081d94c 7090e295 perl523!PerlDirMapPathA+0x1f<br>\n0081dab4 70906736 perl523!win32_stat+0x6e<br>\n0081dac0 72541f60 perl523!PerlLIOLstat+0xd<br>\n0081dee4 7254181b Glob!g_lstat+0x72<br>\n0081df6c 725415e7 Glob!glob2+0x7a<br>\n0081efb0 72541141 Glob!glob0+0x181<br>\n0081f7cc 725420e8 Glob!bsd_glob+0x11d<br>\n0081f814 72542929 Glob!doglob+0x3f<br>\n0081f850 72542391 Glob!csh_glob+0x4a2<br>\n0081f894 708a05f4 Glob!iterate+0x1e8<br>\n0081f8ac 708cd3d8 perl523!Perl_pp_glob+0x19a<br>\n0081f8b8 70871fd8 perl523!Perl_runops_standard+0xc<br>\n0081f8cc 70871ef8 perl523!S_run_body+0xdf<br>\n0081f938 70908290 perl523!perl_run+0x1e6<br>\n0081fb68 00fe1216 perl523!RunPerl+0xbc<br>\n0081fba8 76de3744 perl!<strong>tmainCRTStartup+0xfd<br>\n0081fbbc 77b7a064 KERNEL32!BaseThreadInitThunk+0x24<br>\n0081fc04 77b7a02f ntdll!</strong>RtlUserThreadStart+0x2f<br>\n0081fc14 00000000 ntdll!_RtlUserThreadStart+0x1b</p>\n\n<p>To fix the issue, it is recommended that the VDir::MapPathA and VDir::MapPathW functions validate the drive letter to ensure no out-of-bounds reads occur, and also check the length of the pInName argument to ensure no buffer over-reads occur. A proposed patch is attached. However, the patch only addresses the issues in VDir::MapPathA because it was not immediately clear how to hit VDir::MapPathW for the purpose of testing.</p>\n\n<p>Credit: John Leitch (<a title=\"john@autosectools.com\" href=\"mailto:john@autosectools.com\" rel=\"nofollow noopener noreferrer\">john@autosectools.com</a>), Bryce Darling (<a title=\"darlingbryce@gmail.com\" href=\"mailto:darlingbryce@gmail.com\" rel=\"nofollow noopener noreferrer\">darlingbryce@gmail.com</a>)</p>\n", 
    "vulnerability_information": "I have reported multiple vulnerabilities in Perl that have now been fixed.\n\nhttps://rt.perl.org/Public/Bug/Display.html?id=126755\n\n---\n\nPerl 5.22 suffers from two out-of-bounds read and multiple small buffer over-read vulnerabilities in the VDir::MapPathA and VDir::MapPathW functions that could potentially be exploited to achieve arbitrary code execution. The out-of-bounds read issues exist because the functions in question do not validate that the chr argument passed to DriveIndex, which calculates an index:\n\n    inline int DriveIndex(char chr)\n    {\n\tif (chr == '\\\\' || chr == '/')\n\t    return ('Z'-'A')+1;\n\treturn (chr | 0x20)-'a';\n    };\n\nIn the VDir::MapPathA function, DriveIndex is called with a potentially untrusted value, pInName,  and the return value is then passed to GetDirA:\n\nchar *VDir::MapPathA(const char *pInName)\n{   /*\n     * possiblities -- relative path or absolute path with or without drive letter\n     * OR UNC name\n     */\n    [...]\n\n    if (pInName[1] == ':') {\n\t[...]\n\t}\n\telse {\n\t    /* relative path with drive letter */\n\t    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\t    strcat(szBuffer, &pInName[2]);\n\t    if(strlen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\n\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n    }\n    else {\n\t[...]\n    }\n\n    return szLocalBufferA;\n}\n\nGetDirA then uses the unbounded index argument to index into dirTableA, a fixed length char pointer array.\n\n    inline const char *GetDirA(int index)\n    {\n\tchar *ptr = dirTableA[index];\n\tif (!ptr) {\n\t    /* simulate the existence of this drive */\n\t    ptr = szLocalBufferA;\n\t    ptr[0] = 'A' + index;\n\t    ptr[1] = ':';\n\t    ptr[2] = '\\\\';\n\t    ptr[3] = 0;\n\t}\n\treturn ptr;\n    };\n\nIn cases where index is attacker controlled, this behavior can be used to read outside of the dirTableA array. This is especially problematic because the value returned is then copied to a fixed length buffer using strcpy:\n\nstrcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\nIf an attacker can manipulate the layout of memory to trick GetDirA into returning a string larger than szBuffer, a buffer overflow will occur. The issue in VDir::MapPathW is nearly identical..\n\nFurther, multiple small and less critical buffer over-reads exist in both VDir::MapPathA and VDir::MapPathW:\n\nchar *VDir::MapPathA(const char *pInName)\n{   /*\n     * possiblities -- relative path or absolute path with or without drive letter\n     * OR UNC name\n     */\n    [...]\n\n    if (!length) <<< Check here confirms the buffer is at least of length 2 (including null) before continuing execution.\n\treturn (char*)pInName;\n\n    [...]\n\n    if (pInName[1] == ':') { <<< While technically no over-read can occur here, pInName is a single character, this checks the null terminator.\n\t/* has drive letter */\n\tif (IsPathSep(pInName[2])) { <<<< This could cause an over-read because the string could possibly be of length 2 (including null).\n\t    /* absolute with drive letter */\n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    /* relative path with drive letter */\n\t    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\t    strcat(szBuffer, &pInName[2]); <<<< This could cause an over-read for the same reason.\n\t    if(strlen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\n\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n    }\n    else {\n\t[...]\n\t}\n    }\n\n    return szLocalBufferA;\n}\n\n\nTo observe the out-of-bounds read vulnerability in VDir::MapPathA, the following script can be executed while Perl is under a debugger:\n\nprint glob \"]:\";\n\nWhich will result in an exception similar to the following:\n\n(f78.1dd8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=0081d62c ebx=0081dae2 ecx=765c7377 edx=7eff3920 esi=0081dae0 edi=0081d62c\neip=747613a0 esp=0081d608 ebp=74744fac iopl=0         nv up ei pl nz na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206\nMSVCR110!strcat+0x71:\n747613a0 8a11            mov     dl,byte ptr [ecx]          ds:002b:765c7377=??\n0:000> k\nChildEBP RetAddr\n0081d608 709059ea MSVCR110!strcat+0x71\n0081d940 7090688e perl523!VDir::MapPathA+0xdd\n0081d94c 7090e295 perl523!PerlDirMapPathA+0x1f\n0081dab4 70906736 perl523!win32_stat+0x6e\n0081dac0 72541f60 perl523!PerlLIOLstat+0xd\n0081dee4 7254181b Glob!g_lstat+0x72\n0081df6c 725415e7 Glob!glob2+0x7a\n0081efb0 72541141 Glob!glob0+0x181\n0081f7cc 725420e8 Glob!bsd_glob+0x11d\n0081f814 72542929 Glob!doglob+0x3f\n0081f850 72542391 Glob!csh_glob+0x4a2\n0081f894 708a05f4 Glob!iterate+0x1e8\n0081f8ac 708cd3d8 perl523!Perl_pp_glob+0x19a\n0081f8b8 70871fd8 perl523!Perl_runops_standard+0xc\n0081f8cc 70871ef8 perl523!S_run_body+0xdf\n0081f938 70908290 perl523!perl_run+0x1e6\n0081fb68 00fe1216 perl523!RunPerl+0xbc\n0081fba8 76de3744 perl!__tmainCRTStartup+0xfd\n0081fbbc 77b7a064 KERNEL32!BaseThreadInitThunk+0x24\n0081fc04 77b7a02f ntdll!__RtlUserThreadStart+0x2f\n0081fc14 00000000 ntdll!_RtlUserThreadStart+0x1b\n\nTo fix the issue, it is recommended that the VDir::MapPathA and VDir::MapPathW functions validate the drive letter to ensure no out-of-bounds reads occur, and also check the length of the pInName argument to ensure no buffer over-reads occur. A proposed patch is attached. However, the patch only addresses the issues in VDir::MapPathA because it was not immediately clear how to hit VDir::MapPathW for the purpose of testing.\n\nCredit: John Leitch (john@autosectools.com), Bryce Darling (darlingbryce@gmail.com)", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "http://www.perl.org", 
            "about": "", 
            "twitter_handle": "", 
            "name": "Perl (IBB)"
        }, 
        "handle": "ibb-perl", 
        "url": "https://hackerone.com/ibb-perl", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/030/31b273f2caeb42494d4f7bbf1531000c771d7793_small.png?1383737333", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/030/61f6fc128a6334a8f80c75f7e7385f1842d774fe_medium.png?1383737333"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 30, 
        "default_currency": "usd"
    }, 
    "is_published": false
}