{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [
        "siddiki"
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "450.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 86022, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2015-09-01T22:57:01.569Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "Multiple so called  'type juggling' attacks. Most notably PhabricatorUser::validateCSRFToken() is 'bypassable' in certain cases.", 
    "is_member_of_team?": null, 
    "vote_count": 1, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2015-10-01T22:57:01.701Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$450", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:32:48.081Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:32:48.081Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "This requires random, non-user-controlled values to happen to generate hashes in the form `0+e\\d+`, right? If I'm doing the math right, about 1 in 64 million CSRF tokens has this form, and we cycle them every hour, so there is a 1-hour window of vulnerability in the next 7,300 years. Presumably we can compute when this window occurs, and are not vulnerable if we get everyone patched before then.\n\nThe API token effectively cycles every second, but the entire hash must match, so I think this one has millions (billions?) of years before it is vulnerable.\n\n(If no epoch input between now and 2038 produces a matching hash, we may not be vulnerable on any hardware which exists today.)\n\nDoes that sound about right? This is definitely a theoretical vulnerability and we'll fix it, but I don't _think_ a practical attack exists against it in our lifetimes. Does my math sound like it's in the right ballpark, or am I mis-assessing the practicality of this attack?\n\n", 
            "markdown_message": "<p>This requires random, non-user-controlled values to happen to generate hashes in the form <code>0+e\\d+</code>, right? If I&#39;m doing the math right, about 1 in 64 million CSRF tokens has this form, and we cycle them every hour, so there is a 1-hour window of vulnerability in the next 7,300 years. Presumably we can compute when this window occurs, and are not vulnerable if we get everyone patched before then.</p>\n\n<p>The API token effectively cycles every second, but the entire hash must match, so I think this one has millions (billions?) of years before it is vulnerable.</p>\n\n<p>(If no epoch input between now and 2038 produces a matching hash, we may not be vulnerable on any hardware which exists today.)</p>\n\n<p>Does that sound about right? This is definitely a theoretical vulnerability and we&#39;ll fix it, but I don&#39;t <u>think</u> a practical attack exists against it in our lifetimes. Does my math sound like it&#39;s in the right ballpark, or am I mis-assessing the practicality of this attack?</p>\n", 
            "type": "Activities::Comment", 
            "id": 570608, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:39:58.045Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:39:58.045Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "That sounds about right, i filed it mainly because best practices and often it is not exploitable. This issue happens a lot also with login scripts (e.g. comparing stored sha1/md5 with a user supplied value) and you're right in that case it is very hard to exploit. \n\nHowever, and i'm not completely sure if this is the case with Phabricator or not -- when the attacker can trigger the regeneration of the 'random' hash it is also considered real life exploitable, since you can just regenerate until a hash is generated that matches the 0+e\\d+. This is the case with password regeneration tokens for example (see: http://en.securitylab.ru/lab/PT-2012-29) \n", 
            "markdown_message": "<p>That sounds about right, i filed it mainly because best practices and often it is not exploitable. This issue happens a lot also with login scripts (e.g. comparing stored sha1/md5 with a user supplied value) and you&#39;re right in that case it is very hard to exploit. </p>\n\n<p>However, and i&#39;m not completely sure if this is the case with Phabricator or not -- when the attacker can trigger the regeneration of the &#39;random&#39; hash it is also considered real life exploitable, since you can just regenerate until a hash is generated that matches the 0+e\\d+. This is the case with password regeneration tokens for example (see: <a title=\"http://en.securitylab.ru/lab/PT-2012-29\" href=\"/redirect?signature=9eb6fb5a27fadeee6be8d779d5c59fc387a94906&amp;url=http%3A%2F%2Fen.securitylab.ru%2Flab%2FPT-2012-29\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://en.securitylab.ru/lab/PT-2012-29</span><i class=\"icon-external-link\"></i></a>) </p>\n", 
            "type": "Activities::Comment", 
            "id": 570616, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:45:23.959Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:45:23.959Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "As far as I can tell, it looks like these are the next 5 vulnerability windows:\n\n```\n2028-10-31 9 AM\n2040-03-11 4 PM\n2122-11-02 7 PM\n2124-06-24 9 PM\n2125-12-31 9 AM\n```\n\nSo we have about 18 years to patch the CSRF version of this, at least, before a practical attack becomes possible.", 
            "markdown_message": "<p>As far as I can tell, it looks like these are the next 5 vulnerability windows:</p>\n<pre class=\"highlight plaintext\"><code>2028-10-31 9 AM\n2040-03-11 4 PM\n2122-11-02 7 PM\n2124-06-24 9 PM\n2125-12-31 9 AM\n</code></pre>\n<p>So we have about 18 years to patch the CSRF version of this, at least, before a practical attack becomes possible.</p>\n", 
            "type": "Activities::Comment", 
            "id": 570620, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:46:21.553Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:46:21.553Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Well, 13 years, I suppose. Anyway, thanks for the report! We'll get this fixed shortly.", 
            "markdown_message": "<p>Well, 13 years, I suppose. Anyway, thanks for the report! We&#39;ll get this fixed shortly.</p>\n", 
            "type": "Activities::Comment", 
            "id": 570621, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:50:38.848Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:50:38.848Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Err, im not sure if i understand, how can you predict the outcome of the hashing function that is based on a random string? I don't think you can predict the csrf-token hashes? Arent the csrf-tokens randomly generated? (e.g. the ones of the form 0+e\\d+ will also appear randomly and not sequentally?) or are you just using statistics?", 
            "markdown_message": "<p>Err, im not sure if i understand, how can you predict the outcome of the hashing function that is based on a random string? I don&#39;t think you can predict the csrf-token hashes? Arent the csrf-tokens randomly generated? (e.g. the ones of the form 0+e\\d+ will also appear randomly and not sequentally?) or are you just using statistics?</p>\n", 
            "type": "Activities::Comment", 
            "id": 570625, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T01:56:45.109Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T01:56:45.109Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Oh, right, they're variant per user account. Those are the values for my user account, which is obviously the most important one.", 
            "markdown_message": "<p>Oh, right, they&#39;re variant per user account. Those are the values for my user account, which is obviously the most important one.</p>\n", 
            "type": "Activities::Comment", 
            "id": 570626, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:01:27.460Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:01:27.460Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Maybe, but they're variant every time a new token is generated right? Every time a new csrf-token is generated it is possibly of the form 0+e\\d+, we can't know which ones will be of that form because we cant predict sha1 outcomes. So that still makes it hard to exploit, since you'd need to perform a XSRF-request at the moment the hash happens to be of the form 0+e\\d+ but there is no way in telling beforehand when that will be. ", 
            "markdown_message": "<p>Maybe, but they&#39;re variant every time a new token is generated right? Every time a new csrf-token is generated it is possibly of the form 0+e\\d+, we can&#39;t know which ones will be of that form because we cant predict sha1 outcomes. So that still makes it hard to exploit, since you&#39;d need to perform a XSRF-request at the moment the hash happens to be of the form 0+e\\d+ but there is no way in telling beforehand when that will be. </p>\n", 
            "type": "Activities::Comment", 
            "id": 570628, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:03:59.772Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:03:59.772Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Anyways, thanks for the reply and good luck with project :) ", 
            "markdown_message": "<p>Anyways, thanks for the reply and good luck with project :) </p>\n", 
            "type": "Activities::Comment", 
            "id": 570631, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:42:38.392Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:42:38.392Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "I believe these changes will fix the issue:\n\nhttps://secure.phabricator.com/D14025\nhttps://secure.phabricator.com/D14026\n\nThey also defuse hypothetical timing attacks against these comparisons, although I currently believe these are even less practical than this juggling attack.", 
            "markdown_message": "<p>I believe these changes will fix the issue:</p>\n\n<p><a title=\"https://secure.phabricator.com/D14025\" href=\"/redirect?signature=496fd431022b7b9a6c95a2b5251a677ba776e12d&amp;url=https%3A%2F%2Fsecure.phabricator.com%2FD14025\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure.phabricator.com/D14025</span><i class=\"icon-external-link\"></i></a><br>\n<a title=\"https://secure.phabricator.com/D14026\" href=\"/redirect?signature=4000dc5faf49a9c935b96c58d820b0d8db5e3515&amp;url=https%3A%2F%2Fsecure.phabricator.com%2FD14026\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure.phabricator.com/D14026</span><i class=\"icon-external-link\"></i></a></p>\n\n<p>They also defuse hypothetical timing attacks against these comparisons, although I currently believe these are even less practical than this juggling attack.</p>\n", 
            "type": "Activities::Comment", 
            "id": 570643, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:52:08.565Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:52:08.565Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "(I'm not going to try to commit those tonight since it's getting late and I want to double check them tomorrow morning with fresh eyes, but I'll close this out then if no one spots any issues between now and then.)", 
            "markdown_message": "<p>(I&#39;m not going to try to commit those tonight since it&#39;s getting late and I want to double check them tomorrow morning with fresh eyes, but I&#39;ll close this out then if no one spots any issues between now and then.)</p>\n", 
            "type": "Activities::Comment", 
            "id": 570646, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:57:42.841Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:57:42.841Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "      array('hunter42', 'hunter42', true),\n\nthis pretty much sums it up :D", 
            "markdown_message": "<pre class=\"highlight plaintext\"><code>  array(&#39;hunter42&#39;, &#39;hunter42&#39;, true),\n</code></pre>\n<p>this pretty much sums it up :D</p>\n", 
            "type": "Activities::Comment", 
            "id": 570649, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T02:59:37.642Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T02:59:37.642Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Just to add information to the hivemind: stuff like in_array is also vulnerable unless given a third argument \n\nhttps://secure.php.net/in_array\n\nIf the third parameter strict is set to TRUE then the in_array() function will also check the types of the needle in the haystack.\n\n", 
            "markdown_message": "<p>Just to add information to the hivemind: stuff like in_array is also vulnerable unless given a third argument </p>\n\n<p><a title=\"https://secure.php.net/in_array\" href=\"/redirect?signature=896dc090118c53ed3ebe360995c15930ef5e4a03&amp;url=https%3A%2F%2Fsecure.php.net%2Fin_array\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure.php.net/in_array</span><i class=\"icon-external-link\"></i></a></p>\n\n<p>If the third parameter strict is set to TRUE then the in_array() function will also check the types of the needle in the haystack.</p>\n", 
            "type": "Activities::Comment", 
            "id": 570650, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T22:52:34.456Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T22:52:34.456Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "There's potentially one of those in the Twilio API:\n\nhttps://github.com/twilio/twilio-php/blob/master/Services/Twilio/RequestValidator.php\n\nBut I think it's not vulnerable even in theory since it uses `base64_encode()` and I think it will always end in `=`.\n\nThere's an `in_array()` in our version of the Stripe API but it doesn't do anything bad and the modern library doesn't have it.\n\nI wasn't able to find any additional suspicious callsites, but will keep an eye out.", 
            "markdown_message": "<p>There&#39;s potentially one of those in the Twilio API:</p>\n\n<p><a title=\"https://github.com/twilio/twilio-php/blob/master/Services/Twilio/RequestValidator.php\" href=\"/redirect?signature=c723cfc3c187958b04a88ba5484664f78188f5c1&amp;url=https%3A%2F%2Fgithub.com%2Ftwilio%2Ftwilio-php%2Fblob%2Fmaster%2FServices%2FTwilio%2FRequestValidator.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/twilio/twilio-php/blob/master/Services/Twilio/RequestValidator.php</span><i class=\"icon-external-link\"></i></a></p>\n\n<p>But I think it&#39;s not vulnerable even in theory since it uses <code>base64_encode()</code> and I think it will always end in <code>=</code>.</p>\n\n<p>There&#39;s an <code>in_array()</code> in our version of the Stripe API but it doesn&#39;t do anything bad and the modern library doesn&#39;t have it.</p>\n\n<p>I wasn&#39;t able to find any additional suspicious callsites, but will keep an eye out.</p>\n", 
            "type": "Activities::Comment", 
            "id": 573227, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "superkritisch", 
                "url": "/superkritisch"
            }, 
            "created_at": "2015-09-01T22:53:23.283Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T22:53:23.283Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "This should now be fixed in HEAD.", 
            "markdown_message": "<p>This should now be fixed in HEAD.</p>\n", 
            "type": "Activities::BugResolved", 
            "id": 573229, 
            "genius_execution_id": null
        }, 
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2015-09-01T22:55:30.958Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T22:55:30.958Z", 
            "actor": {
                "url": "/phabricator", 
                "profile": {
                    "name": "Phabricator"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/018/29aa105aca62b26e62c64e57c902e5db2bb8daf6_medium.jpg?1487955532"
                }
            }, 
            "team_handle": "phabricator", 
            "bounty_amount": "450.0", 
            "collaborator": {
                "username": "superkritisch", 
                "url": "/superkritisch"
            }, 
            "message": "This attack was probably not exploitable in a practical scenario on its own, but did represent a substantial reduction in entropy in core authentication code.", 
            "markdown_message": "<p>This attack was probably not exploitable in a practical scenario on its own, but did represent a substantial reduction in entropy in core authentication code.</p>\n", 
            "type": "Activities::BountyAwarded", 
            "id": 573237, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-01T22:57:01.602Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-01T22:57:01.602Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "first_to_agree": true, 
            "message": "These fixes are publicly available in the upstream, so this can be disclosed at any time.\n\nThanks again!", 
            "markdown_message": "<p>These fixes are publicly available in the upstream, so this can be disclosed at any time.</p>\n\n<p>Thanks again!</p>\n", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 573239, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-02T23:29:53.829Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-02T23:29:53.829Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "Wow! Thanks for the bounty! I really appreciate it.  \n\nGood luck with the project!", 
            "markdown_message": "<p>Wow! Thanks for the bounty! I really appreciate it.  </p>\n\n<p>Good luck with the project!</p>\n", 
            "type": "Activities::Comment", 
            "id": 575128, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-25T16:12:51.572Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-25T16:12:51.572Z", 
            "actor": {
                "username": "superkritisch", 
                "url": "/superkritisch", 
                "profile_picture_urls": {
                    "medium": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "I'm not sure if theres a button i should press to allow this to become public, so just for clarification: i don't mind if this is shared publically.", 
            "markdown_message": "<p>I&#39;m not sure if theres a button i should press to allow this to become public, so just for clarification: i don&#39;t mind if this is shared publically.</p>\n", 
            "type": "Activities::Comment", 
            "id": 598368, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-09-25T16:18:41.767Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-09-25T16:18:41.767Z", 
            "actor": {
                "username": "epriestley", 
                "url": "/epriestley", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/043/67210f4155bb8999679d01c81406df1242df0f8c_medium.jpg?1383694450"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "phabricator", 
            "message": "I think there's a button you can press somewhere to agree to immediate disclosure. It will automatically disclose after a set time period (30 days?) otherwise. Feel free to press the button if you can find it, but just waiting for a week or so will have the same effect if you can't.\n\n(Beyond the project commit history we also already disclosed this in the Sep 5 changelog -- https://secure.phabricator.com/w/changelog/2015.36/ -- so the schedule of the disclosure here isn't too important.)", 
            "markdown_message": "<p>I think there&#39;s a button you can press somewhere to agree to immediate disclosure. It will automatically disclose after a set time period (30 days?) otherwise. Feel free to press the button if you can find it, but just waiting for a week or so will have the same effect if you can&#39;t.</p>\n\n<p>(Beyond the project commit history we also already disclosed this in the Sep 5 changelog -- <a title=\"https://secure.phabricator.com/w/changelog/2015.36/\" href=\"/redirect?signature=d82fede445bdd0ec543bf56fa991c9ba89f53386&amp;url=https%3A%2F%2Fsecure.phabricator.com%2Fw%2Fchangelog%2F2015.36%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure.phabricator.com/w/changelog/2015.36/</span><i class=\"icon-external-link\"></i></a> -- so the schedule of the disclosure here isn&#39;t too important.)</p>\n", 
            "type": "Activities::Comment", 
            "id": 598383, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2015-10-01T22:57:15.688Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-10-01T22:57:15.688Z", 
            "actor": {
                "url": "/phabricator", 
                "profile": {
                    "name": "Phabricator"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/018/29aa105aca62b26e62c64e57c902e5db2bb8daf6_medium.jpg?1487955532"
                }
            }, 
            "team_handle": "phabricator", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 605892, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "superkritisch", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/superkritisch", 
        "profile_picture_urls": {
            "small": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 45, 
        "name": "Cross-Site Request Forgery (CSRF)"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -100396910.7849058, 
    "disclosed_at": "2015-10-01T22:57:15.654Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/86022", 
    "created_at": "2015-09-01T01:08:56.393Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>/* MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */</p>\n\n<p>The Phabricator code base is at various places vulnerable for so called <br>\n&#39;type juggling&#39; <a title=\"1\" href=\"/redirect?signature=38344ba1b8db38dcd3ff589bcdea8dbe517c79df&amp;url=http%3A%2F%2Fturbochaos.blogspot.nl%2F2013%2F08%2Fexploiting-exotic-bugs-php-type-juggling.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>1</span><i class=\"icon-external-link\"></i></a> attacks. Most notably PhabricatorUser::validateCSRFToken()<br>\nis &#39;bypassable&#39; in certain cases.  </p>\n\n<h2 id=\"type-juggling\">Type Juggling</h2>\n\n<p>Since PHP&#39;s loose type comparison operators compare only data values but not <br>\ntheir associated types, deriving variable types from context. PHP&#39;s string <br>\nconversion rules <a title=\"2\" href=\"/redirect?signature=9d7af628ad5c4829f819e11c736d0fb7f93da0da&amp;url=http%3A%2F%2Fphp.net%2Fmanual%2Fen%2Flanguage.types.string.php%23language.types.string.conversion\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>2</span><i class=\"icon-external-link\"></i></a> specify strings (when evaluated in a numeric context) with <br>\nleading decimal, hexadecimal, infinity, NAN or radix (a &#39;.&#39;) data optionally<br>\nfollowed by an exponent are evaluated as floats. </p>\n\n<p>What this means is that a string like 00e13242 is cast to 0 and as such, to PHP <br>\n0e94323 == 00e19384. </p>\n\n<p>Translated into code, this means that the following comparison:</p>\n<pre class=\"highlight plaintext\"><code>(hash($randomSecret) == $user_input)\n</code></pre>\n<p>will return true if hash($randomSecret) returns a hash in the form 0+[eE]\\d+ and<br>\nthe $user_input is given as &quot;0&quot;. This applies to various hashing algorithms, <br>\nincluding (but not limited to) MD5 and SHA1. If you&#39;re not convinced, try <br>\nrunning the PHP-code at the bottom of this text for a PoC with SHA1.</p>\n\n<h2 id=\"how-this-applies-to-phabricator\">How this applies to Phabricator</h2>\n\n<p>In order to understand how this applies to Phabricator, we need to first know <br>\nthat static method PhabricatorHash::digest() located at <br>\nsrc/infrastructure/util/PhabricatorHash.php <a title=\"3\" href=\"/redirect?signature=2e2aa1bf3f70a21060deb8f7cadf280e2de82fea&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Finfrastructure%2Futil%2FPhabricatorHash.php%23L25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>3</span><i class=\"icon-external-link\"></i></a> on line 25 returns a sha1 hash<br>\nvia hash_hmac();</p>\n\n<p>Then we need to know that in AphrontRequest::validateCSRF();<a title=\"4\" href=\"/redirect?signature=bb8f2a01340e46051c0e7c9f9e44e81e5ce21e83&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Faphront%2FAphrontRequest.php%23L249\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>4</span><i class=\"icon-external-link\"></i></a> the static function<br>\nPhabricatorUser::validateCSRFToken($token); is called with a user-supplied <br>\n$token.</p>\n\n<p>Now, if we look at PhabricatorUser::validateCSRFToken() located at <br>\nphabricator/src/applications/people/storage/PhabricatorUser.php <a title=\"5\" href=\"/redirect?signature=15c7c4e1b4a3a16d5e25e3027362dd87dadfbd03&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Fapplications%2Fpeople%2Fstorage%2FPhabricatorUser.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>5</span><i class=\"icon-external-link\"></i></a>, on line 409<br>\nwe see that getRawCSRFToken (which also returns a sha1 hash) is called and it&#39;s <br>\nreturn value is stored in $valid </p>\n<pre class=\"highlight plaintext\"><code>$valid = $this-&gt;getRawCSRFToken($ii);\n</code></pre>\n<p>then on line 412 we see:</p>\n<pre class=\"highlight plaintext\"><code>if ($token == $valid) {\n</code></pre>\n<p>or, if the $version is &#39;breach&#39; we reach this code on line 419-420:</p>\n<pre class=\"highlight plaintext\"><code>$digest = PhabricatorHash::digest($valid, $salt);\nif (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\n</code></pre>\n<p>Both these comparisons meets the criteria for type juggling. Since $valid is a <br>\nrandomly generated sha1 hash which eventually will be of the form 0+[eE]\\d+ <br>\nafter sufficient regenerations and the same goes for $digest. In addition, <br>\n$token is a user-supplied value. </p>\n\n<h2 id=\"tl-dr\">TL;DR</h2>\n\n<p>So in short, some expected CSRF-tokens will equal a user-supplied CSRF-token <br>\ncontaining &quot;0&quot;. In essence this is a reduction in entropy of the CSRF-tokens.</p>\n\n<p>to stop PHP from automatically casting either value to another type during <br>\ncomparison, simply change: </p>\n<pre class=\"highlight plaintext\"><code>if ($token == $valid) {\n</code></pre>\n<p>to</p>\n<pre class=\"highlight plaintext\"><code>if ($token === $valid) {\n</code></pre>\n<p>And likewise:</p>\n<pre class=\"highlight plaintext\"><code>if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\n</code></pre>\n<p>to</p>\n<pre class=\"highlight plaintext\"><code>if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) === $token) {\n</code></pre>\n<p>In addition to the above vulnerability, there are other notable misuses of PHP <br>\ncomparison operators. </p>\n\n<p>phabricator/src/applications/conduit/method/ConduitConnectConduitAPIMethod.php:144<br>\nin protected function execute(ConduitAPIRequest $request) <a title=\"6\" href=\"/redirect?signature=ca7fb0c2b46a176fdd67e8cf92181519997a21c9&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2F%2Fsrc%2Fapplications%2Fconduit%2Fmethod%2FConduitConnectConduitAPIMethod.php%23L145\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>6</span><i class=\"icon-external-link\"></i></a>:</p>\n<pre class=\"highlight plaintext\"><code>    $valid = sha1($token.$user-&gt;getConduitCertificate());\n    if ($valid != $signature) { \n        throw new ConduitException(&#39;ERR-INVALID-CERTIFICATE&#39;);\n</code></pre>\n<p>The != operator is not type strict and $signature is user-specified. $token is <br>\nalso user-specified. To fix this != should be changed to !==.</p>\n\n<p>phabricator/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php<br>\nin verifyMessage() on line 15 and 16 <a title=\"7\" href=\"/redirect?signature=03b6f7e8d60d3953fd09aae1a3f2d5e1f45c4f49&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Fapplications%2Fmetamta%2Fcontroller%2FPhabricatorMetaMTAMailgunReceiveController.php%23L15\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>7</span><i class=\"icon-external-link\"></i></a>:</p>\n<pre class=\"highlight plaintext\"><code>$sig = $request-&gt;getStr(&#39;signature&#39;);\nreturn hash_hmac(&#39;sha256&#39;, $timestamp.$token, $api_key) == $sig\n</code></pre>\n<p>Where $sig is obviously a user-supplied value and can thus be 0, and again the <br>\nreturn value of hash_hmac can be of the form 0+[eE]\\d+. </p>\n\n<p>To fix this, change:<br>\n    hash_hmac(&#39;sha256&#39;, $timestamp.$token, $api_key) == $sig</p>\n\n<p>to:<br>\n    hash_hmac(&#39;sha256&#39;, $timestamp.$token, $api_key) === $sig</p>\n\n<h2 id=\"examples\">Examples:</h2>\n\n<ul>\n<li>\n<p>type juggling with sha1<a title=\"8\" href=\"/redirect?signature=637cc9c4ba7173e4b88e23cf0f8f4d767f7ff760&amp;url=https%3A%2F%2Fpen-testing.sans.org%2Fblog%2Fpen-testing%2F2014%2F12%2F18%2Fphp-weak-typing-woes-with-some-pontification-about-code-and-pen-testing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>8</span><i class=\"icon-external-link\"></i></a></p>\n\n<p>&lt;?php<br>\n/* sha1 type juggling PoC values */<br>\n$v1 = sha1(&quot;AAJd1x3j&quot;);<br>\n$v2 = sha1(&quot;AAPkbYlH&quot;);<br>\n$v3 = sha1(&quot;AAZlIwOZ&quot;);</p>\n\n<p>var_dump($v1, $v2, $v3);<br>\n/* wrong way to compare these hashes */<br>\nvar_dump( $v1 == $v2, $v2 == $v3, $v3 == $v1, $v1 == &quot;0&quot;);</p>\n\n<p>/* correct way */<br>\nvar_dump( $v1 === $v2, $v2 === $v3, $v3 === $v1 );<br>\n?&gt;</p>\n</li>\n</ul>\n\n<p>The above will output:</p>\n<pre class=\"highlight plaintext\"><code>string(40) &quot;00e6811279456694288001763399976992804485&quot;\nstring(40) &quot;0e51223820731210116366152413868569204545&quot;\nstring(40) &quot;0e13965443605273185827757762777509208778&quot;\nbool(true)  \nbool(true)\nbool(true)\nbool(true)\nbool(false)\nbool(false)\nbool(false)\n</code></pre>\n<h2 id=\"references\">References:</h2>\n\n<ol>\n<li><a title=\"http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html\" href=\"/redirect?signature=38344ba1b8db38dcd3ff589bcdea8dbe517c79df&amp;url=http%3A%2F%2Fturbochaos.blogspot.nl%2F2013%2F08%2Fexploiting-exotic-bugs-php-type-juggling.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"http://php.net/manual/en/language.types.string.php#language.types.string.conversion\" href=\"/redirect?signature=9d7af628ad5c4829f819e11c736d0fb7f93da0da&amp;url=http%3A%2F%2Fphp.net%2Fmanual%2Fen%2Flanguage.types.string.php%23language.types.string.conversion\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://php.net/manual/en/language.types.string.php#language.types.string.conversion</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25\" href=\"/redirect?signature=2e2aa1bf3f70a21060deb8f7cadf280e2de82fea&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Finfrastructure%2Futil%2FPhabricatorHash.php%23L25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249\" href=\"/redirect?signature=bb8f2a01340e46051c0e7c9f9e44e81e5ce21e83&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Faphront%2FAphrontRequest.php%23L249\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php\" href=\"/redirect?signature=15c7c4e1b4a3a16d5e25e3027362dd87dadfbd03&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Fapplications%2Fpeople%2Fstorage%2FPhabricatorUser.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145\" href=\"/redirect?signature=ca7fb0c2b46a176fdd67e8cf92181519997a21c9&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2F%2Fsrc%2Fapplications%2Fconduit%2Fmethod%2FConduitConnectConduitAPIMethod.php%23L145\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15\" href=\"/redirect?signature=03b6f7e8d60d3953fd09aae1a3f2d5e1f45c4f49&amp;url=https%3A%2F%2Fgithub.com%2Fphacility%2Fphabricator%2Fblob%2Fmaster%2Fsrc%2Fapplications%2Fmetamta%2Fcontroller%2FPhabricatorMetaMTAMailgunReceiveController.php%23L15\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15</span><i class=\"icon-external-link\"></i></a></li>\n<li><a title=\"https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing\" href=\"/redirect?signature=637cc9c4ba7173e4b88e23cf0f8f4d767f7ff760&amp;url=https%3A%2F%2Fpen-testing.sans.org%2Fblog%2Fpen-testing%2F2014%2F12%2F18%2Fphp-weak-typing-woes-with-some-pontification-about-code-and-pen-testing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing</span><i class=\"icon-external-link\"></i></a></li>\n</ol>\n\n<p>/*END MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */</p>\n", 
    "vulnerability_information": "/* MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */\r\n\r\nThe Phabricator code base is at various places vulnerable for so called \r\n'type juggling' [1] attacks. Most notably PhabricatorUser::validateCSRFToken()\r\nis 'bypassable' in certain cases.  \r\n\r\n\r\n##Type Juggling\r\nSince PHP's loose type comparison operators compare only data values but not \r\ntheir associated types, deriving variable types from context. PHP's string \r\nconversion rules [2] specify strings (when evaluated in a numeric context) with \r\nleading decimal, hexadecimal, infinity, NAN or radix (a '.') data optionally\r\nfollowed by an exponent are evaluated as floats. \r\n\r\nWhat this means is that a string like 00e13242 is cast to 0 and as such, to PHP \r\n0e94323 == 00e19384. \r\n\r\nTranslated into code, this means that the following comparison:\r\n\r\n    (hash($randomSecret) == $user_input)\r\n\r\nwill return true if hash($randomSecret) returns a hash in the form 0+[eE]\\d+ and\r\nthe $user_input is given as \"0\". This applies to various hashing algorithms, \r\nincluding (but not limited to) MD5 and SHA1. If you're not convinced, try \r\nrunning the PHP-code at the bottom of this text for a PoC with SHA1.\r\n\r\n\r\n##How this applies to Phabricator\r\nIn order to understand how this applies to Phabricator, we need to first know \r\nthat static method PhabricatorHash::digest() located at \r\nsrc/infrastructure/util/PhabricatorHash.php [3] on line 25 returns a sha1 hash\r\nvia hash_hmac();\r\n\r\nThen we need to know that in AphrontRequest::validateCSRF();[4] the static function\r\nPhabricatorUser::validateCSRFToken($token); is called with a user-supplied \r\n$token.\r\n\r\nNow, if we look at PhabricatorUser::validateCSRFToken() located at \r\nphabricator/src/applications/people/storage/PhabricatorUser.php [5], on line 409\r\nwe see that getRawCSRFToken (which also returns a sha1 hash) is called and it's \r\nreturn value is stored in $valid \r\n\r\n    $valid = $this->getRawCSRFToken($ii);\r\n\r\nthen on line 412 we see:\r\n\r\n    if ($token == $valid) {\r\n\r\nor, if the $version is 'breach' we reach this code on line 419-420:\r\n\r\n    $digest = PhabricatorHash::digest($valid, $salt);\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\r\n\r\nBoth these comparisons meets the criteria for type juggling. Since $valid is a \r\nrandomly generated sha1 hash which eventually will be of the form 0+[eE]\\d+ \r\nafter sufficient regenerations and the same goes for $digest. In addition, \r\n$token is a user-supplied value. \r\n\r\n##TL;DR\r\nSo in short, some expected CSRF-tokens will equal a user-supplied CSRF-token \r\ncontaining \"0\". In essence this is a reduction in entropy of the CSRF-tokens.\r\n\r\nto stop PHP from automatically casting either value to another type during \r\ncomparison, simply change: \r\n\r\n    if ($token == $valid) {\r\n\r\nto\r\n\r\n    if ($token === $valid) {\r\n\r\nAnd likewise:\r\n\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\r\n\r\nto\r\n\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) === $token) {\r\n\r\n\r\n\r\nIn addition to the above vulnerability, there are other notable misuses of PHP \r\ncomparison operators. \r\n\r\nphabricator/src/applications/conduit/method/ConduitConnectConduitAPIMethod.php:144\r\nin protected function execute(ConduitAPIRequest $request) [6]:\r\n        \r\n        $valid = sha1($token.$user->getConduitCertificate());\r\n        if ($valid != $signature) { \r\n            throw new ConduitException('ERR-INVALID-CERTIFICATE');\r\n\r\nThe != operator is not type strict and $signature is user-specified. $token is \r\nalso user-specified. To fix this != should be changed to !==.\r\n\r\n\r\nphabricator/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php\r\nin verifyMessage() on line 15 and 16 [7]:\r\n\r\n    $sig = $request->getStr('signature');\r\n    return hash_hmac('sha256', $timestamp.$token, $api_key) == $sig\r\n\r\nWhere $sig is obviously a user-supplied value and can thus be 0, and again the \r\nreturn value of hash_hmac can be of the form 0+[eE]\\d+. \r\n\r\nTo fix this, change:\r\n    hash_hmac('sha256', $timestamp.$token, $api_key) == $sig\r\n\r\nto:\r\n    hash_hmac('sha256', $timestamp.$token, $api_key) === $sig\r\n\r\n\r\n\r\n##Examples:\r\n\r\n- type juggling with sha1[8]\r\n\r\n    <?php\r\n    /* sha1 type juggling PoC values */\r\n    $v1 = sha1(\"AAJd1x3j\");\r\n    $v2 = sha1(\"AAPkbYlH\");\r\n    $v3 = sha1(\"AAZlIwOZ\");\r\n\r\n    var_dump($v1, $v2, $v3);\r\n    /* wrong way to compare these hashes */\r\n    var_dump( $v1 == $v2, $v2 == $v3, $v3 == $v1, $v1 == \"0\");\r\n\r\n    /* correct way */\r\n    var_dump( $v1 === $v2, $v2 === $v3, $v3 === $v1 );\r\n    ?>\r\n\r\n\r\n\r\nThe above will output:\r\n\r\n    string(40) \"00e6811279456694288001763399976992804485\"\r\n    string(40) \"0e51223820731210116366152413868569204545\"\r\n    string(40) \"0e13965443605273185827757762777509208778\"\r\n    bool(true)  \r\n    bool(true)\r\n    bool(true)\r\n    bool(true)\r\n    bool(false)\r\n    bool(false)\r\n    bool(false)\r\n\r\n\r\n##References:\r\n1. http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html\r\n2. http://php.net/manual/en/language.types.string.php#language.types.string.conversion\r\n3. https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25\r\n4. https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249\r\n5. https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php\r\n6. https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145\r\n7. https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15\r\n8. https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing\r\n\r\n[1]: http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html \"1\"\r\n[2]: http://php.net/manual/en/language.types.string.php#language.types.string.conversion \"2\"\r\n[3]: https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25 \"3\"\r\n[4]: https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249 \"4\"\r\n[5]: https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php \"5\"\r\n[6]: https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145 \"6\"\r\n[7]: https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15 \"7\"\r\n[8]: https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing \"8\"\r\n\r\n\r\n\r\n\r\n/*END MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "http://phacility.com/phabricator/", 
            "about": "Phabricator is a collection of open source web applications that help software companies build better software.", 
            "twitter_handle": "phabricator", 
            "name": "Phabricator"
        }, 
        "handle": "phabricator", 
        "url": "https://hackerone.com/phabricator", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/018/8f0130b0439b00cdeeddd76246ec8063cac6495f_small.jpg?1487955532", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/018/29aa105aca62b26e62c64e57c902e5db2bb8daf6_medium.jpg?1487955532"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 18, 
        "default_currency": "usd"
    }, 
    "is_published": false
}