{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": "2016-06-17T23:49:48.746Z", 
    "voters": [
        "lukasreschke", 
        "mdv", 
        "guido", 
        "temmyscript", 
        "kaito", 
        "zawad", 
        "mogyhacker", 
        "martijn", 
        "zeroknife", 
        "dyabla", 
        "and 3 more..."
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 144482, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2016-06-21T00:56:27.877Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "StringIO strio_getline() can divulge arbitrary memory", 
    "is_member_of_team?": null, 
    "vote_count": 13, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": "2016-07-17T23:49:48.859Z", 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$500", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "created_at": "2016-06-13T23:56:57.613Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-13T23:56:57.613Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "We couldn't reproduce this bug with the PoC code, but confirmed the case.\nThe assumption doesn't seem a common case, but we don't assert it is impossible.\n\nWe are discussing how to handle this issue.", 
            "markdown_message": "<p>We couldn&#39;t reproduce this bug with the PoC code, but confirmed the case.<br>\nThe assumption doesn&#39;t seem a common case, but we don&#39;t assert it is impossible.</p>\n\n<p>We are discussing how to handle this issue.</p>\n", 
            "type": "Activities::Comment", 
            "id": 1012197, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-16T07:06:23.899Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-16T07:06:23.899Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "We reproduced the problem on 32bit box, but will not provide emergency releases for this issue because the assumption in your report is not impossible but unlikely in real-world applications.\n\nThe following fix will be included in the next releases of 2.2, 2.3, and 2.4:\n\n```\ndiff --git a/ext/stringio/stringio.c b/ext/stringio/stringio.c\nindex 4fdc4df..f35c702 100644\n--- a/ext/stringio/stringio.c\n+++ b/ext/stringio/stringio.c\n@@ -1021,7 +1021,7 @@ strio_getline(int argc, VALUE *argv, struct StringIO *ptr)\n     s = RSTRING_PTR(ptr->string);\n     e = s + RSTRING_LEN(ptr->string);\n     s += ptr->pos;\n-    if (limit > 0 && s + limit < e) {\n+    if (limit > 0 && (size_t)limit < (size_t)(e - s)) {\n    e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n     }\n     if (NIL_P(str)) {\n```\n\nThank you for your cooperation.", 
            "markdown_message": "<p>We reproduced the problem on 32bit box, but will not provide emergency releases for this issue because the assumption in your report is not impossible but unlikely in real-world applications.</p>\n\n<p>The following fix will be included in the next releases of 2.2, 2.3, and 2.4:</p>\n<pre class=\"highlight diff\"><code><span class=\"gh\">diff --git a/ext/stringio/stringio.c b/ext/stringio/stringio.c\nindex 4fdc4df..f35c702 100644\n</span><span class=\"gd\">--- a/ext/stringio/stringio.c\n</span><span class=\"gi\">+++ b/ext/stringio/stringio.c\n</span><span class=\"gu\">@@ -1021,7 +1021,7 @@ strio_getline(int argc, VALUE *argv, struct StringIO *ptr)\n</span>     s = RSTRING_PTR(ptr-&gt;string);\n     e = s + RSTRING_LEN(ptr-&gt;string);\n     s += ptr-&gt;pos;\n<span class=\"gd\">-    if (limit &gt; 0 &amp;&amp; s + limit &lt; e) {\n</span><span class=\"gi\">+    if (limit &gt; 0 &amp;&amp; (size_t)limit &lt; (size_t)(e - s)) {\n</span>    e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n     }\n     if (NIL_P(str)) {\n</code></pre>\n<p>Thank you for your cooperation.</p>\n", 
            "type": "Activities::Comment", 
            "id": 1016514, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-16T11:48:37.922Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-16T11:48:37.922Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "Okay. I guess you can close this one as resolved then.", 
            "markdown_message": "<p>Okay. I guess you can close this one as resolved then.</p>\n", 
            "type": "Activities::Comment", 
            "id": 1017098, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "guido", 
                "url": "/guido"
            }, 
            "created_at": "2016-06-16T14:47:44.807Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-16T14:47:44.807Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "@guido Done. Thank you. ", 
            "markdown_message": "<p><a href=\"/guido\">@guido</a> Done. Thank you. </p>\n", 
            "type": "Activities::BugResolved", 
            "id": 1017372, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-16T21:33:29.791Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-16T21:33:29.791Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "Is there an embargo on this, ie. should I refrain from talking about this publicly?", 
            "markdown_message": "<p>Is there an embargo on this, ie. should I refrain from talking about this publicly?</p>\n", 
            "type": "Activities::Comment", 
            "id": 1018114, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-17T02:24:31.050Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-17T02:24:31.050Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "> Is there an embargo on this, ie. should I refrain from talking about this publicly?\n\nNo, feel free to talk about it publicly.\n\nFYI, the fix is not committed yet, because the following test passes without the fix:\n\n```\ndiff --git a/test/stringio/test_stringio.rb b/test/stringio/test_stringio.rb\nindex bf3a9ee..e4974cb 100644\n--- a/test/stringio/test_stringio.rb\n+++ b/test/stringio/test_stringio.rb\n@@ -680,4 +680,11 @@\n       StringIO.new {}\n     end\n   end\n+\n+  def test_overflow\n+    limit = (1 << (RbConfig::SIZEOF[\"size_t\"]*8-1)) - 0x10\n+    s = StringIO.new(\"abc\\n\")\n+    s.gets(\"xxx\", limit)\n+    assert_equal(4, s.pos)\n+  end\n end\n```\n\nDo you have any suggestion?\n", 
            "markdown_message": "<blockquote>\n<p>Is there an embargo on this, ie. should I refrain from talking about this publicly?</p>\n</blockquote>\n\n<p>No, feel free to talk about it publicly.</p>\n\n<p>FYI, the fix is not committed yet, because the following test passes without the fix:</p>\n<pre class=\"highlight diff\"><code><span class=\"gh\">diff --git a/test/stringio/test_stringio.rb b/test/stringio/test_stringio.rb\nindex bf3a9ee..e4974cb 100644\n</span><span class=\"gd\">--- a/test/stringio/test_stringio.rb\n</span><span class=\"gi\">+++ b/test/stringio/test_stringio.rb\n</span><span class=\"gu\">@@ -680,4 +680,11 @@\n</span>       StringIO.new {}\n     end\n   end\n<span class=\"gi\">+\n+  def test_overflow\n+    limit = (1 &lt;&lt; (RbConfig::SIZEOF[&quot;size_t&quot;]*8-1)) - 0x10\n+    s = StringIO.new(&quot;abc\\n&quot;)\n+    s.gets(&quot;xxx&quot;, limit)\n+    assert_equal(4, s.pos)\n+  end\n</span> end\n</code></pre>\n<p>Do you have any suggestion?</p>\n", 
            "type": "Activities::Comment", 
            "id": 1018425, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-17T11:45:10.616Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-17T11:45:10.616Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "I haven't tried your test but the reason that any test you'll make for this can always fail is because:\n\n```c\n     if (limit > 0 && s + limit < e) {\n```\n\nIf ```s``` is a pointer whose virtual address is below 0x80000000, then ```s + limit < e``` will work as expected, because ```s + 0x80000000``` does not overflow the register on 32 bit.\n\nSay ```s``` is ```0x70000000``` and ```e``` is 0x70001000```, and ```limit``` is ```0x7FFFFFF0```.  So you will get:\n\n```c\n     if 0x7FFFFFF0 > 0 && 0x70000000 + 0x7FFFFFF0 < 0x70001000  ) {\n```\n\nBecause ```0x70000000 + 0x7FFFFFF0``` does NOT overflow but rather computes to the correct value ```0xEFFFFFF0```, the code works as expected: ```0xEFFFFFF0``` is NOT lower than ```0x70001000``` so the code within the curly braces ```{}``` will not get executed.\n\nCompare this to a scenario where ```s``` is ```0x8000000F``` or higher.\nFor example:\n\n```s == 0x90000000```\n```e == 0x90001000```\n```limit == 0x7FFFFFF0```\n\n```s + limit < e```` evaluates to\n```0x90000000 + 0x7FFFFFF0 < 0x90001000``` which evaluates to\n```0x0FFFFFF0 < 0x90001000``` which evaluates as true, thus the code within the curly braces ```{}``` will be executed. This is the actual culprit in the vulnerability.\n\nSince there is no way to influence at which virtual addresses ```malloc()```  puts allocates blocks, and as far as I know you cannot set the ```limit``` (the second parameter to ```gets()```) to something like ```0xFFFFFFFF``` (this would 100% ensure the vulnerability to trigger), it is not possible to design a fully reliable test.", 
            "markdown_message": "<p>I haven&#39;t tried your test but the reason that any test you&#39;ll make for this can always fail is because:</p>\n<pre class=\"highlight c\"><code>     <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">limit</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">limit</span> <span class=\"o\">&lt;</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n</code></pre>\n<p>If <code>s</code> is a pointer whose virtual address is below 0x80000000, then <code>s + limit &lt; e</code> will work as expected, because <code>s + 0x80000000</code> does not overflow the register on 32 bit.</p>\n\n<p>Say <code>s</code> is <code>0x70000000</code> and <code>e</code> is 0x70001000<code>, and</code>limit<code>is</code>0x7FFFFFF0```.  So you will get:</p>\n<pre class=\"highlight c\"><code>     <span class=\"k\">if</span> <span class=\"mh\">0x7FFFFFF0</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mh\">0x70000000</span> <span class=\"o\">+</span> <span class=\"mh\">0x7FFFFFF0</span> <span class=\"o\">&lt;</span> <span class=\"mh\">0x70001000</span>  <span class=\"p\">)</span> <span class=\"p\">{</span>\n</code></pre>\n<p>Because <code>0x70000000 + 0x7FFFFFF0</code> does NOT overflow but rather computes to the correct value <code>0xEFFFFFF0</code>, the code works as expected: <code>0xEFFFFFF0</code> is NOT lower than <code>0x70001000</code> so the code within the curly braces <code>{}</code> will not get executed.</p>\n\n<p>Compare this to a scenario where <code>s</code> is <code>0x8000000F</code> or higher.<br>\nFor example:</p>\n\n<p><code>s == 0x90000000</code><br>\n<code>e == 0x90001000</code><br>\n<code>limit == 0x7FFFFFF0</code></p>\n\n<p><code>s + limit &lt; e</code><code>evaluates to<br>\n</code><code>0x90000000 + 0x7FFFFFF0 &lt; 0x90001000</code><code>which evaluates to<br>\n</code><code>0x0FFFFFF0 &lt; 0x90001000</code><code>which evaluates as true, thus the code within the curly braces</code><code>{}</code>` will be executed. This is the actual culprit in the vulnerability.</p>\n\n<p>Since there is no way to influence at which virtual addresses <code>malloc()</code>  puts allocates blocks, and as far as I know you cannot set the <code>limit</code> (the second parameter to <code>gets()</code>) to something like <code>0xFFFFFFFF</code> (this would 100% ensure the vulnerability to trigger), it is not possible to design a fully reliable test.</p>\n", 
            "type": "Activities::Comment", 
            "id": 1018917, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-17T23:49:48.786Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-17T23:49:48.786Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "first_to_agree": true, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 1020460, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-18T01:02:55.957Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-18T01:02:55.957Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "@guido \nThanks for your advice.\n\nRunning a different Ruby process from a test also doesn't reproduce the problem, so we've just merged it.", 
            "markdown_message": "<p><a href=\"/guido\">@guido</a> <br>\nThanks for your advice.</p>\n\n<p>Running a different Ruby process from a test also doesn&#39;t reproduce the problem, so we&#39;ve just merged it.</p>\n", 
            "type": "Activities::Comment", 
            "id": 1020531, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-21T00:56:27.922Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-21T00:56:27.922Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::AgreedOnGoingPublic", 
            "id": 1025850, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-21T00:56:33.542Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-21T00:56:33.542Z", 
            "actor": {
                "username": "shugo", 
                "url": "/shugo", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/076/177/f64d7a369fcf4f7abe5e9bb6fdf66be75d94bedd_medium.jpg?1465358284"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::ReportBecamePublic", 
            "id": 1025851, 
            "genius_execution_id": null
        }, 
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2016-06-22T13:28:19.650Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-22T13:28:19.650Z", 
            "actor": {
                "url": "/ruby", 
                "profile": {
                    "name": "Ruby"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/007/724/0c1556227f51c9b2b13ada11ccd2fb02cc9fa257_medium.png?1449271894"
                }
            }, 
            "team_handle": "ruby", 
            "bounty_amount": "500.0", 
            "collaborator": {
                "username": "guido", 
                "url": "/guido"
            }, 
            "message": "We're assessing the minimum bounty here given the complexity and number of constraints involved in achieving exploitation on most production systems. Thanks for the detailed description as always @guido! ", 
            "markdown_message": "<p>We&#39;re assessing the minimum bounty here given the complexity and number of constraints involved in achieving exploitation on most production systems. Thanks for the detailed description as always <a href=\"/guido\">@guido</a>! </p>\n", 
            "type": "Activities::BountyAwarded", 
            "id": 1028246, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "created_at": "2016-06-22T13:34:12.609Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-06-22T13:34:12.609Z", 
            "actor": {
                "username": "guido", 
                "url": "/guido", 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/002/983/055f2e31c3b25e230eeb37461df974006ba7b0bd_medium.jpg?1403536399"
                }, 
                "hackerone_triager": false
            }, 
            "team_handle": "ruby", 
            "message": "Thanks!", 
            "markdown_message": "<p>Thanks!</p>\n", 
            "type": "Activities::Comment", 
            "id": 1028254, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "singular_disclosure_allowed": true, 
    "reporter": {
        "username": "guido", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/guido", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/002/983/bc1fffcbbb736a8fa94816a1961b7b76725881eb_small.jpg?1403536399"
        }, 
        "is_me?": false
    }, 
    "weakness": {
        "id": 2, 
        "name": "Memory Corruption - Generic"
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "allow_singular_disclosure_after": -75337370.11799869, 
    "disclosed_at": "2016-06-21T00:56:33.515Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/144482", 
    "created_at": "2016-06-13T14:39:10.077Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>(originally send by e-mail on 4 Jun 2016)</p>\n\n<p>The problem is this line in ext/stringio/stringio.c strio_getline():</p>\n<pre class=\"highlight c\"><code><span class=\"mi\">1002</span>     <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">limit</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">limit</span> <span class=\"o\">&lt;</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"mi\">1003</span>     <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">rb_enc_right_char_head</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">limit</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">get_enc</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">));</span>\n<span class=\"mi\">1004</span>     <span class=\"p\">}</span>\n</code></pre>\n<p>This works as intended as long as the sum of s (pointer) and limit<br>\n(long) doesn&#39;t overflow. So if on a 32 bit system &#39;s&#39; happens to be<br>\n0xBF000000, and limit is 0x7FFFFFFF, the sum of both values is<br>\n0x3EFFFFFF, which is a completely unrelated address. From there, there<br>\nare several paths to be chosen from based on what the first parameter to<br>\nthe function is (&#39;str&#39;).</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1005</span>      <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">NIL_P</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"p\">...</span>\n            <span class=\"p\">...</span>\n  <span class=\"mi\">1008</span>      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">RSTRING_LEN</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"p\">...</span>\n            <span class=\"p\">...</span>\n  <span class=\"mi\">1024</span>      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"p\">...</span>\n            <span class=\"p\">...</span>\n  <span class=\"mi\">1030</span>      <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"p\">...</span>\n            <span class=\"p\">...</span>\n</code></pre>\n<p>All these paths eventually call strio_substr(). A wrong &#39;pos&#39; parameter<br>\nto this function is not possible because it was checked earlier:</p>\n<pre class=\"highlight c\"><code>   <span class=\"mi\">996</span>      <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">pos</span> <span class=\"o\">&gt;=</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">RSTRING_LEN</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">string</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n   <span class=\"mi\">997</span>      <span class=\"k\">return</span> <span class=\"n\">Qnil</span><span class=\"p\">;</span>\n   <span class=\"mi\">998</span>      <span class=\"p\">}</span>\n</code></pre>\n<p>a wrong &#39;len&#39; parameter to this function doesn&#39;t matter as it will<br>\ncorrect it itself:</p>\n<pre class=\"highlight c\"><code>    <span class=\"mi\">98</span>  <span class=\"k\">static</span> <span class=\"n\">VALUE</span>\n    <span class=\"mi\">99</span>  <span class=\"n\">strio_substr</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">StringIO</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">,</span> <span class=\"kt\">long</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"kt\">long</span> <span class=\"n\">len</span><span class=\"p\">)</span>\n   <span class=\"mi\">100</span>  <span class=\"p\">{</span>\n   <span class=\"mi\">101</span>      <span class=\"n\">VALUE</span> <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">string</span><span class=\"p\">;</span>\n   <span class=\"mi\">102</span>      <span class=\"n\">rb_encoding</span> <span class=\"o\">*</span><span class=\"n\">enc</span> <span class=\"o\">=</span> <span class=\"n\">get_enc</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span>\n   <span class=\"mi\">103</span>      <span class=\"kt\">long</span> <span class=\"n\">rlen</span> <span class=\"o\">=</span> <span class=\"n\">RSTRING_LEN</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">pos</span><span class=\"p\">;</span>\n   <span class=\"mi\">104</span>  \n   <span class=\"mi\">105</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"o\">&gt;</span> <span class=\"n\">rlen</span><span class=\"p\">)</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">rlen</span><span class=\"p\">;</span>\n   <span class=\"mi\">106</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n   <span class=\"mi\">107</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">rb_str_new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n   <span class=\"mi\">108</span>      <span class=\"k\">return</span> <span class=\"n\">rb_enc_str_new</span><span class=\"p\">(</span><span class=\"n\">RSTRING_PTR</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">,</span> <span class=\"n\">enc</span><span class=\"p\">);</span>\n   <span class=\"mi\">109</span>  <span class=\"p\">}</span>\n</code></pre>\n<p>As for the first path (&#39;str&#39; is nil, line 1005), it will call<br>\nstrio_substr() with an invalid &#39;len&#39; value, which doesn&#39;t matter because<br>\nstrio_substr() corrects it:</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1005</span>      <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">NIL_P</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1006</span>      <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"n\">strio_substr</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span> <span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">);</span>\n  <span class=\"mi\">1007</span>      <span class=\"p\">}</span>\n</code></pre>\n<p>Within the second path (&#39;str&#39; is an empty string, line 1008), there is<br>\nthe risk of an OOB read here, because this routine&#39;s logic is based on<br>\nthe belief that &#39;e&#39; denotes the end of the buffer. &#39;p&#39; will never become<br>\n&#39;e&#39; because either 1) a null pointer dereference will occur (once it<br>\nreads at address 0x00000000) or 2) no \\n character is found before &#39;p&#39;<br>\nreaches an invalid memory page. In theory an attacker could use this<br>\nmishap to find the \\n character at various places in memory (by<br>\nadjusting the &#39;limit&#39; variable), but that is usually not very useful.<br>\n(The way an attacker can know at which the \\n character is found will<br>\nbecome clear later).</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1009</span>      <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">;</span>\n  <span class=\"mi\">1010</span>      <span class=\"nf\">while</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1011</span>          <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">++</span><span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1012</span>          <span class=\"k\">return</span> <span class=\"n\">Qnil</span><span class=\"p\">;</span>\n  <span class=\"mi\">1013</span>          <span class=\"p\">}</span>\n  <span class=\"mi\">1014</span>      <span class=\"p\">}</span>\n  <span class=\"mi\">1015</span>      <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n  <span class=\"mi\">1016</span>      <span class=\"nf\">while</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">memchr</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"o\">!=</span> <span class=\"n\">e</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1017</span>          <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">*++</span><span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1018</span>          <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">p</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"mi\">1019</span>          <span class=\"k\">break</span><span class=\"p\">;</span>\n  <span class=\"mi\">1020</span>          <span class=\"p\">}</span>\n  <span class=\"mi\">1021</span>      <span class=\"p\">}</span>\n  <span class=\"mi\">1022</span>      <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"n\">strio_substr</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span> <span class=\"n\">s</span> <span class=\"o\">-</span> <span class=\"n\">RSTRING_PTR</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">string</span><span class=\"p\">),</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">);</span>\n</code></pre>\n<p>The third path (&#39;str&#39; is 1 character large, line 1024) is similar to the<br>\nsecond path except that memchr is used to find the desired character:</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1025</span>      <span class=\"nf\">if</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">memchr</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">RSTRING_PTR</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">))</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1026</span>          <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">p</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"mi\">1027</span>      <span class=\"p\">}</span>\n  <span class=\"mi\">1028</span>      <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"n\">strio_substr</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span> <span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">);</span>\n</code></pre>\n<p>The fourth path is entered if &#39;str&#39; is 2 or more bytes large (line<br>\n1030). The first condition is always true if a very high &#39;limit&#39; value<br>\nis chosen (the premise of this vulnerability):</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1031</span>      <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n</code></pre>\n<p>The first subpath is never true in this case:</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1032</span>          <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1024</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n</code></pre>\n<p>So the second subpath is entered. This can be used to find the arbitrary<br>\nstring &#39;str&#39; across the totality of virtual memory:</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1040</span>          <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1041</span>          <span class=\"kt\">long</span> <span class=\"n\">skip</span><span class=\"p\">[</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">CHAR_BIT</span><span class=\"p\">],</span> <span class=\"n\">pos</span><span class=\"p\">;</span>\n  <span class=\"mi\">1042</span>          <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">RSTRING_PTR</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">);</span>\n  <span class=\"mi\">1043</span>          <span class=\"n\">bm_init_skip</span><span class=\"p\">(</span><span class=\"n\">skip</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n  <span class=\"mi\">1044</span>          <span class=\"nf\">if</span> <span class=\"p\">((</span><span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"n\">bm_search</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">skip</span><span class=\"p\">))</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"mi\">1045</span>              <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">pos</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"mi\">1046</span>          <span class=\"p\">}</span>\n  <span class=\"mi\">1047</span>          <span class=\"p\">}</span>\n</code></pre>\n<p>After any of these paths have been traversed, the attacker can read the<br>\n&#39;pos&#39; attribute to get the relative location of the string that has been<br>\nfound somewhere in memory:</p>\n<pre class=\"highlight c\"><code>  <span class=\"mi\">1051</span>      <span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"n\">e</span> <span class=\"o\">-</span> <span class=\"n\">RSTRING_PTR</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">string</span><span class=\"p\">);</span>\n</code></pre>\n<p>By subtracting this current &#39;pos&#39; from the previous &#39;pos&#39; the attacker<br>\ncan know the position of string that was searched for relative to the<br>\nbase string.</p>\n\n<p>My hypothesis is that, if we assume that the attacker can control the<br>\n&#39;limit&#39; variable as well as the string that has to be searched for and<br>\nthey can invoke strio_getline an arbitrary number of times, they can<br>\nmake Ruby divulge arbitrary information such as private keys (if they<br>\nare loaded in memory), by searching for &#39;BEGIN PGP PRIVATE KEY BLOCK&#39;<br>\nand adjust the &#39;limit&#39; parameter in combination with all alphanumeric<br>\ncharacters to deduce the entire base64-encoded private key.</p>\n\n<p>Note that a pointer address can naturally be very high (on 32 bit<br>\nanyway), such as 0xFFFF0000. In that event, a &#39;limit&#39; of 0x10000 can be<br>\nenough to overflow this computation:</p>\n<pre class=\"highlight c\"><code><span class=\"mi\">1002</span>     <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">limit</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">limit</span> <span class=\"o\">&lt;</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n</code></pre>\n<p>Here is code that can be used to trigger the vulnerability.</p>\n<pre class=\"highlight ruby\"><code><span class=\"nb\">require</span> <span class=\"s2\">&quot;stringio&quot;</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"no\">StringIO</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nf\">puts</span><span class=\"p\">(</span><span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nf\">rewind</span><span class=\"p\">()</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nf\">gets</span><span class=\"p\">(</span><span class=\"s1\">&#39;xxx&#39;</span><span class=\"p\">,</span> <span class=\"mh\">0x7FFFFFFFFFFFFFF0</span><span class=\"p\">)</span>\n<span class=\"nb\">puts</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nf\">pos</span><span class=\"p\">)</span>\n</code></pre>\n<p>The vulnerability is more likely to trigger on 32 bit than on 64 bit,<br>\nsince on 32 bit, the chance that the base string is allocated beyond the<br>\nhalf of the virtual address space (0x80000000 or above, like 0xBF000000<br>\nin my initial example) than on 64 bit (where it needs to be allocated at<br>\n0x8000000000000000 or above). I did all of my testing on 32 bit.</p>\n\n<p>Please let me know if you request a CVE, or if you need more information<br>\nfrom me.</p>\n\n<p>Guido</p>\n", 
    "vulnerability_information": "(originally send by e-mail on 4 Jun 2016)\n\nThe problem is this line in ext/stringio/stringio.c strio_getline():\n\n```c\n1002     if (limit > 0 && s + limit < e) {\n1003     e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n1004     }\n```\n\nThis works as intended as long as the sum of s (pointer) and limit\n(long) doesn't overflow. So if on a 32 bit system 's' happens to be\n0xBF000000, and limit is 0x7FFFFFFF, the sum of both values is\n0x3EFFFFFF, which is a completely unrelated address. From there, there\nare several paths to be chosen from based on what the first parameter to\nthe function is ('str').\n\n```c\n  1005\t    if (NIL_P(str)) {\n            ...\n            ...\n  1008\t    else if ((n = RSTRING_LEN(str)) == 0) {\n            ...\n            ...\n  1024\t    else if (n == 1) {\n            ...\n            ...\n  1030\t    else {\n            ...\n            ...\n```\n\nAll these paths eventually call strio_substr(). A wrong 'pos' parameter\nto this function is not possible because it was checked earlier:\n\n```c\n   996\t    if (ptr->pos >= (n = RSTRING_LEN(ptr->string))) {\n   997\t\treturn Qnil;\n   998\t    }\n```\n\na wrong 'len' parameter to this function doesn't matter as it will\ncorrect it itself:\n\n```c\n    98\tstatic VALUE\n    99\tstrio_substr(struct StringIO *ptr, long pos, long len)\n   100\t{\n   101\t    VALUE str = ptr->string;\n   102\t    rb_encoding *enc = get_enc(ptr);\n   103\t    long rlen = RSTRING_LEN(str) - pos;\n   104\t\n   105\t    if (len > rlen) len = rlen;\n   106\t    if (len < 0) len = 0;\n   107\t    if (len == 0) return rb_str_new(0,0);\n   108\t    return rb_enc_str_new(RSTRING_PTR(str)+pos, len, enc);\n   109\t}\n```\n\nAs for the first path ('str' is nil, line 1005), it will call\nstrio_substr() with an invalid 'len' value, which doesn't matter because\nstrio_substr() corrects it:\n\n```c\n  1005\t    if (NIL_P(str)) {\n  1006\t\tstr = strio_substr(ptr, ptr->pos, e - s);\n  1007\t    }\n```\n\nWithin the second path ('str' is an empty string, line 1008), there is\nthe risk of an OOB read here, because this routine's logic is based on\nthe belief that 'e' denotes the end of the buffer. 'p' will never become\n'e' because either 1) a null pointer dereference will occur (once it\nreads at address 0x00000000) or 2) no \\n character is found before 'p'\nreaches an invalid memory page. In theory an attacker could use this\nmishap to find the \\n character at various places in memory (by\nadjusting the 'limit' variable), but that is usually not very useful.\n(The way an attacker can know at which the \\n character is found will\nbecome clear later).\n\n```c\n  1009\t\tp = s;\n  1010\t\twhile (*p == '\\n') {\n  1011\t\t    if (++p == e) {\n  1012\t\t\treturn Qnil;\n  1013\t\t    }\n  1014\t\t}\n  1015\t\ts = p;\n  1016\t\twhile ((p = memchr(p, '\\n', e - p)) && (p != e)) {\n  1017\t\t    if (*++p == '\\n') {\n  1018\t\t\te = p + 1;\n  1019\t\t\tbreak;\n  1020\t\t    }\n  1021\t\t}\n  1022\t\tstr = strio_substr(ptr, s - RSTRING_PTR(ptr->string), e - s);\n```\n\nThe third path ('str' is 1 character large, line 1024) is similar to the\nsecond path except that memchr is used to find the desired character:\n\n```c\n  1025\t\tif ((p = memchr(s, RSTRING_PTR(str)[0], e - s)) != 0) {\n  1026\t\t    e = p + 1;\n  1027\t\t}\n  1028\t\tstr = strio_substr(ptr, ptr->pos, e - s);\n```\n\nThe fourth path is entered if 'str' is 2 or more bytes large (line\n1030). The first condition is always true if a very high 'limit' value\nis chosen (the premise of this vulnerability):\n\n```c\n  1031\t\tif (n < e - s) {\n```\n\nThe first subpath is never true in this case:\n\n```c\n  1032\t\t    if (e - s < 1024) {\n```\n\nSo the second subpath is entered. This can be used to find the arbitrary\nstring 'str' across the totality of virtual memory:\n\n```c\n  1040\t\t    else {\n  1041\t\t\tlong skip[1 << CHAR_BIT], pos;\n  1042\t\t\tp = RSTRING_PTR(str);\n  1043\t\t\tbm_init_skip(skip, p, n);\n  1044\t\t\tif ((pos = bm_search(p, n, s, e - s, skip)) >= 0) {\n  1045\t\t\t    e = s + pos + n;\n  1046\t\t\t}\n  1047\t\t    }\n```\n\nAfter any of these paths have been traversed, the attacker can read the\n'pos' attribute to get the relative location of the string that has been\nfound somewhere in memory:\n\n```c\n  1051\t    ptr->pos = e - RSTRING_PTR(ptr->string);\n```\n\nBy subtracting this current 'pos' from the previous 'pos' the attacker\ncan know the position of string that was searched for relative to the\nbase string.\n\nMy hypothesis is that, if we assume that the attacker can control the\n'limit' variable as well as the string that has to be searched for and\nthey can invoke strio_getline an arbitrary number of times, they can\nmake Ruby divulge arbitrary information such as private keys (if they\nare loaded in memory), by searching for 'BEGIN PGP PRIVATE KEY BLOCK'\nand adjust the 'limit' parameter in combination with all alphanumeric\ncharacters to deduce the entire base64-encoded private key.\n\nNote that a pointer address can naturally be very high (on 32 bit\nanyway), such as 0xFFFF0000. In that event, a 'limit' of 0x10000 can be\nenough to overflow this computation:\n\n```c\n1002     if (limit > 0 && s + limit < e) {\n```\n\nHere is code that can be used to trigger the vulnerability.\n\n```ruby\nrequire \"stringio\"\ns = StringIO.new\ns.puts(\"abc\")\ns.rewind()\nx = s.gets('xxx', 0x7FFFFFFFFFFFFFF0)\nputs(s.pos)\n```\n\nThe vulnerability is more likely to trigger on 32 bit than on 64 bit,\nsince on 32 bit, the chance that the base string is allocated beyond the\nhalf of the virtual address space (0x80000000 or above, like 0xBF000000\nin my initial example) than on 64 bit (where it needs to be allocated at\n0x8000000000000000 or above). I did all of my testing on 32 bit.\n\nPlease let me know if you request a CVE, or if you need more information\nfrom me.\n\nGuido", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "https://www.ruby-lang.org", 
            "about": "A Programmer's Best Friend", 
            "twitter_handle": "", 
            "name": "Ruby"
        }, 
        "handle": "ruby", 
        "url": "https://hackerone.com/ruby", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/007/724/36e273f967b252ae8b4051d09ffc08f7de16d7d5_small.png?1449271894", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/007/724/0c1556227f51c9b2b13ada11ccd2fb02cc9fa257_medium.png?1449271894"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 7724, 
        "default_currency": "usd"
    }, 
    "is_published": false
}