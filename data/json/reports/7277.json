{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [
        "madrobot", 
        "dhanunjaya", 
        "4mit44"
    ], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "7500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 7277, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2014-03-03T15:20:55.000Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "TLS Triple Handshake Attack", 
    "is_member_of_team?": null, 
    "vote_count": 3, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": null, 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$7,500", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2014-04-12T03:29:00.464Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2014-04-12T03:29:00.464Z", 
            "actor": {
                "url": "/internet", 
                "profile": {
                    "name": "The Internet"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/38e952fcff2c0aae0d011d5cecd07e5f62ecbd63_medium.png?1383767658"
                }
            }, 
            "team_handle": "internet", 
            "bounty_amount": "7500.0", 
            "collaborator": {
                "username": "prosecco-inria", 
                "url": "/prosecco-inria"
            }, 
            "message": "", 
            "markdown_message": "", 
            "type": "Activities::BountyAwarded", 
            "id": 29174, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "prosecco-inria", 
                "url": "/prosecco-inria"
            }, 
            "created_at": "2014-04-12T03:29:00.464Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-09-15T13:28:48.881Z", 
            "actor": {
                "url": "/internet", 
                "profile": {
                    "name": "The Internet"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/38e952fcff2c0aae0d011d5cecd07e5f62ecbd63_medium.png?1383767658"
                }
            }, 
            "team_handle": "internet", 
            "message": null, 
            "markdown_message": "", 
            "type": "Activities::BugResolved", 
            "id": 1196071, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "reporter": {
        "username": "prosecco-inria", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/prosecco-inria", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/001/622/06e317acc9529dca34da7a48120cf52e2901e539_small.jpg?1425571167"
        }, 
        "is_me?": false
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "disclosed_at": "2014-03-03T15:20:55.000Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/7277", 
    "created_at": "2014-03-03T15:20:55.000Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p>More details are at <a title=\"https://secure-resumption.com\" href=\"/redirect?signature=5aa4f15cf2d9192fb038cfe264b356ce13b274a5&amp;url=https%3A%2F%2Fsecure-resumption.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure-resumption.com</span><i class=\"icon-external-link\"></i></a> [2]</p>\n\n<h1 id=\"scenario\">Scenario</h1>\n\n<p>Consider a client C that normally authenticates to a server S using a client certificate.  If C uses the same certificate to authenticate to a malicious server M, then we show that M can use C&#39;s certificate to authenticate its own connection to S.</p>\n\n<p>The attack relies on the combination of an initial RSA or DHE handshake, followed by session resumption on a new connection, followed by a client-authenticated renegotiation. During the first two handshakes, C has a connection to M and M has a connection to S. During the third handshake, M is able to authenticate as C to S and as S to C.</p>\n\n<p>This server-based man-in-the-middle attack should normally have been prevented by the Renegotiation Indication (RI) extension [3] but by injecting session resumption between the two full handshakes, we are able to bypass the renegotiation countermeasure.</p>\n\n<h1 id=\"triple-handshake-attack\">Triple Handshake Attack</h1>\n\n<p>I&#39;ll briefly summarise the attack below for an initial RSA key exchange.  The webpage [2] has diagrams that will be easier to follow, describes more attack variants, and provides some disclosure status.</p>\n\n<p>The attack proceeds in three steps:</p>\n\n<p>Step 1. (Initial Handshakes C-M, M-S)</p>\n\n<ul>\n<li>C connects to M and M connects to S, both handshakes use RSA.</li>\n<li>M forwards C&#39;s and S&#39;s client hellos to each other.</li>\n<li>M receives an encrypted PMS from C and reencrypts it towards S.</li>\n<li>Both handshakes complete with new sessions and record keys.</li>\n<li>Both sessions have the same master secret, random nonces, and session id.  (M knows the master secret and record keys since it participated in both handshakes)</li>\n</ul>\n\n<p>Step 2. (Session Resumption C-M, M-S)</p>\n\n<ul>\n<li>C resumes its session with M on a new connection.<br>\n</li>\n<li>M resumes its session with S on a new connection.</li>\n<li>M forwards all the abbreviated handshake messages unchanged between C and S.</li>\n<li>Note that the RI extensions on both handshakes are empty, since it is the first handshake on the connection</li>\n<li>Both handshakes complete with new record keys (and reuse old sessions)</li>\n<li>Both connections have the same record keys and handshake logs (verify data)\n(M still knows the record keys and can send messages in either direction.)</li>\n</ul>\n\n<p>Step 3. (Renegotiation C-M-S)</p>\n\n<ul>\n<li>S requests M for renegotiation with client certificate. </li>\n<li>M requests C for renegotiation with client certificate.</li>\n<li>M forwards all renegotiation messages unchanged between C and S </li>\n<li>Note that since the handshake logs in the preceding handshake were the same, the RI extensions on both handshakes will be the same.</li>\n<li>Both handshakes complete with new mutually-authenticated sessions and record keys. C now thinks it is connected to S and S thinks it is connected to C.</li>\n<li>(M does not know the new record keys but its previous messages to S on the same connection \nmay be treated as authenticated by C.)</li>\n</ul>\n\n<p>At the end of Step 3, S has an incoming connection on which it initially received data from an anonymous client (M) and later received data from an authenticated client (C). This breaks the intended guarantees of the RI extension.</p>\n\n<h1 id=\"countermeasures\">Countermeasures </h1>\n\n<p>During Step 3, C has a connection on which it first received M&#39;s certificate and later S&#39;s certificate. If C refuses to accept this change of server identity, then it can prevent Step 3 of the attack. Indeed, we recommend mainstream web browsers and HTTPS libraries should systematically forbid the change of server identities during renegotiation.</p>\n\n<p>However, already at the end of Step 2, a number of connection and session parameters, such as the tls-unique channel binding for the two connections are the same. So any application-level mechanism that relies on the TLS master secret [4] or channel bindings [5] or exports TLS keying material [6] is vulnerable to a similar man-in-the-middle attack.</p>\n\n<p>We argue that the core vulnerability here is that the TLS master secret is not bound to enough elements of the TLS session. We propose a new TLS extension that binds the master secret to the hash of the all relevant handshake messages in the initial handshake.</p>\n\n<p>The proposed draft is available at: <a title=\"http://secure-resumption.com/draft-bhargavan-tls-session-hash-00.txt\" href=\"/redirect?signature=ae983e011612b50ee7d7d8e32d518dd6eeb4e883&amp;url=http%3A%2F%2Fsecure-resumption.com%2Fdraft-bhargavan-tls-session-hash-00.txt\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://secure-resumption.com/draft-bhargavan-tls-session-hash-00.txt</span><i class=\"icon-external-link\"></i></a></p>\n\n<p>The key idea is that each full handshake is associated with a session hash, computed as</p>\n<pre class=\"highlight plaintext\"><code>    session_hash = Hash(handshake_messages) \n</code></pre>\n<p>where handshake_messages consist of all messages up to and including the ClientKeyExchange.  The extended master secret computation enabled by the extension is then computed as</p>\n<pre class=\"highlight plaintext\"><code>    master_secret = PRF(pre_master_secret, \n                                        &quot;extended master secret&quot;, \n                                         session_hash) [0..47]; \n</code></pre>\n<p>We&#39;ve implemented this extension in OpenSSL without much difficulty.  Changing the master secret derivation may seem radical, but we believe it is the main way to counter future attacks that may rely on the session synchronization (step 1) that we exploit here.</p>\n\n<p>An alternative countermeasure would be an extension (along the lines of [3]) that includes the session hash as defined above in the ClientHello and ServerHello messages of the abbreviated handshake. This would provide an explicit link between the resumption handshake and its original full handshake, and hence prevent the renegotiation attack described above.</p>\n\n<p>We welcome comments and suggestions.<br>\n-Karthik Bhargavan, Antoine Delignat-Lavaud, and Alfredo Pironti</p>\n\n<p>[1] <a title=\"http://mitls.org\" href=\"/redirect?signature=805a6d0f5afb71737669ec907df37f5ce4339c31&amp;url=http%3A%2F%2Fmitls.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://mitls.org</span><i class=\"icon-external-link\"></i></a><br>\n[2] <a title=\"https://secure-resumption.com\" href=\"/redirect?signature=5aa4f15cf2d9192fb038cfe264b356ce13b274a5&amp;url=https%3A%2F%2Fsecure-resumption.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://secure-resumption.com</span><i class=\"icon-external-link\"></i></a><br>\n[3] RFC5746: Transport Layer Security Renegotiation Indication Extension<br>\n[4] The Compound Authentication Binding Problem (draft-puthenkulam-eap-binding-04)<br>\n[5] RFC5929: Channel Bindings for TLS<br>\n[6] RFC5705: Keying Material Exporters for Transport Layer Security</p>\n", 
    "vulnerability_information": "More details are at https://secure-resumption.com [2]\n\nScenario\n======\nConsider a client C that normally authenticates to a server S using a client certificate.  If C uses the same certificate to authenticate to a malicious server M, then we show that M can use C's certificate to authenticate its own connection to S.\n\nThe attack relies on the combination of an initial RSA or DHE handshake, followed by session resumption on a new connection, followed by a client-authenticated renegotiation. During the first two handshakes, C has a connection to M and M has a connection to S. During the third handshake, M is able to authenticate as C to S and as S to C.\n\nThis server-based man-in-the-middle attack should normally have been prevented by the Renegotiation Indication (RI) extension [3] but by injecting session resumption between the two full handshakes, we are able to bypass the renegotiation countermeasure.\n\nTriple Handshake Attack\n================\nI'll briefly summarise the attack below for an initial RSA key exchange.  The webpage [2] has diagrams that will be easier to follow, describes more attack variants, and provides some disclosure status.\n\nThe attack proceeds in three steps:\n\nStep 1. (Initial Handshakes C-M, M-S)\n\n- C connects to M and M connects to S, both handshakes use RSA.\n- M forwards C's and S's client hellos to each other.\n- M receives an encrypted PMS from C and reencrypts it towards S.\n- Both handshakes complete with new sessions and record keys.\n- Both sessions have the same master secret, random nonces, and session id.  (M knows the master secret and record keys since it participated in both handshakes)\n\nStep 2. (Session Resumption C-M, M-S)\n\n- C resumes its session with M on a new connection.\t     \n- M resumes its session with S on a new connection.\n- M forwards all the abbreviated handshake messages unchanged between C and S.\n- Note that the RI extensions on both handshakes are empty, since it is the first handshake on the connection\n- Both handshakes complete with new record keys (and reuse old sessions)\n- Both connections have the same record keys and handshake logs (verify data)\n  (M still knows the record keys and can send messages in either direction.)\n\nStep 3. (Renegotiation C-M-S)\n\n- S requests M for renegotiation with client certificate. \n- M requests C for renegotiation with client certificate.\n- M forwards all renegotiation messages unchanged between C and S \n- Note that since the handshake logs in the preceding handshake were the same, the RI extensions on both handshakes will be the same.\n- Both handshakes complete with new mutually-authenticated sessions and record keys. C now thinks it is connected to S and S thinks it is connected to C.\n- (M does not know the new record keys but its previous messages to S on the same connection \n  may be treated as authenticated by C.)\n\nAt the end of Step 3, S has an incoming connection on which it initially received data from an anonymous client (M) and later received data from an authenticated client (C). This breaks the intended guarantees of the RI extension.\n\nCountermeasures \n===========\nDuring Step 3, C has a connection on which it first received M's certificate and later S's certificate. If C refuses to accept this change of server identity, then it can prevent Step 3 of the attack. Indeed, we recommend mainstream web browsers and HTTPS libraries should systematically forbid the change of server identities during renegotiation.\n\nHowever, already at the end of Step 2, a number of connection and session parameters, such as the tls-unique channel binding for the two connections are the same. So any application-level mechanism that relies on the TLS master secret [4] or channel bindings [5] or exports TLS keying material [6] is vulnerable to a similar man-in-the-middle attack.\n\nWe argue that the core vulnerability here is that the TLS master secret is not bound to enough elements of the TLS session. We propose a new TLS extension that binds the master secret to the hash of the all relevant handshake messages in the initial handshake.\n\nThe proposed draft is available at: http://secure-resumption.com/draft-bhargavan-tls-session-hash-00.txt\n\nThe key idea is that each full handshake is associated with a session hash, computed as\n\t\n```\n\tsession_hash = Hash(handshake_messages) \n```\n\t\nwhere handshake_messages consist of all messages up to and including the ClientKeyExchange.  The extended master secret computation enabled by the extension is then computed as\n\t\n```\n\tmaster_secret = PRF(pre_master_secret, \n                                        \"extended master secret\", \n                                         session_hash) [0..47]; \n```\n\t\nWe've implemented this extension in OpenSSL without much difficulty.  Changing the master secret derivation may seem radical, but we believe it is the main way to counter future attacks that may rely on the session synchronization (step 1) that we exploit here.\n\nAn alternative countermeasure would be an extension (along the lines of [3]) that includes the session hash as defined above in the ClientHello and ServerHello messages of the abbreviated handshake. This would provide an explicit link between the resumption handshake and its original full handshake, and hence prevent the renegotiation attack described above.\n\nWe welcome comments and suggestions.\n-Karthik Bhargavan, Antoine Delignat-Lavaud, and Alfredo Pironti\n\n[1] http://mitls.org\n[2] https://secure-resumption.com\n[3] RFC5746: Transport Layer Security Renegotiation Indication Extension\n[4] The Compound Authentication Binding Problem (draft-puthenkulam-eap-binding-04)\n[5] RFC5929: Channel Bindings for TLS\n[6] RFC5705: Keying Material Exporters for Transport Layer Security\n", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "", 
            "about": "Hack all the things.", 
            "twitter_handle": null, 
            "name": "The Internet"
        }, 
        "handle": "internet", 
        "url": "https://hackerone.com/internet", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/020/b94983d2ec09553c3e08f98cc718cb17e01112e6_small.png?1383767658", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/020/38e952fcff2c0aae0d011d5cecd07e5f62ecbd63_medium.png?1383767658"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 20, 
        "default_currency": "usd"
    }, 
    "is_published": false
}